<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【转】Web前端知识体系精简]]></title>
    <url>%2Fblog%2F2017-06-20.Web%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E7%AE%80%2F</url>
    <content type="text"><![CDATA[Web前端技术由html、css和javascript三大部分构成，是一个庞大而复杂的技术体系，其复杂程度不低于任何一门后端语言。而我们在学习它的时候往往是先从某一个点切入，然后不断地接触和学习新的知识点，因此对于初学者很难理清楚整个体系的脉络结构。本文将对Web前端知识体系进行简单的梳理，对应的每个知识点点到为止，不作详细介绍。目的是帮助大家审查自己的知识结构是否完善，如有遗漏或不正确的地方，希望共勉。 #1 ##2 JAVASCRIPT 篇0、基础语法Javascript基础语法包括：变量定义、数据类型、循环、选择、内置对象等。 数据类型有string,number,boolean,null,undefined,object等。其中，string,number和boolean是基础类型,null和undefined是JS中的两个特殊类型,object是引用类型。 Javascript可以通过typeof来判断基础数据类型，但不能够准确判断引用类型, 因此需要用到另外一个方法，那就是Object的toString,关于数据类型及其判断可以参考以下博客：数据类型详解 和 判断JS数据类型的四种方法 JS常用的内置对象有Date、Array、JSON,RegExp等。 一般来讲，Date和Array用的最频繁，JSON可以对对象和数组进行序列化和反序列化，还有一个作用就是实现对象的深拷贝。 RegExp即正则表达式，是处理字符串的利器。 关于数据类型和正则表达式的介绍可以参考博客：ES5对数组增强的9个API 和 JS正则表达式精简 1、函数原型链Javascript虽然没有继承概念，但Javascript在函数Function对象中建立了原型对象prototype，并以Function对象为主线，从上至下，在内部构建了一条原型链。 简单来说就是建立了变量查找机制，当访问一个对象的属性时，先查找对象本身是否存在，如果不存在就去该对象所在的原型连上去找，直到Object对象为止，如果都没有找到该属性才会返回undefined。 因此我们经常会利用函数的原型机制来实现JS继承。关于函数原型链可参考博客：JS原型对象和原型链 2、函数作用域函数作用域就是变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。在JS中没有会块级作用域，只有函数作用域，因此JS中还存在着另外一种怪异现象，那就是变量提升。关于作用域的介绍请参考博客：函数的作用域和作用域链 3、函数指针 thisthis 存在于函数中，它指向的是该函数在运行时被调用的那个对象。在实际项目中，遇到this的坑比较多，因此需要对this作深入的理解。 Function对象还提供了call、apply和bind等方法来改变函数的this指向，其中call和apply主动执行函数，bind一般在事件回调中使用，而call和apply的区别只是参数的传递方式不同。关于call,apply和bind的用户请参考博客：详解JS的call,apply和bind 4、构造函数 newJS中的函数即可以是构造函数又可以当作普通函数来调用，当使用new来创建对象时，对应的函数就是构造函数，通过对象来调用时就是普通函数。 普通函数的创建有：显式声明、匿名定义、new Function() 等三种方式。 当通过new来创建一个新对象时，JS底层将新对象的原型链指向了构造函数的原型对象，于是就在新对象和函数对象之间建立了一条原型链，通过新对象可以访问到函数对象原型prototype中的方法和属性。new的详细介绍请参考博客：理解JS中的new运算符 5、闭包闭包其实是一个主动执行的代码块，这个代码块的特殊之处是可以永久保存局部变量，但又不污染全局变量，可以形成一个独立的执行过程，因此我们经常用闭包来定义组件。关于闭包的介绍请参考：干货分享：让你分分钟学会JS闭包 6、单线程和异步队列setTimeout和setInterval是JS内置的两个定时器，使用很简单，但这两个方法背后的原理却不简单。 我们知道，JS是单线程语言，在浏览器中，当JS代码被加载时，浏览器会为其分配一个主线程来执行任务(函数)，主线程会形成一个全局执行环境，执行环境采用栈的方式将待执行任务按顺序依次来执行。 但在浏览器中有一些任务是非常耗时的，比如http请求、定时器、事件回调等，为了保证其他任务的执行效率不被影响，JS在执行环境中维护了一个异步队列(也叫工作线程)，并将这些任务放入队列中进行等待，这些任务的执行时机并不确定，只有当主线程的任务执行完成以后，才会去检查异步队列中的任务是否需要开始执行。这就是为什么setTimeout(fn,0) 始终要等到最后执行的原因。关于单线程和异步队列问题请参考：setTimeout（0） 7、异步通讯 Ajax技术 Ajax是浏览器专门用来和服务器进行交互的异步通讯技术，其核心对象是XMLHttpRequest,通过该对象可以创建一个Ajax请求。为了防止XSS攻击，浏览器对Ajax做了限制，不允许Ajax跨域请求服务器,就是只能访问当前域名下的url。 当然，如果确信你的站点不存在跨域的风险，可以在服务端主动开启跨域请求。 也可以直接通过CORS或JSONP来实现。 JSONP是利用脚本(script)跨域能力来模拟Ajax请求。 CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 关于CORS的介绍请参考：跨域资源共享 CORS 详解 8、DOM对象 documentdocument对象里保存着整个web页面dom结构，在页面上所有的元素最终都会映射为一个dom对象。 document也提供了很多api来查找特定的dom对象，比如getElementById,querySelector等等。 9、事件系统 Event事件是用户与页面交互的基础，到目前为止，DOM事件从PC端的 鼠标事件(mouse) 发展到移动端的 触摸事件(touch) 和 手势事件(guesture) 由于DOM结构可能会多层嵌套，因此也衍生出了两种事件流：事件捕获和事件冒泡，后者最常用。利用事件冒泡机制可以实现很多功能，比如页面点击统计。关于两种事件流的介绍请参考：事件冒泡和捕获 除此之外，在页面初始化、滚动、隐藏、返回等操作时分别内置了onload/onDOMContentLoaded、onscroll、onvisibility和onhashchange等事件，如果想要捕获这些事件，需要通过addEventLisener/attachEvent来进行绑定。 10、全局对象 window在JS中，当一段JS代码在浏览器中被加载执行，JS引擎会在内存中构建一个全局执行环境，执行环境的作用是保证所有的函数能按照正确的顺序被执行，而window对象则是这个执行环境中的一个全局对象，window对象中内置了很多操作api和对象，document对象就是其中一个。关于JS执行环境的介绍请参考博客：深入理解JS执行细节 CSS 篇css是用来对html进行修饰的一门语言。 1、选择器css的选择器有很多种，常用的有类选择器、标签选择器、ID选择器、后代选择器、群组选择器、伪类选择器(before/after)、兄弟选择器(+~)、属性选择器等等。 2、定位 position定位一般有相对定位(relative)、绝对定位(absolute)、固定定位(fixed)，relative和absolute在移动端用的最多，fixed 在移动端有兼容性问题，因此不推荐使用，在移动端替代fixed的方案是 absolute+内部滚动。 3、浮动 float设置float为left或right，就能使该元素脱离文档流，向左或向右浮动。一般在做宫格模式布局时会用到，如果子元素全部设置为浮动，则父元素是塌陷的，这时就需要清除浮动，清除浮动的方法也很多，常用的方法是在元素末尾加空元素设置clear:both, 更高级一点的就给父容器设置before/after来模拟一个空元素，还可以直接设置overflow:auto/hidden。除过浮动可以实现宫格模式，行内盒子(inline-block)和table也可以。 4、盒子模型 Box盒子模型是css最重要的一个概念，也是css布局的基石。 常见的盒子模型有块级盒子(block)和行内盒子(inline-block)，盒子最关键的几个属性包括margin、border、padding和content,这几个元素可以设置盒子和盒子之间的关系以及盒子和内容之间的关系。还有一个问题是计算盒子的大小，需要注意的是，box-sizing属性的设置会影响盒子的width和height。只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。 5、弹性布局 FlexFlex布局的容器是一个伸缩容器，首先容器本身会更具容器中的元素动态设置自身大小；然后当Flex容器被应用一个大小时（width和height），将会自动调整容器中的元素适应新大小。Flex容器也可以设置伸缩比例和固定宽度，还可以设置容器中元素的排列方向（横向和纵向）和是否支持元素的自动换行。有了这个神器，做页面布局的可以方便很多了。注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 6、过渡 Transition 、旋转 Transform应用transform可以对元素进行平移(translate)、旋转(rotate)、放大缩小(scale)、倾斜(skew)等处理，而transition使css属性值(包括transform)在一段时间内平滑的过渡。使用transition和transform就可以实现页面的滑动切换效果。 7、动画 AnimationAnimation首先需要设置一个动画函数，然后以这个动画的方式来改变元素的css属性之的变化，动画可以被设置为永久循环演示。 和transition相比，animation设置动画效果更灵活更丰富，二者还有一个区别是：transition只能通过主动改变元素的css值才能触发动画效果，而animation一旦被应用，就开始执行动画。 8、雪碧图 sprite对于大型站点，为了减少http请求的次数，一般会将常用的小图标排到一个大图中，页面加载时只需请求一次网络， 然后在css中通过设置background-position来控制显示所需要的小图标。 9、字体图标 iconfont所谓字体图标就是将常用的图标转化为字体资源存在文件中，通过在CSS中引用该字体文件，然后可以直接通过控制字体的css属性来设置图标的样式，字体图标的好处是其不受屏幕分辨率的影响，并且可以任意修改图标的颜色。 HTML 篇1、Web语义化 和 SEOhtml 常规标签有html,head,body,div,span,table,ul,ol,dl,p,b,h1~h6,strong,form,input,img,em,i 等等，另外html5 还新增了很多语义化的标签，比如header,acticle,aside,section,footer,audio,radio 等等。 Web语义化是指使用语义恰当的标签，使页面有良好的结构，页面元素有含义，能够让人和搜索引擎都容易理解。 SEO是指在了解搜索引擎自然排名机制的基础之上，对网站进行内部及外部的调整优化，改进网站在搜索引擎中关键词的自然排名，获得更多的展现量，吸引更多目标客户点击访问网站，从而达到互联网营销及品牌建设的目标。 搜索引擎通过爬虫技术获取的页面就是由一堆html标签组成的代码,，人可以通过可视化的方式来判断页面上哪些内容是重点，而机器做不到。 但搜索引擎会根据标签的含义来判断内容的权重，因此，在合适的位置使用恰当的标签，使整个页面的语义明确，结构清晰，搜索引擎才能正确识别页面中的重要内容，并予以较高的权值。比如h1~h6这几个标签在SEO中的权值非常高，用它们作页面的标题就是一个简单的SEO优化。 2、页面渲染机制页面渲染就是浏览器的渲染引擎将html代码根据CSS定义的规则显示在浏览器窗口中的过程。大致工作原理如下： 用户输入网址，浏览器向服务器发出请求，服务器返回html文件； 渲染引擎开始载入html代码，并将HTML中的标签转化为DOM节点，生成DOM树； 如果&lt;head&gt;中引用了外部css文件，则发出css文件请求，服务器返回该文件； 如果&lt;head&gt;中引用了外部js文件，则发出js文件请求，服务器返回该文件后开始运行； 渲染引擎继续载入html中的&lt;body&gt;部分的代码，并开始解析前面返回的css文件，然后根据css选择器计算出节点的样式，创建渲染树； 从根节点递归调用，计算每一个元素的大小、位置等，给每个节点所应该出现在屏幕上的精确坐标； 如果body中的&lt;img&gt;引用了图片资源，则立即向服务器发出请求，此时渲染引擎不会等待图片下载完毕，而是继续渲染后面的代码； 服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排版，因此引擎需要回过头来重新渲染这部分代码； 如果此时js脚本中运行了style.display=”none”, 布局被改变，引擎也需要重新渲染这部分代码； 直到&lt;/html&gt;为止，页面渲染完毕。 3、重绘和回流当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流。比如上面的img文件加载完成后就会引起回流，每个页面至少需要一次回流，就是在页面第一次加载的时候。 当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。 从上面可以看出，回流必将引起重绘，而重绘不一定会引起回流。 会引起重绘和回流的操作 添加、删除元素(回流+重绘) 隐藏元素，display:none(回流+重绘)，visibility:hidden(只重绘，不回流) 移动元素，比如改变top,left,transform的值，或者移动元素到另外一个父元素中。(重绘+回流) 对style的操作(对不同的属性操作，影响不一样) 还有一种是用户的操作，比如改变浏览器大小，改变浏览器的字体大小等(回流+重绘) 4、本地存储本地存储最原始的方式就是 cookie,cookie 是存放在本地浏览器的一段文本，数据以键值对的形式保存，可以设置过期时间。 但是 cookie 不适合大量数据的存储，因为每请求一次页面，cookie 都会发送给服务器，这使得 cookie 速度很慢而且效率也不高。因此cookie的大小被限制为4k左右(不同浏览器可能不同,分HOST)，如下所示： Firefox和Safari允许cookie多达4097个字节，包括名（name）、值（value）和等号。 Opera允许cookie多达4096个字节，包括：名（name）、值（value）和等号。 Internet Explorer允许cookie多达4095个字节，包括：名（name）、值（value）和等号。 在所有浏览器中，任何cookie大小超过限制都被忽略，且永远不会被设置。 html5提供了两种在客户端存储数据的新方法：localStorage 和 sessionStorage, 它们都是以key/value 的形式来存储数据，前者是永久存储，后者的存储期限仅限于浏览器会话(session),即当浏览器窗口关闭后，sessionStorage中的数据被清除。 localStorage的存储空间大约5M左右(不同浏览器可能不同，分 HOST)，这个相当于一个5M大小的前端页面的数据库，相比于cookie可以节约带宽，但localStorage在浏览器隐私模式下是不可读取的，当存储数据超过了localStorage的存储空间后会抛出异常。 此外，H5还提供了逆天的websql和indexedDB,允许前端以关系型数据库的方式来存储本地数据，相对来说，这个功能目前应用的场景比较少，此处不作介绍。 5、浏览器缓存机制浏览器缓存机制是指通过 HTTP 协议头里的 Cache-Control（或 Expires）和 Last-Modified（或 Etag）等字段来控制文件缓存的机制。 Cache-Control 用于控制文件在本地缓存有效时长。最常见的，比如服务器回包：Cache-Control:max-age=600 表示文件在本地应该缓存，且有效时长是600秒（从发出请求算起）。在接下来600秒内，如果有请求这个资源，浏览器不会发出 HTTP 请求，而是直接使用本地缓存的文件。 Last-Modified 是标识文件在服务器上的最新更新时间。下次请求时，如果文件缓存过期，浏览器通过 If-Modified-Since 字段带上这个时间，发送给服务器，由服务器比较时间戳来判断文件是否有修改。如果没有修改，服务器返回304告诉浏览器继续使用缓存；如果有修改，则返回200，同时返回最新的文件。 Cache-Control 通常与 Last-Modified 一起使用。一个用于控制缓存有效时间，一个在缓存失效后，向服务查询是否有更新。 Cache-Control 还有一个同功能的字段：Expires。Expires 的值一个绝对的时间点，如：Expires: Thu, 10 Nov 2015 08:45:11 GMT，表示在这个时间点之前，缓存都是有效的。 Expires 是 HTTP1.0 标准中的字段，Cache-Control 是 HTTP1.1 标准中新加的字段，功能一样，都是控制缓存的有效时间。当这两个字段同时出现时，Cache-Control 是高优化级的。 Etag 也是和 Last-Modified 一样，对文件进行标识的字段。不同的是，Etag 的取值是一个对文件进行标识的特征字串。在向服务器查询文件是否有更新时，浏览器通过 If-None-Match 字段把特征字串发送给服务器，由服务器和文件最新特征字串进行匹配，来判断文件是否有更新。没有更新回包304，有更新回包200。Etag 和 Last-Modified 可根据需求使用一个或两个同时使用。两个同时使用时，只要满足基中一个条件，就认为文件没有更新。 另外有两种特殊的情况： 手动刷新页面（F5)，浏览器会直接认为缓存已经过期（可能缓存还没有过期），在请求中加上字段：Cache-Control:max-age=0，发包向服务器查询是否有文件是否有更新。 强制刷新页面（Ctrl+F5)，浏览器会直接忽略本地的缓存（有缓存也会认为本地没有缓存），在请求中加上字段：Cache-Control:no-cache（或 Pragma:no-cache），发包向服务重新拉取文件。 6、History操作用户访问网页的历史记录通常会被保存在一个类似于栈的对象中，即history对象，点击返回就出栈，跳下一页就入栈。 它提供了以下方法来操作页面的前进和后退： window.history.back() 返回到上一个页面 window.history.forward() 进入到下一个页面 window.history.go([delta]) 跳转到指定页面 HTML5 对History Api 进行了增强，新增了两个Api和一个事件，分别是pushState、replaceState 和 onpopstate pushState是往history对象里添加一个新的历史记录，即压栈。 replaceState 是替换history对象中的当前历史记录。 当点击浏览器后退按钮或 js调用history.back都会触发onpopstate事件。 与其类似的还有一个事件: onhashchange，onhashchange是老API, 浏览器支持度高, 本来是用来监听hash变化的, 但可以被利用来做客户端前进和后退事件的监听，而onpopstate是专门用来监听浏览器前进后退的, 不仅可以支持hash, 非hash的同源url也支持。 7、HTML5离线缓存HTML5离线缓存又叫Application Cache，是从浏览器的缓存中分出来的一块缓存区，如果要在这个缓存中保存数据，可以使用一个描述文件（manifest file），列出要下载和缓存的资源。 manifest 文件是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容）。manifest 文件可分为三个部分： CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存 NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存 FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面） 离线缓存为应用带来三个优势： 离线浏览 - 用户可在应用离线时使用它们 速度 - 已缓存资源加载得更快 减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。 8、Canvas 和 SVGCanvas 通过Javascript 来绘制 2D 图形。Canvas 是逐像素进行渲染的。在 Canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。 SVG 是一种使用 XML 描述 2D 图形的语言。SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。你可以为某个元素附加 JavaScript 事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。 Canvas和SVG相比，canvas更依赖于分辨率，不支持事件处理器，文本渲染能力弱，比较适合密集型游戏，其中的许多对象会被频繁绘制，而svg则比较适用于类似谷歌地图带有大型渲染区域的应用程序。 by @一像素 2017.06 分类: CSS3,HTML5,JS 标签: html, css, javascript, flexbox, seo, web, ajax, jsonp, cookie, canvas 转自 http://www.cnblogs.com/onepixel/p/7021506.html UI好看（尤其在移动端）， 截个图 。 可能主要是字体好看.]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>HTML</tag>
        <tag>CSS</tag>
        <tag>flexbox</tag>
        <tag>ajax</tag>
        <tag>jsonp</tag>
        <tag>cookie</tag>
        <tag>canvas</tag>
        <tag>seo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】并发队列-无界阻塞队列LinkedBlockingQueue原理探究]]></title>
    <url>%2Fblog%2F2017-06-19.%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97-%E6%97%A0%E7%95%8C%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97LinkedBlockingQueue%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[一、前言前面介绍了 使用CAS实现的非阻塞队列ConcurrentLinkedQueue，下面就来介绍下使用独占锁实现的阻塞队列LinkedBlockingQueue的实现。 二、 LinkedBlockingQueue类图结构 如图LinkedBlockingQueue中也有两个Node分别用来存放首尾节点，并且里面有个初始值为0的原子变量count用来记录队列元素个数，另外里面有两个ReentrantLock的独占锁，分别用来控制元素入队和出队加锁，其中takeLock用来控制同时只有一个线程可以从队列获取元素，其他线程必须等待，putLock控制同时只能有一个线程可以获取锁去添加元素，其他线程必须等待。另外notEmpty和notFull用来实现入队和出队的同步。 另外由于出入队是两个非公平独占锁，所以可以同时又一个线程入队和一个线程出队，其实这个是个生产者-消费者模型。 1234567891011/** Lock held by take, poll, etc */private final ReentrantLock takeLock = new ReentrantLock();/** Wait queue for waiting takes */private final Condition notEmpty = takeLock.newCondition();/** Lock held by put, offer, etc */private final ReentrantLock putLock = new ReentrantLock();/** Wait queue for waiting puts */private final Condition notFull = putLock.newCondition(); /* Current number of elements / 1private final AtomicInteger count = new AtomicInteger(0); 12345678910public static final int MAX_VALUE = 0x7fffffff;public LinkedBlockingQueue() &#123; this(Integer.MAX_VALUE);&#125; public LinkedBlockingQueue(int capacity) &#123; if (capacity &lt;= 0) throw new IllegalArgumentException(); this.capacity = capacity; //初始化首尾节点 last = head = new Node&lt;E&gt;(null);&#125; 如图默认队列容量为0x7fffffff;用户也可以自己指定容量。 三、必备基础3.1 ReentrantLock可以参考 https://www.atatech.org/articles/80539?flag_data_from=active 3.2 条件变量（Condition）条件变量这里使用的是takeLock.newCondition()获取也就是说调用ReentrantLock的方法获取的，那么可预见Condition使用了ReentrantLock的state。上面的参考没有提到所以这里串串讲下 首先看下类图结构 如图ConditionObject中两个node分别用来存放条件队列的首尾节点，条件队列就是调用条件变量的await方法被阻塞后的节点组成的单向链表。另外ConditionObject还要依赖AQS的state，ConditionObject是AQS类的一个内部类。 awaitNanos操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public final long awaitNanos(long nanosTimeout) throws InterruptedException &#123; //如果中断标志被设置了，则抛异常 if (Thread.interrupted()) throw new InterruptedException(); //添加当前线程节点到条件队列， Node node = addConditionWaiter(); //当前线程释放独占锁 int savedState = fullyRelease(node); long lastTime = System.nanoTime(); int interruptMode = 0; while (!isOnSyncQueue(node)) &#123; if (nanosTimeout &lt;= 0L) &#123; transferAfterCancelledWait(node); break; &#125; //挂起当前线程直到超时 LockSupport.parkNanos(this, nanosTimeout); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; long now = System.nanoTime(); nanosTimeout -= now - lastTime; lastTime = now; &#125; //unpark后，当前线程重新获取锁，有可能获取不到被放到AQS的队列 if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) unlinkCancelledWaiters(); if (interruptMode != 0) reportInterruptAfterWait(interruptMode); return nanosTimeout - (System.nanoTime() - lastTime);&#125;final int fullyRelease(Node node) &#123; boolean failed = true; try &#123; int savedState = getState(); //释放锁，如果失败则抛异常 if (release(savedState)) &#123; failed = false; return savedState; &#125; else &#123; throw new IllegalMonitorStateException(); &#125; &#125; finally &#123; if (failed) node.waitStatus = Node.CANCELLED; &#125;&#125; 首先如果当前线程中断标志被设置了，直接抛出异常。添加当前线程节点（状态为：-2）到条件队列。 然后尝试释放当前线程拥有的锁并保存当前计数，可知如果当前线程调用awaitNano前没有使用当前条件变量所在的Reetenlock变量调用lock或者lockInterruptibly获取到锁,会抛出IllegalMonitorStateException异常。 然后调用park挂起当前线程直到超时或者其他线程调用了当前线程的unpark方法，或者调用了当前线程的interupt方法（这时候会抛异常）。 如果超时或者其他线程调用了当前线程的unpark方法，则当前线程从挂起变为激活，获取cpu资源后会继续执行，会重新获取锁。 signal操作 12345678910111213141516171819202122232425262728293031public final void signal() &#123; //如果当前线程没有持有锁，抛异常 if (!isHeldExclusively()) throw new IllegalMonitorStateException(); //从条件队列找第一个状态为CONDITION的，然后把状态变为0 Node first = firstWaiter; if (first != null) doSignal(first);&#125;private void doSignal(Node first) &#123; do &#123; if ( (firstWaiter = first.nextWaiter) == null) lastWaiter = null; first.nextWaiter = null; &#125; while (!transferForSignal(first) &amp;&amp; (first = firstWaiter) != null);&#125;final boolean transferForSignal(Node node) &#123; //状态为CONDITION的，然后把状态变为0 if (!compareAndSetWaitStatus(node, Node.CONDITION, 0)) return false; //把条件队列的上面状态为0的节点放入AQS阻塞队列 Node p = enq(node); int ws = p.waitStatus; //调用unpark激活挂起的线程 if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) LockSupport.unpark(node.thread); return true;&#125; 首先看调用signal的线程是不是持有了独占锁，没有则抛出异常。 然后获取在条件队列里面待的时间最长的node,把它移动到线程持有的锁所在的AQS队列。 其中enq方法就是把当前节点放入了AQS队列，但是这时候该节点还是在条件队列里面那，那么什么时候从条件队列移除那？其实在await里面的unlinkCancelledWaiters方法。 总结： 无论是条件变量的await和singal都是需要先获取独占锁才能调用，因为条件变量使用的就是独占锁里面的state管理状态，否者会报异常。 四 、带超时时间的offer操作-生产者在队尾添加元素，如果队列满了，那么等待timeout时候，如果时间超时则返回false，如果在超时前队列有空余空间，则插入后返回true。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException &#123; //空元素抛空指针异常 if (e == null) throw new NullPointerException(); long nanos = unit.toNanos(timeout); int c = -1; final ReentrantLock putLock = this.putLock; final AtomicInteger count = this.count; //获取可被中断锁，只有一个线程克获取 putLock.lockInterruptibly(); try &#123; //如果队列满则进入循环 while (count.get() == capacity) &#123; //nanos&lt;=0直接返回 if (nanos &lt;= 0) return false; //否者调用await进行等待，超时则返回&lt;=0（1） nanos = notFull.awaitNanos(nanos); &#125; //await在超时时间内返回则添加元素（2） enqueue(new Node&lt;E&gt;(e)); c = count.getAndIncrement(); //队列不满则激活其他等待入队线程（3） if (c + 1 &lt; capacity) notFull.signal(); &#125; finally &#123; //释放锁 putLock.unlock(); &#125; //c==0说明队列里面有一个元素，这时候唤醒出队线程（4） if (c == 0) signalNotEmpty(); return true;&#125;private void enqueue(Node&lt;E&gt; node) &#123; last = last.next = node;&#125;private void signalNotEmpty() &#123; final ReentrantLock takeLock = this.takeLock; takeLock.lock(); try &#123; notEmpty.signal(); &#125; finally &#123; takeLock.unlock(); &#125;&#125; 如果获取锁前面有线程调用了putLock. interrupt(),并且后面没有调用interrupted()重置中断标志，调用lockInterruptibly时候会抛出InterruptedException异常。 队列满的时候调用notFull.awaitNanos阻塞当前线程，当前线程会释放获取的锁，然后等待超时或者其他线程调用了notFull.signal()才会返回并重新获取锁，或者其他线程调用了该线程的interrupt方法设置了中断标志，这时候也会返回但是会抛出InterruptedException异常。 如果超时则直接返回false，如果超时前调用了notFull.signal()则会退出循环，执行（2）添加元素到队列，然后执行（3），（3）的目的是为了激活其他入队等待线程。（4）的话c==0说明队列里面已经有一个元素了，这时候就可以激活等待出队线程了。 另外signalNotEmpty函数是先获取独占锁，然后在调用的signal这也证明了3.2节的结论。 五、 带超时时间的poll操作-消费者获取并移除队首元素，在指定的时间内去轮询队列看有没有首元素有则返回，否者超时后返回null 12345678910111213141516171819202122232425262728293031public E poll(long timeout, TimeUnit unit) throws InterruptedException &#123; E x = null; int c = -1; long nanos = unit.toNanos(timeout); final AtomicInteger count = this.count; final ReentrantLock takeLock = this.takeLock; //出队线程获取独占锁 takeLock.lockInterruptibly(); try &#123; //循环直到队列不为空 while (count.get() == 0) &#123; //超时直接返回null if (nanos &lt;= 0) return null; nanos = notEmpty.awaitNanos(nanos); &#125; //出队，计数器减一 x = dequeue(); c = count.getAndDecrement(); //如果出队前队列不为空则发送信号，激活其他阻塞的出队线程 if (c &gt; 1) notEmpty.signal(); &#125; finally &#123; //释放锁 takeLock.unlock(); &#125; //当前队列容量为最大值-1则激活入队线程。 if (c == capacity) signalNotFull(); return x;&#125; 首先获取独占锁，然后进入循环当当前队列有元素才会退出循环，或者超时了，直接返回null。 超时前退出循环后，就从队列移除元素，然后计数器减去一，如果减去1前队列元素大于1则说明当前移除后队列还有元素，那么就发信号激活其他可能阻塞到当前条件信号的线程。 最后如果减去1前队列元素个数=最大值，那么移除一个后会腾出一个空间来，这时候可以激活可能存在的入队阻塞线程。 六、put操作-生产者与带超时时间的poll类似不同在于put时候如果当前队列满了它会一直等待其他线程调用notFull.signal才会被唤醒。 七、 take操作-消费者与带超时时间的poll类似不同在于take时候如果当前队列空了它会一直等待其他线程调用notEmpty.signal()才会被唤醒。 八、 size操作当前队列元素个数，如代码直接使用原子变量count获取。 123public int size() &#123; return count.get();&#125; 九、peek操作获取但是不移除当前队列的头元素，没有则返回null 12345678910111213141516 public E peek() &#123; //队列空，则返回null if (count.get() == 0) return null; final ReentrantLock takeLock = this.takeLock; takeLock.lock(); try &#123; Node&lt;E&gt; first = head.next; if (first == null) return null; else return first.item; &#125; finally &#123; takeLock.unlock(); &#125;&#125; 十、 remove操作删除队列里面的一个元素，有则删除返回true，没有则返回false，在删除操作时候由于要遍历队列所以加了双重锁，也就是在删除过程中不允许入队也不允许出队操作 123456789101112131415161718192021222324252627282930313233343536373839public boolean remove(Object o) &#123; if (o == null) return false; //双重加锁 fullyLock(); try &#123; //遍历队列找则删除返回true for (Node&lt;E&gt; trail = head, p = trail.next; p != null; trail = p, p = p.next) &#123; if (o.equals(p.item)) &#123; unlink(p, trail); return true; &#125; &#125; //找不到返回false return false; &#125; finally &#123; //解锁 fullyUnlock(); &#125;&#125;void fullyLock() &#123; putLock.lock(); takeLock.lock();&#125;void fullyUnlock() &#123; takeLock.unlock(); putLock.unlock();&#125;void unlink(Node&lt;E&gt; p, Node&lt;E&gt; trail) &#123; p.item = null; trail.next = p.next; if (last == p) last = trail; //如果当前队列满，删除后，也不忘记最快的唤醒等待的线程 if (count.getAndDecrement() == capacity) notFull.signal();&#125; 十一、开源框架中使用首先线程池Executors的newFixedThreadPool和newSingleThreadExecutor的工作队列就是使用的这个。 然后tomcat中任务队列TaskQueue是继承并扩展了的，下面看看TaskQueue 11.1 类图结构 可知TaskQueue继承了LinkedBlockingQueue并且泛化类型固定了为Runnalbe.重写了offer,poll，take方法。 11.2 TaskQueuetomcat中有个线程池ThreadPoolExecutor，在NIOEndPoint中当acceptor线程接受到请求后，会把任务放入队列，然后poller 线程从队列里面获取任务，然后就吧任务放入线程池执行。这个ThreadPoolExecutor中的的一个参数就是TaskQueue。 先看看ThreadPoolExecutor的参数如果是普通LinkedBlockingQueue是怎么样的执行逻辑： 当调用线程池方法 execute() 方法添加一个任务时： 如果当前运行的线程数量小于 corePoolSize，则创建新线程运行该任务 如果当前运行的线程数量大于或等于 corePoolSize，则将这个任务放入阻塞队列。 如果当前队列满了，并且当前运行的线程数量小于 maximumPoolSize，则创建新线程运行该任务； 如果当前队列满了，并且当前运行的线程数量大于或等于 maximumPoolSize，那么线程池将会抛出RejectedExecutionException异常。 如果线程执行完了当前任务，那么会去队列里面获取一个任务来执行，如果任务执行完了，并且当前线程数大于corePoolSize，那么会根据线程空闲时间keepAliveTime回收一些线程保持线程池corePoolSize个线程。 首先看下线程池中exectue添加任务时候的逻辑： 123456789101112131415161718192021222324public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); //当前工作线程个数小于core个数则开新线程执行（1） int c = ctl.get(); if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; c = ctl.get(); &#125; //放入队列（2） if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; //如果队列满了则开新线程，但是个数要不超过最大值，超过则返回false //然后执行reject handler（3） else if (!addWorker(command, false)) reject(command);&#125; 可知当当前工作线程个数为corePoolSize后，如果在来任务会把任务添加到队列，队列满了或者入队失败了则开启新线程。 然后看看TaskQueue中重写的offer方法的逻辑： 123456789101112public boolean offer(Runnable o) &#123; // 如果parent为null则直接调用父类方法 if (parent==null) return super.offer(o); //如果当前线程池中线程个数达到最大，则无条件调用父类方法 if (parent.getPoolSize() == parent.getMaximumPoolSize()) return super.offer(o); //如果当前提交的任务小于当前线程池线程数，说明线程用不完，没必要重新开线程 if (parent.getSubmittedCount()&lt;(parent.getPoolSize())) return super.offer(o); //如果当前线程池线程个数&gt;core个数但是小于最大个数，则开新线程代替放入队列 if (parent.getPoolSize()&lt;parent.getMaximumPoolSize()) return false; //到了这里，无条件调用父类 return super.offer(o);&#125; 可知parent.getPoolSize()&lt;parent.getMaximumPoolSize()普通队列会把当前任务放入队列，TAskQueue则是返回false，因为这会开启新线程执行任务，当然前提是当前线程个数没有达到最大值。 然后看下Worker线程中如果从队列里面获取任务执行的： 123456789101112131415161718192021222324252627282930313233final void runWorker(Worker w) &#123; ... try &#123; while (task != null || (task = getTask()) != null) &#123; ... &#125; completedAbruptly = false; &#125; finally &#123; ... &#125;&#125;private Runnable getTask() &#123; boolean timedOut = false; // Did the last poll() time out? for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); ... int wc = workerCountOf(c); ... try &#123; //根据timed决定调用poll还是take Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null) return r; timedOut = true; &#125; catch (InterruptedException retry) &#123; timedOut = false; &#125; &#125;&#125; 十二、总结12.1 并发安全总结仔细思考下阻塞队列是如何实现并发安全的维护队列链表的，先分析下简单的情况就是当队列里面有多个元素时候，由于同时只有一个线程（通过独占锁putLock实现）入队元素并且是操作last节点（，而同时只有一个出队线程(通过独占锁takeLock实现）操作head节点，所以不存在并发安全问题。 考虑当队列为空的时候队列状态为： 这时候假如一个线程调用了take方法,由于队列为空，所以count.get()==0所以当前线程会调用notEmpty.await()把自己挂起，并且放入notEmpty的条件队列，并且释放当前条件变量关联的通过takeLock.lockInterruptibly()获取的独占锁。由于释放了锁，所以这时候其他线程调用take时候就会通过takeLock.lockInterruptibly()获取独占锁，然后同样阻塞到notEmpty.await()，同样会被放入notEmpty的条件队列，也就说在队列为空的情况下可能会有多个线程因为调用take被放入了notEmpty的条件队列。 这时候如果有一个线程调用了put方法，那么就会调用enqueue操作，该操作会在last节点后面添加新元素并且设置last为新节点。然后count.getAndIncrement()先获取当前队列元个数为0保存到c，然后自增count为1，由于c==0所以调用signalNotEmpty激活notEmpty的条件队列里面的阻塞时间最长的线程，这时候take中调用notEmpty.await()的线程会被激活await内部会重新去获取独占锁获取成功则返回，否者被放入AQS的阻塞队列，如果获取成功，那么count.get() &gt;0因为可能多个线程put了，所以调用dequeue从队列获取元素（这时候一定可以获取到），然后调用c = count.getAndDecrement() 把当前计数返回后并减去1，如果c&gt;1 说明当前队列还有其他元素，那么就调用 notEmpty.signal()去激活 notEmpty的条件队列里面的其他阻塞线程。 考虑当队列满的时候： 当队列满的时候调用put方法时候，会由于notFull.await()当前线程被阻塞放入notFull管理的条件队列里面，同理可能会有多个调用put方法的线程都放到了notFull的条件队列里面。 这时候如果有一个线程调用了take方法,调用dequeue()出队一个元素，c = count.getAndDecrement()；count值减一；c==capacity;现在队列有一个空的位置，所以调用signalNotFull()激活notFull条件队列里面等待最久的一个线程。 12.2简单对比LinkedBlockingQueue与ConcurrentLinkedQueue相比前者前者是阻塞队列使用可重入独占的非公平锁来实现通过使用put锁和take锁使得入队和出队解耦可以同时进行处理，但是同时只有一个线程可以入队或者出队，其他线程必须等待，另外引入了条件变量来进行入队和出队的同步，每个条件变量维护一个条件队列用来存放阻塞的线程，要注意这个队列和AQS的队列不是一个东东。LinkedBlockingQueue的size操作通过使用原子变量count获取能够比较精确的获取当前队列的元素个数，另外remove方法使用双锁保证删除时候队列元素保持不变，另外其实这个是个生产者-消费者模型。 而ConcurrentLinkedQueue则使用CAS非阻塞算法来实现，使用CAS原子操作保证链表构建的安全性，当多个线程并发时候CAS失败的线程不会被阻塞，而是使用cpu资源去轮询CAS直到成功，size方法先比LinkedBlockingQueue的获取的个数是不精确的，因为获取size的时候是通过遍历队列进行的，而遍历过程中可能进行增加删除操作,remove方法操作时候也没有对整个队列加锁，remove时候可能进行增加删除操作，这就可能删除了一个刚刚新增的元素，而不是删除的想要位置的。 欢迎看官们拍砖，让我们共同进步！ 原创文章，转载请注明： 转载自并发编程网 – ifeve.com本文链接地址: 并发队列-无界阻塞队列LinkedBlockingQueue原理探究]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】并发队列-无界阻塞优先级队列PriorityBlockingQueue原理探究]]></title>
    <url>%2Fblog%2F2017-06-19.%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97-%E6%97%A0%E7%95%8C%E9%98%BB%E5%A1%9E%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97PriorityBlockingQueue%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[一、 前言PriorityBlockingQueue是带优先级的无界阻塞队列，每次出队都返回优先级最高的元素，是二叉树最小堆的实现，研究过数组方式存放最小堆节点的都知道，直接遍历队列元素是无序的。 二、 PriorityBlockingQueue类图结构 如图PriorityBlockingQueue内部有个数组queue用来存放队列元素，size用来存放队列元素个数，allocationSpinLockOffset是用来在扩容队列时候做cas的，目的是保证只有一个线程可以进行扩容。由于这是一个优先级队列所以有个比较器comparator用来比较元素大小。lock独占锁对象用来控制同时只能有一个线程可以进行入队出队操作。notEmpty条件变量用来实现take方法阻塞模式。这里没有notFull 条件变量是因为这里的put操作是非阻塞的，为啥要设计为非阻塞的是因为这是无界队列。最后PriorityQueue q用来搞序列化的。 如下构造函数，默认队列容量为11，默认比较器为null; 12345678910111213141516private static final int DEFAULT_INITIAL_CAPACITY = 11;public PriorityBlockingQueue() &#123; this(DEFAULT_INITIAL_CAPACITY, null);&#125;public PriorityBlockingQueue(int initialCapacity) &#123; this(initialCapacity, null);&#125;public PriorityBlockingQueue(int initialCapacity, Comparator&lt;? super E&gt; comparator) &#123; if (initialCapacity &lt; 1) throw new IllegalArgumentException(); this.lock = new ReentrantLock(); this.notEmpty = lock.newCondition(); this.comparator = comparator; this.queue = new Object[initialCapacity];&#125; 三、 offer操作在队列插入一个元素，由于是无界队列，所以一直为成功返回true; 1234567891011121314151617181920212223242526public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); final ReentrantLock lock = this.lock; lock.lock(); int n, cap; Object[] array; //如果当前元素个数&gt;=队列容量，则扩容(1) while ((n = size) &gt;= (cap = (array = queue).length)) tryGrow(array, cap); try &#123; Comparator&lt;? super E&gt; cmp = comparator; //默认比较器为null if (cmp == null)(2) siftUpComparable(n, e, array); else //自定义比较器(3) siftUpUsingComparator(n, e, array, cmp); //队列元素增加1，并且激活notEmpty的条件队列里面的一个阻塞线程 size = n + 1;（9） notEmpty.signal(); &#125; finally &#123; lock.unlock(); &#125; return true;&#125; 主流程比较简单，下面看看两个主要函数 123456789101112131415161718192021222324252627282930313233private void tryGrow(Object[] array, int oldCap) &#123; lock.unlock(); //must release and then re-acquire main lock Object[] newArray = null; //cas成功则扩容(4) if (allocationSpinLock == 0 &amp;&amp; UNSAFE.compareAndSwapInt(this, allocationSpinLockOffset, 0, 1)) &#123; try &#123; //oldGap&lt;64则扩容新增oldcap+2,否者扩容50%，并且最大为MAX_ARRAY_SIZE int newCap = oldCap + ((oldCap &lt; 64) ? (oldCap + 2) : // grow faster if small (oldCap &gt;&gt; 1)); if (newCap - MAX_ARRAY_SIZE &gt; 0) &#123; // possible overflow int minCap = oldCap + 1; if (minCap &lt; 0 || minCap &gt; MAX_ARRAY_SIZE) throw new OutOfMemoryError(); newCap = MAX_ARRAY_SIZE; &#125; if (newCap &gt; oldCap &amp;&amp; queue == array) newArray = new Object[newCap]; &#125; finally &#123; allocationSpinLock = 0; &#125; &#125; //第一个线程cas成功后，第二个线程会进入这个地方，然后第二个线程让出cpu，尽量让第一个线程执行下面点获取锁，但是这得不到肯定的保证。(5) if (newArray == null) // back off if another thread is allocating Thread.yield(); lock.lock();(6) if (newArray != null &amp;&amp; queue == array) &#123; queue = newArray; System.arraycopy(array, 0, newArray, 0, oldCap); &#125;&#125; tryGrow目的是扩容，这里要思考下为啥在扩容前要先释放锁，然后使用cas控制只有一个线程可以扩容成功。我的理解是为了性能，因为扩容时候是需要花时间的，如果这些操作时候还占用锁那么其他线程在这个时候是不能进行出队操作的，也不能进行入队操作，这大大降低了并发性。 所以在扩容前释放锁，这允许其他出队线程可以进行出队操作，但是由于释放了锁，所以也允许在扩容时候进行入队操作，这就会导致多个线程进行扩容会出现问题，所以这里使用了一个spinlock用cas控制只有一个线程可以进行扩容，失败的线程调用Thread.yield()让出cpu，目的意在让扩容线程扩容后优先调用lock.lock重新获取锁，但是这得不到一定的保证，有可能调用Thread.yield()的线程先获取了锁。 那copy元素数据到新数组为啥放到获取锁后面那?原因应该是因为可见性问题，因为queue并没有被volatile修饰。另外有可能在扩容时候进行了出队操作，如果直接拷贝可能看到的数组元素不是最新的。而通过调用Lock后，获取的数组则是最新的，并且在释放锁前 数组内容不会变化。 具体建堆算法： 1234567891011121314private static &lt;T&gt; void siftUpComparable(int k, T x, Object[] array) &#123; Comparable&lt;? super T&gt; key = (Comparable&lt;? super T&gt;) x; //队列元素个数&gt;0则判断插入位置，否者直接入队(7) while (k &gt; 0) &#123; int parent = (k - 1) &gt;&gt;&gt; 1; Object e = array[parent]; if (key.compareTo((T) e) &gt;= 0) break; array[k] = e; k = parent; &#125; array[k] = key;(8)&#125; 下面用图说话模拟下过程：假设队列容量为2 第一次offer(2)时候 执行（1)为false所以执行（2），由于k=n=size=0;所以执行（8）元素入队，然执行（9）size+1;现在队列状态: 第二次offer(4)时候执行（1)为false，所以执行（2）由于k=1,所以进入while循环，parent=0;e=2;key=4;key&gt;e所以break;然后把4存到数据下标为1的地方，这时候队列状态为： 第三次offer(6)时候执行（1)为true,所以调用tryGrow,由于20进入循环 parent=0;e=2;key=6;key&gt;e所以break;然后把6放入下标为2的地方，现在队列状态： 第四次offer(1)时候执行（1)为false，所以执行（2）由于k=3,所以进入while循环，parent=0;e=2;key=1; key&lt;e；所以把2复制到数组下标为3的地方，然后k=0退出循环；然后把2存放到下标为0地方，现在状态： 四、 poll操作在队列头部获取并移除一个元素，如果队列为空，则返回null 123456789public E poll() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; return dequeue(); &#125; finally &#123; lock.unlock(); &#125;&#125; 主要看dequeue 12345678910111213141516171819202122232425private E dequeue() &#123; //队列为空，则返回null int n = size - 1; if (n &lt; 0) return null; else &#123; //获取队头元素(1) Object[] array = queue; E result = (E) array[0]; //获取对尾元素，并值null(2) E x = (E) array[n]; array[n] = null; Comparator&lt;? super E&gt; cmp = comparator; if (cmp == null)//cmp=null则调用这个，把对尾元素位置插入到0位置，并且调整堆为最小堆(3) siftDownComparable(0, x, array, n); else siftDownUsingComparator(0, x, array, n, cmp); size = n;（4） return result; &#125;&#125; 12345678910111213141516171819private static &lt;T&gt; void siftDownComparable(int k, T x, Object[] array,int n) &#123; if (n &gt; 0) &#123; Comparable&lt;? super T&gt; key = (Comparable&lt;? super T&gt;)x; int half = n &gt;&gt;&gt; 1; // loop while a non-leaf while (k &lt; half) &#123; int child = (k &lt;&lt; 1) + 1; // assume left child is least Object c = array[child];（5） int right = child + 1;（6) if (right &lt; n &amp;&amp; ((Comparable&lt;? super T&gt;) c).compareTo((T) array[right]) &gt; 0)(7) c = array[child = right]; if (key.compareTo((T) c) &lt;= 0)(8) break; array[k] = c; k = child; &#125; array[k] = key;(9) &#125;&#125; 下面用图说话模拟下过程： 第一次调用poll()首先执行（1） result=1；然后执行（2）x=2;这时候队列状态 然后执行（3）后状态为： 执行（4）后的结果： 下面重点说说siftDownComparable这个屌屌的建立最小堆的算法：首先说下思想，其中k一开始为0，x为数组里面最后一个元素，由于第0个元素为树根，被出队时候要被搞掉，所以建堆要从它的左右孩子节点找一个最小的值来当树根，子树根被搞掉后，会找子树的左右孩子最小的元素来代替，直到树节点为止，还不明白，没关系，看图说话：假如当前队列元素： 那么对于树为： 这时候如果调用了poll();那么result=2;x=11;现在树为： 然后看leftChildVal = 4;rightChildVal = 6; 44也就是key&gt;c；然后把c放入树根，现在树为： 然后看根的左边孩子4为根的子树我们要为这个字树找一个根节点看leftChildVal = 8;rightChildVal = 10; 88也就是key&gt;c；然后把c放入树根，现在树为： 这时候k=3;half=3所以推出循环，执行（9）后结果为： 这时候队列为： 五、 put操作内部调用的offer,由于是无界队列，所以不需要阻塞 123public void put(E e) &#123; offer(e); // never need to block&#125; 六、 take操作获取队列头元素，如果队列为空则阻塞。 1234567891011121314public E take() throws InterruptedException &#123; final ReentrantLock lock = this.lock; lock.lockInterruptibly(); E result; try &#123; //如果队列为空，则阻塞，把当前线程放入notEmpty的条件队列 while ( (result = dequeue()) == null) notEmpty.await(); &#125; finally &#123; lock.unlock(); &#125; return result;&#125; 这里是阻塞实现，阻塞后直到入队操作调用notEmpty.signal 才会返回。 七、 size操作获取队列元个数，由于加了独占锁所以返回结果是精确的 123456789public int size() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; return size; &#125; finally &#123; lock.unlock(); &#125;&#125; 八、 开源框架中使用目前还没找到.. 九、总结PriorityBlockingQueue始终保证出队的元素是优先级最高的元素而不是在队列里面停留时间最长的原始，并且可以定制优先级的规则，内部通过使用一个二叉树最小堆算法来维护内部数组，这个数组是可扩容的，当当前元素个数&gt;=最大容量时候会通过算法扩容，当队列任务里面的任务由优先级时候本队列比较实用。 PriorityBlockingQueue类似于ArrayBlockingQueue内部使用一个独占锁来控制同时只有一个线程可以进行入队和出队，另外前者只使用了一个notEmpty条件变量而没有notFull这是因为前者是无界队列，当put时候永远不会处于await所以也不需要被唤醒,并且take方法由于是阻塞方法，所以是可被中断的，其他方法对中断标志不理会。 值得注意的是为了避免在扩容操作时候其他线程不能进行出队操作，实现上使用了先释放锁，然后通过cas保证同时只有一个线程可以扩容成功。 原创文章，转载请注明： 转载自并发编程网 – ifeve.com本文链接地址: 并发队列-无界阻塞优先级队列PriorityBlockingQueue原理探究](http://ifeve.com/java-priorityblockingqueu/)]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】Html5拖放-15行js代码实现两个div内容互换]]></title>
    <url>%2Fblog%2F2017-06-16.html5%E6%8B%96%E6%94%BE-15%E8%A1%8Cjs%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AAdiv%E5%86%85%E5%AE%B9%E4%BA%92%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[html5拖放–15行js代码实现两个div内容互换 本文首发于我的个人博客:http://cherryblog.site/ ，欢迎大家前去参观本文项目地址，sortable插件地址：https://github.com/sunshine940326/sortable https://github.com/yafey/sortabledemo地址：https://github.com/sunshine940326/drag https://github.com/yafey/drag 在写我们后台的管理程序中需要有一个拖放的功能，然后我们有一个这样的功能，实现11个固定且大小不一的div互换，效果如下 最终效果图 作为一个小菜鸟，听到这样的消息我是蒙逼的= =，在网上找到一个插件，功能挺强大的 sortable插件 sortable插件 插件地址：https://github.com/sunshine940326/sortable 但是这个插件只能拖动和放置，不能交换，也就是只能将div插入在其他div前面，其余的向后推移，并且不能做到交换div中的内容，而div容器不变的条件，然后我就和其他同事商量了一下交换两个div中的数据要怎么处理，然后同事说这个就比较麻烦了= =。需要写死div，然后先记录鼠标拖动前的div中的内容，然后判断鼠标放下的位置，在哪一个div的范围内，再交换两个的数据= =，真正做起来还不知道有什么坑。听着都怕，于是就暂且搁置了这个功能，直到有一天非做不可了，我百度了一下“怎么交换两个div”，然后找到了一个demo，天啦噜~整个实现过程全部代码50行不到，js代码之后十几行，整个过程不到半个小时就解决了，★,°:.☆(￣▽￣)/$:.°★。撒花！效果如下： demo效果 demo地址：https://github.com/sunshine940326/drag查看代码，发现思路如下: ondragstart（ 用户开始拖动元素时触发）的时候使用该对象的dataTransfer.setData方法，并且用中间量记录点击的div ondragover (当某被拖动的对象在另一对象容器范围内拖动时触发此事件),拖动div的时候阻止拖动的默认事件（drop 事件的默认行为是以链接形式打开） ondrop (在一个拖动过程中，释放鼠标键时触发此事件)时候交换两个div的html百度了一下发现这是html的新特性drag，研究了一下有如下特点 拖放本例的代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;style type="text/css"&gt; #div1 &#123;float:left; width:100px; height:35px; margin:10px;padding:10px;border:1px solid #aaaaaa;&#125; #div2 &#123;float:left; width:200px; height:135px; margin:10px;padding:10px;border:1px solid #aaaaaa;&#125; &lt;/style&gt; &lt;script type="text/javascript"&gt; function allowDrop(ev) &#123; ev.preventDefault(); &#125; var srcdiv = null; function drag(ev,divdom) &#123; srcdiv=divdom; ev.dataTransfer.setData("text/html",divdom.innerHTML); &#125; function drop(ev,divdom) &#123; ev.preventDefault(); if(srcdiv != divdom)&#123; srcdiv.innerHTML = divdom.innerHTML; divdom.innerHTML=ev.dataTransfer.getData("text/html"); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="div1" ondrop="drop(event,this)" ondragover="allowDrop(event)" draggable="true" ondragstart="drag(event, this)"&gt; &lt;p&gt;ni hao!&lt;/p&gt;&lt;/div&gt;&lt;div id="div2" ondrop="drop(event,this)" ondragover="allowDrop(event)" draggable="true" ondragstart="drag(event, this)"&gt; &lt;p&gt;Hello world!&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 拖放是一种常见的特性，即抓取对象以后拖到另一个位置。在 HTML5 中，拖放是标准的一部分，任何元素都能够拖放。 设置元素为可拖放首先，为了使元素可拖动，把 draggable 属性设置为 true ：&lt;div draggable=&quot;true&quot;&gt;&lt;/div&gt; 设置ondragstart 和并保存数据ondragstart 属性调用了一个函数，drag(event,this)，它规定了被拖动的数据。dataTransfer.setData() 方法设置被拖数据的数据类型和值,在这个例子中，数据类型是 “text/html”，值是可拖动元素的innerHTML 1234function drag(ev,divdom)&#123; srcdiv=divdom; ev.dataTransfer.setData("text/html",divdom.innerHTML);&#125; 放到何处 - ondragoverondragover 事件规定在何处放置被拖动的数据。默认地，无法将数据/元素放置到其他元素中。如果需要设置允许放置，我们必须阻止对元素的默认处理方式。这要通过调用 ondragover 事件的 event.preventDefault() 方法：event.preventDefault() 123function allowDrop(ev)&#123; ev.preventDefault();&#125; 进行放置 - ondrop当放置被拖数据时，会发生 drop 事件。在上面的例子中，ondrop 属性调用了一个函数，drop(event)： 1234567 function drop(ev,divdom)&#123; ev.preventDefault(); if(srcdiv != divdom)&#123; srcdiv.innerHTML = divdom.innerHTML; divdom.innerHTML=ev.dataTransfer.getData("text/html"); &#125;&#125; 转自： https://juejin.im/post/59259b9a0ce4630058264046]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Css：【转】默认的checkbox、input、radio太丑了？我来教你改变使用纯css3改写的带动画的默认样式]]></title>
    <url>%2Fblog%2F2017-06-16.css%EF%BC%9A%E9%BB%98%E8%AE%A4%E7%9A%84checkbox%E3%80%81input%E3%80%81radio%E5%A4%AA%E4%B8%91%E4%BA%86%EF%BC%9F%E6%88%91%E6%9D%A5%E6%95%99%E4%BD%A0%E6%94%B9%E5%8F%98%E4%BD%BF%E7%94%A8%E7%BA%AFcss3%E6%94%B9%E5%86%99%E7%9A%84%E5%B8%A6%E5%8A%A8%E7%94%BB%E7%9A%84%E9%BB%98%E8%AE%A4%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[css：默认的checkbox、input、radio太丑了？我来教你改变使用纯css3改写的带动画的默认样式 项目的github地址为： https://github.com/sunshine940326/css3formeledemo 【github已经 fork】本文首发于我的个人博客，http://cherryblog.site/ ；欢迎大家查看我的其他博客最近在做公司后台的优化项目，拿到设计稿一看，设计师觉得默认的input、checkbox、radio太丑了，要优化，在做了几个demo之后找到了要怎么优化这些样式的方法，我优化的原则有以下几点： 因为是在已有的项目上做优化，所以尽量在不改变原有结构的基础上进行修改 input、checkbox这些大都是表单里面的元素，所以大部分跟后台有交互，保留原有属性，只增加新的class或者id 只使用css3，并且其属性也都是input，当然也可以直接使用img代替，或者用div+span模拟，但是这就不叫做“优化”，而是模仿了。 使用sass，只需要改变参数就可以反复多次使用 思路大致的原理都是使用html原生的标签元素标签checkbox或者input，在后面加上label标签，将一些原有的元素隐藏，然后再用css设置你想要样式，行为方面都是根据原生属性来判断，不需要使用js。所有的html代码都是 1234div.container input type="checkbox" id="checkbox" label for="checkbox" div.bottom-line 都是利用css的原生属性来判断用户的操作,先将原本的checkbox隐藏，然后再设置label的样式，最后设置input[type=checkbox]:checked+label的样式 checkboxcheckbox demo1首先来看一个checkbox，实现这个动画其实很简单，只运用css就可以实现。实现的原理是绑定checkout和label,用label控制是否checked。点击label的时候改变checkbox的属性先将checkbox隐藏，然后label为一个只有border的框框，使用after和befor伪元素来实现对号的两部分。先将after和before设置宽度为width0.4，height为0，设置不同的旋转角度，让befor和after合起来刚好是一个对号。然后用css动画设置使其height达到width0.7和width*0.35并控制动画使其连贯播放， html1234&lt;div class="cb-container"&gt; &lt;input type="checkbox" id="checkbox"&gt; &lt;label for="checkbox" class="cb-label"&gt;&lt;/label&gt;&lt;/div&gt; scss123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130$checked-color: #fff;$checked-bg:rgb(101,141,181);$unchecked-color: #cfcece;$unchecked-bg:rgb(249,249,249);$checkbox-height: 100px;$background-color:#fff;$font-color:#dcdcdc;$duration: .4s;.cb-container&#123; width: 1000px; text-align: center; margin-top: 50px;&#125;html, body&#123; padding:0; margin:0; background-color: $background-color; color:$font-color; font-family:'Open Sans';&#125;#checkbox&#123; display:none;&#125;.cb-label&#123; height: $checkbox-height; width: $checkbox-height; background: $unchecked-bg; border: $checkbox-height * .1 solid $unchecked-color; position: relative; display: inline-block; box-sizing: border-box; transition: border-color ease $duration/2; -moz-transition: border-color ease $duration/2; -o-transition: border-color ease $duration/2; -webkit-transition: border-color ease $duration/2; cursor: pointer; &amp;::before,&amp;::after&#123; -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; position: absolute; height: 0; width: $checkbox-height * 0.2; background: $checked-color; display: inline-block; -moz-transform-origin: left top; -ms-transform-origin: left top; -o-transform-origin: left top; -webkit-transform-origin: left top; transform-origin: left top; content: ''; -webkit-transition: opacity ease 0.5s; -moz-transition: opacity ease 0.5s; transition: opacity ease 0.5s; &#125; &amp;::before&#123; top:$checkbox-height * 0.76; left: $checkbox-height * 0.31; -moz-transform: rotate(-135deg); -ms-transform: rotate(-135deg); -o-transform: rotate(-135deg); -webkit-transform: rotate(-135deg); transform: rotate(-135deg); &#125; &amp;::after &#123; top: $checkbox-height * .45; left: $checkbox-height * 0; -moz-transform: rotate(-45deg); -ms-transform: rotate(-45deg); -o-transform: rotate(-45deg); -webkit-transform: rotate(-45deg); transform: rotate(-45deg); &#125;&#125;input[type=checkbox]:checked + .cb-label,.cb-label.checked&#123; background: $checked-bg; border-color:$checked-bg; &amp;::after&#123; border-color:$checked-color; height: $checkbox-height * .35; -moz-animation: dothabottomcheck $duration/2 ease 0s forwards; -o-animation: dothabottomcheck $duration/2 ease 0s forwards; -webkit-animation: dothabottomcheck $duration/2 ease 0s forwards; animation: dothabottomcheck $duration/2 ease 0s forwards; &#125; &amp;::before&#123; border-color:$checked-color; height: $checkbox-height * 1; -moz-animation: dothatopcheck $duration ease 0s forwards; -o-animation: dothatopcheck $duration ease 0s forwards; -webkit-animation: dothatopcheck $duration ease 0s forwards; animation: dothatopcheck $duration ease 0s forwards; &#125;&#125;@-moz-keyframes dothabottomcheck&#123; 0% &#123; height: 0; &#125; 100% &#123; height: $checkbox-height *0.35; &#125;&#125;@-webkit-keyframes dothabottomcheck&#123; 0% &#123; height: 0; &#125; 100% &#123; height: $checkbox-height *0.35; &#125;&#125;@keyframes dothabottomcheck&#123; 0% &#123; height: 0; &#125; 100% &#123; height: $checkbox-height *0.35; &#125;&#125;@keyframes dothatopcheck&#123; 0% &#123; height: 0; &#125; 50% &#123; height: 0; &#125; 100% &#123; height: $checkbox-height * 0.7; &#125;&#125;@-webkit-keyframes dothatopcheck&#123; 0% &#123; height: 0; &#125; 50% &#123; height: 0; &#125; 100% &#123; height: $checkbox-height * 0.7; &#125;&#125;@-moz-keyframes dothatopcheck&#123; 0% &#123; height: 0; &#125; 50% &#123; height: 0; &#125; 100% &#123; height: $checkbox-height * 0.7; &#125;&#125; 经过改变后的checkbox checkboxdemo2 checkboxdemo2 checkboxdemo3 checkboxdemo3 checkboxdemo4 checkboxdemo4 inputinput的优化源于在掘金上看到的一篇文章，效果着实小清新，于是就使用拿来主义，写了一个简易版的demo，效果如下，运用的是flex布局还有伪元素placeholder来实现的。 input效果 输入框清除默认样式 当输入框获得焦点时，输入框原本的文字向上移，并且下方蓝色的线宽度由0变为100 如果没有输入内容，还变为未输入的状态 ​ 先贴上代码 html代码html结构很简单，使用的是HTML原生的form元素input和label；在效果中的“请输入内容”这几个字不是使用的 1placeholder ，而是使用的label，但是也设置有 1placeholder ,只不过是把 1placeholder 的透明度设置为0，因为我们需要根据 1placeholder 是否显示来设置下方line的宽度和label的位置。 1234div.input-container input type="input" id="input" placeholder="请输入内容" label for="input" div.bottom-line 完整html代码如下 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel="stylesheet" href="scss/main.css"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="input-container"&gt; &lt;input type="input" id="input" placeholder="请输入内容"&gt; &lt;label for="input"&gt;请输入内容&lt;/label&gt; &lt;div class="bottom-line"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; css代码全部的动画效果都只使用了css，但是使用的一些新特性浏览器兼容性还没有那么好，兼容到ie10.布局使用的是flex，动画效果用的是用的transform。运用伪类placeholder判断是否输入了文字，如果输入了文字下方的line宽度变为100%；label中的文字上移并且变小代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586$width: 500px;$label-font-color: #3f4f5b;$label-focus-font-color: rgb(82, 97, 108);$border-bottom-color: #d5d5d5;$focus-border-color: rgb(101, 141, 181);$transform-top: 10px;$transform-time: 0.3s;$scale: 0.9;.input-container &#123; width: $width; position: relative; display: -webkit-box; display: -ms-flexbox; display: flex; -webkit-box-orient: vertical; -webkit-box-direction: reverse; -ms-flex-flow: column-reverse; flex-flow: column-reverse; -webkit-box-align: start; -ms-flex-align: start; align-items: flex-start; margin: 100px auto&#125;.input-container input &#123; -webkit-box-ordinal-group: 11; order: 10; -ms-flex-order: 10; outline: none; border: none; width: 100%; padding: 10px 0; font-size: 20px; border-bottom: 1px solid $border-bottom-color; text-indent: 10px;&#125;.input-container input::-moz-placeholder &#123; opacity: 0;&#125;.input-container input::-webkit-input-placeholder &#123; opacity: 0;&#125;.input-container input:-ms-input-placeholder &#123; opacity: 0;&#125;.input-container input, .input-container label &#123; transition: all $transform-time;&#125;.input-container label &#123; -webkit-box-ordinal-group: 101; -ms-flex-order: 100; order: 100; color: $label-font-color; -webkit-transform-origin: left bottom; transform-origin: left bottom; -webkit-transform: translate(10px, 40px); transform: translate(0px, 40px);&#125;.input-container .bottom-line &#123; order: 2; width: 0; height: 2px; background: $focus-border-color; transition: all $transform-time;&#125;.input-container input:focus &#123; border-bottom-color: #fff;&#125;.input-container input:focus ~ div, .input-container input:not(:placeholder-shown) ~ div &#123; width: 100%&#125;.input-container input:focus + label, .input-container input:not(:placeholder-shown) + label &#123; color: $label-focus-font-color; -webkit-transform: translate(10px) scale($scale); transform: translate(10px) scale($scale)&#125; 转自 ： https://juejin.im/post/591873170ce4630069f3013d]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】Visual Studio Code 常用快捷键]]></title>
    <url>%2Fblog%2F2017-06-15.VisualStudioCode%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[主命令框F1 或 Ctrl+Shift+P: 打开命令面板。在打开的输入框内，可以输入任何命令，例如： 按一下 Backspace 会进入到 Ctrl+P 模式 在 Ctrl+P 下输入 &gt; 可以进入 Ctrl+Shift+P 模式 在Ctrl+P窗口下还可以: 文件名 跳转到对应文件 ? 列出当前可执行的动作 ! 显示 Errors或 Warnings，也可以 Ctrl+Shift+M : 跳转到行数，也可以 Ctrl+G 直接进入 @ 跳转到 symbol（搜索变量或者函数），也可以 Ctrl+Shift+O 直接进入 @ 根据分类跳转 symbol，查找属性或函数，也可以 Ctrl+Shift+O 后输入:进入 # 根据名字查找 symbol，也可以 Ctrl+T 常用快捷键编辑器与终端窗口管理同时打开多个终端窗口（查看多个项目） Ctrl+Shift+N 打开一个新窗口 Ctrl+Shift+W 关闭窗口 同时打开多个编辑器（查看多个文件） Ctrl+N 新建文件 Ctrl+Tab 文件之间切换 Ctrl+\ 切出一个新的编辑器（最多 3 个） ，也可以按住 Ctrl + 鼠标点击 Explorer 里的文件名 Ctrl+1、Ctrl+2、Ctrl+3左中右 3 个编辑器的快捷键 `Ctrl+ `` 3 个编辑器之间循环切换 Ctrl+k然后按 ←/→ 编辑器换位置 代码编辑格式调整 Ctrl+[ 、 Ctrl+] 代码行缩进 Ctrl+C/X 复制/剪切 当前行/当前选中内容 Shift+Alt+F 代码格式化,或 Ctrl+Shift+P 后输入format code Alt+↑/↓ 上/下移动一行 Shift+Alt+↑/↓ 向上/向下复制一行 Ctrl+Enter 在当前行下边插入一行 Ctrl+Shift+Enter 在当前行上方插入一行 光标相关 Home 移动到行首 End 移动到行尾 Ctrl+End 移动到文件结尾 Ctrl+Home 移动到文件开头 F12 移动到定义处 Alt+F12 定义处缩略图（只看一眼而不跳转过去） Ctrl+Shift+] 移动到后半个括号 Shift+End 选择从光标到行尾 Shift+Home 选择从行首到光标处 Ctrl+Delete 删除光标右侧的所有字 Shift+Alt+←/→ 扩展/缩小选取范围 Ctrl+Alt+↑/↓，Alt+Shift+鼠标左键 多行编辑(列编辑) Ctrl+Shift+L 同时选中所有匹配 Ctrl+D 下一个匹配的也被选中 Ctrl+U 回退上一个光标操作 重构代码 Shift+F12 找到所有的引用 Ctrl+F12 同时修改本文件中所有匹配的 F2 重命名比如要修改一个方法名，可以选中后按 ，输入新的名字，回车，会发现所有的文件都修改了 F8 跳转到下一个 Error 或 Warning，当有多个错误时可以按 逐个跳转 查看 diff; 在 explorer 里选择文件右键-&gt; Set file to compare-&gt;需要对比的文件上右键选择-&gt;Compare with file_name_you_chose 查找替换 Ctrl+F 查找 Ctrl+H 查找替换 Ctrl+Shift+F 整个文件夹中查找 显示相关 F11全屏 Ctrl +/- zoomIn/zoomOut Ctrl+B 侧边栏显/隐 Ctrl+Shift+E 显示资源管理器 Ctrl+Shift+F 显示搜索 Ctrl+Shift+G 显示 Git Ctrl+Shift+D 显示 Debug Ctrl+Shift+U 显示 Output 其他自动保存File -&gt; AutoSave ，或 Ctrl+Shift+P，输入 auto 修改默认快捷键 打开默认键盘快捷方式设置：File-&gt;Preferences-&gt;Keyboard Shortcuts，或Alt+F-&gt;p-&gt;k 修改 keybindings.json：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// Place your key bindings in this file to overwrite the defaults[ // ctrl+l 快速切换编辑器语言 &#123; "key": "ctrl+l", "command": "workbench.action.editor.changeEncoding", "when": "editorFocus" &#125;, // ctrl+] 在explorer.exe中打开当前编辑文件 &#123; "key": "ctrl+]", "command": "workbench.action.files.revealActiveFileInWindows", "when": "editorFocus" &#125;, // ctrl+shift+] 定位到VSCode资源管理器位置 &#123; "key": "ctrl+shift+]", "command": "workbench.files.action.showActiveFileInExplorer", "when": "editorFocus" &#125;, // ctrl+space 被切换输入法快捷键占用 &#123; "key": "alt+space", "command": "editor.action.triggerSuggest", "when": "editorTextFocus" &#125;, // ctrl+d 删除一行 &#123; "key": "ctrl+d", "command": "editor.action.deleteLines", "when": "editorTextFocus" &#125;, // 与删除一行的快捷键互换 &#123; "key": "ctrl+shift+k", "command": "editor.action.addSelectionToNextFindMatch", "when": "editorFocus" &#125;, // ctrl+shift+/多行注释 &#123; "key": "ctrl+shift+/", "command": "editor.action.blockComment", "when": "editorTextFocus" &#125;, // 定制与 sublime 相同的大小写转换快捷键，需安装 TextTransform 插件 &#123; "key": "ctrl+k ctrl+u", "command": "uppercase", "when": "editorTextFocus" &#125;, &#123; "key": "ctrl+k ctrl+l", "command": "lowercase", "when": "editorTextFocus" &#125;] 前端开发必备插件 PostCSS Sorting stylelint stylefmt ESLint javascript standard format beautify Babel ES6/ES7 Debugger for Chrome Add jsdoc comments javascript(ES6) code snippets vue weex Reactjs code snippets React Native Tools Npm Intellisense Instant Markdown Markdown Shortcuts TextTransform 自定义设置参考VS Code 自定义配置参考： 123456789101112131415161718192021&#123; "editor.fontSize": 18, "files.associations": &#123; "*.es": "javascript", "*.es6": "javascript" &#125;, // 控制编辑器是否应呈现空白字符 "editor.renderWhitespace": true, // 启用后，将在保存文件时剪裁尾随空格。 "files.trimTrailingWhitespace": true, // File extensions that can be beautified as javascript or JSON. "beautify.JSfiles": [ "", "es", "es6", "js", "json", "jsbeautifyrc", "jshintrc" ]&#125; 相关参考 官方快捷键大全 转自 ： 猪猪娱乐(Hexo next 应用了 bootstrap ， 挺好看的) –&gt; https://zhuzhuyule.xyz/2017/03/21/Visual-Studio-Code-常用快捷键/]]></content>
      <categories>
        <category>善用佳软</category>
        <category>Visual Studio Code</category>
      </categories>
      <tags>
        <tag>VSCode</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】节制你的激情]]></title>
    <url>%2Fblog%2F2017-06-15.%E8%8A%82%E5%88%B6%E4%BD%A0%E7%9A%84%E6%BF%80%E6%83%85%2F</url>
    <content type="text"><![CDATA[工作了四年以后，我升职为高级软件工程师。这里的升职不是管理上的提升，其实我现在只需要管好我自己，而是对一个软件工程师成熟度的认可。一个高级工程师，较之一个刚毕业的新手而言，他应该能够独立的推进一个项目，从技术，到和其他组的交流协作，都能够独当一面。我最近遇到的一个难题，就是如何和产品经理有效的协作来保证项目的进度。后来学习到一个秘诀，就是要别人的承诺。 具体的故事，是这样发生的。我和项目经理，一起制定使用者剧本(user story)，会议结束的时候，我们分了工。我的项目经理，要先在这些剧本里，加入验收测试，然后，我再预估它们的复杂度。换句话说，我的任务依赖着他的，他做不完，我就起不了步。 当天下午，大家很高心的散会了。第二天，我问他测试写明白了吗。他说他明天给我，我说好吧。可第三天，依旧没写好。我问他，他又说再等一天。三天过去了，剧本没写好，没测试，我没开工。 后来我的上司看到了，略有不爽，他说，怎么都第四天了，还没有开工。我当时想辩解，说不是我的错，因为我得等别人的活完了才能开始自己的，我是被别人耽误了。后来想辩解也没有意义，特别是这种推卸责任的辩解更没有意义。我的产品经理，当时也意识到自己确实没做好，在第四天，他写了测试。 后来，我找到了老板，高级高级工程师，问他我在这种情况下，应该怎么办？他给我讲了一下他作为新手时犯的错误，也给我说了一个解决办法。 在他是新手的时候，如果他依赖的人太慢，我老板就自己替他人把活做了。这样进度会有，但不是长久之计。首先，替他人把活做了，僭越了不说，到时候万一你做的并不是人家的本意，之后还得重头再来，特别是这种产品经理写验收测试的活，程序员一定要让他们从产品，从用户的角度来写测试，不能以程序员对产品的理解去写。其次，即便替人做的好，可自己的精力毕竟有限，不能作为长久的打算。 所以不可取，那么什么可取呢？回到我的经历中来，第一天，大家高兴散会的时候，不能就那么散了，而要问清楚，你什么时候能给我一个满意的答复，我们需要对方的一个承诺。承诺的远近并不是问题。远了，说明他有优先级更高的事情要做，要么，我不能干等，要么，我们把问题上传给决策者来重新讨论优先级。近了，更好。承诺的重要性在于明确各方的责任点和责任段，是为了更有效的交流，不至于把时间用在等待里。 转自 ： http://hui-wang.info/2015/11/04/节制你的激情/]]></content>
      <categories>
        <category>职业规划</category>
      </categories>
      <tags>
        <tag>软技能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】Npm读取config配置的优先级]]></title>
    <url>%2Fblog%2F2017-06-15.npm%E8%AF%BB%E5%8F%96config%E9%85%8D%E7%BD%AE%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[npm可以从多处读取npm的配置信息。不同地方的npm配置存在着优先级顺序。 下面从优先级高到低的顺序来介绍一下各配置。 命令行1&gt; npm run commend --proxy http://server:port 命令行中将proxy的值设为http://server:port。 环境变量以npm_config_为前缀的环境变量会被识别为npm的配置属性。如设置proxy。 1npm_config_proxy=http://server:port 项目.npmrc文件存在于项目根目录下的.npmrc配置文件/path/to/project/.npmrc。 用户.npmrc文件存在于用户根目录下的.npmrc文件。如windows下是%USERPROFILE%/.npmrc，MAC下是$HOME/.npmrc。 全局.npmrc文件存在于Node全局的.npmrc文件。如windows下$PREFIX/etc/.npmrc，MAC下是%APPDATA%/etc/.npmrc。 npm内置的.npmrc文件存在于npm包的内置.npmrc文件/path/to/npm/.npmrc。 npm的默认配置npm本身有默认配置。对于以上情况下都没有设置的配置，npm会使用默认配置。 转自 ：https://yanyinhong.github.io/2017/05/01/The-priority-of-npm-config/]]></content>
      <categories>
        <category>前端</category>
        <category>Node</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】并发与并行的区别]]></title>
    <url>%2Fblog%2F2017-06-15.%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[并发（concurrency）和并行（parallelism）是两个完全不同的概念。 并发，从它的英语本意来看是竞争的意思。这是理解它的关键。没有竞争，并发就无从谈起。为什么会有竞争，那是因为资源是有限的。资源是一方面是有限的，一方面还要满足不同主体的需求，这就会遇到资源的共享。这样以来，就要指定一些规则，让大家有效，并且安全的利用这些资源。这里的并字，强调的是一种秩序。 并行，和竞争没有半毛钱的关系。并行指的是一个任务的属性，看它能不能被化分成相互独立，可以同时完成的小任务。比如说，有一个任务，是要数一本书一共有多少字，那么这个任务就可以被分成很多份，让小明数十页，小微数另外十页。此处的并字，侧重点是指任务能不能可分，能不能同时进行，来达到加速的目的。 两者，不是一个概念，不对立存在。不同的用法是为了达到不同的目的。一个很好的例子，就是JVM中不同的垃圾回收算法，有的是并发的，有的是并行的。 转自 ： http://hui-wang.info/2014/09/02/并发与并行的区别/]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>并行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】Hexo博客搭建之引用站内文章]]></title>
    <url>%2Fblog%2F2017-06-15.Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8B%E5%BC%95%E7%94%A8%E7%AB%99%E5%86%85%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[在写文章的过程中，有时候需要引用站内的其他文章。可以通过内置的标签插件的语法post_link来实现引用。 1&#123;% post_link 文章文件名（不要后缀） 文章标题（可选） %&#125; 举例 引用 Hello.md 1&#123;% post_link Hello %&#125; 或者 1&#123;% post_link Hello 你好 %&#125; 转自 ： https://yanyinhong.github.io/2017/05/03/Refer-article-in-hexo-post/]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】当程序员老了]]></title>
    <url>%2Fblog%2F2017-06-15.%E5%BD%93%E7%A8%8B%E5%BA%8F%E5%91%98%E8%80%81%E4%BA%86%2F</url>
    <content type="text"><![CDATA[之前类似这种题目的文章很少去读，可最近这种想法经常闯进我的思考范围。可能是人马上要三十，到了要想这个问题的年龄了。和其他关于衰老的话题一样，谈起来难免有些淡淡的忧伤。可认真的琢磨之后，发现未雨绸缪是件好事，能看到忧伤背后的从容和坦然。 程序员也是人，所以有人的共性。十几二十的时候，很少会想到老。一是忙着学习考试，没时间。即便有点时间，搞搞对象，打打游戏，也不会轮到它。说白了，还是因为年轻，可塑性强，没什么好怕的。到了快三十的时候，就不一样了。工作之余，时间有了。人闲了，就容易琢磨事儿，还老爱自己吓自己。其次，三十岁的人，慢慢意识到老为何物，爷爷奶奶听不清看不明了甚至走了，爸爸妈妈白发多了。最后，想再折腾的时候，发现已经到了生育培养下一代的年龄，担的责任越来越重，不敢再冒险了。在这种情形下，如果还找到良方来从容应对年月带来的冲击，就会有危机感，害怕老无所用。 经验和精力一个人随着年龄的增长，经验会更丰富，同时，精力也会减少。所以上了年纪后，要学会利用积累的经验去创造价值，而不是单纯的用精力去和年轻人拼。 明白了这一点，就应该注重经验的积累。如何积累呢？首先，得从自身找出路。做同样的一件事，有的人爱观察，爱思考，可以了解事物的本质和内在联系。也有的人，只注重事物的表面，不加深究，只获取看得见，摸得着的果实。日积月累，前者的经验当然会越来越多。其次，要借助外力。有的环境利于经验的摄取，而有的环境只会单纯的让人变老。一个充满挑战需要开拓创新的环境，和一个整日复制粘贴的环境，它们所蕴含的经验有天壤之别。 所以，作为程序员的我们，要勤于观察，善于思考，特别是在这个各种框架、语言、技术日新月异的年代。拿大数据这个炙手可热的新名词来讲，从之前的Hadoop和到之后的Spark框架，技术革新速度是令人无法想象的。然而，爱思考的程序员们会发现，有些东西，的确变了，而有的东西是没有变的。比如说基于图的数据结构和算法，分布式系统的扩展性和可靠性问题，以及系统性能的测试和优化方法，这些基础通用的懂事是没有变的。Spark的核心思想RDD是一个创新，不求甚解的人只会学习如何使用它，爱思考的人会摸清它的来龙去脉，知晓它的优势和局限。这样一来，牢固的基础和丰富的经验可以帮助很快的掌握新的技术。 谈完思考的重要性，再看看环境，上面说到的开拓创新的环境，是很好，可没有怎么办？答案是看你想不想要。环境是可以争取的，甚至可以自己创造的。 我在现在的公司，在同一个职位干了快有五年了。干了三年后，工作开始漫漫变得重复乏味起来。大部分的时间是我帮别人解决问题，而不是我去请教别人，输出大于输入。为了能创造一个更加开拓创新的环境，我曾经“威胁”老板说，如果再找不到具有挑战性的项目，我就要走人了。后来，在我的推动下，终于找到了让我满意的项目和环境，争取到了和公司架构师们一起做项目，向他们学习的机会。除此之外，我还去参加编程比赛，程序员见面会，主动做演讲。这些都是为了创造互相交流学习的环境。 说了这么多关于经验积累方面的见解，我想简单的谈一下精力。精力会随着人的衰老而减少，这是无法阻挡的自然进程。我们能做的，就是放慢它的脚步。唯一方案，就是运动。相信大家都明白生命在于运动的道理，我就不多说了。 潜心治学上面说那么多关于经验的事，只是想从职业竞争的方面说明，老并不可怕，只要方法得当，经验可以转化为不可或缺的优势。加上运动的好了，可以老将出马，一个顶俩。 接下来，说说潜心治学的态度。很多人程序员做了两三年，就想着转行，转产品，转客户，转管理，就好像那些行业不需要养老一样。如果是对编程失去了热情，那么如此做便是无可厚非。但如果仍热情饱满，却因为担心程序员的未来，而转行，那么就没有必要了。 首先，从专家程序员的市场价值来说，他们能够解决别人解决不了的问题，他们能够看到别人看不到的深度。再某些难题面前，一个专家，不能被十个初学者换掉。因为这不是一个搬砖的过程，而是一个修行达没达到深度的问题。除此之外，潜心治学，可以满足人们对知识上的追求，有的快乐并不是金钱所能买得到的，刻苦钻研，攻克难关本身就是一个可以给人以巨大成就感的事情。 潜心治学，成为大家，并非易事，也正因为如此，它是一条可以让人实现巨大自我价值的道路。这样的人，从小的来讲，可以是某些项目的带头人，可以是专利的获得者，可以是书的作者，可以是一个讲师。往大的讲可以是图灵奖的获得者，可以是改变整个世界的人。 结语哗哗啦啦用了好几天的时间讲了这么多，一是想告诉自己，要沉下心来，做自己喜欢做的事，并且享受这个过程。其次，是要记录下，处在三十岁的这个关口，我对程序员人生的看法。也分享给其他的程序员朋友，共勉。 转自 ： http://hui-wang.info/2016/02/25/当程序员老了/]]></content>
      <categories>
        <category>职业规划</category>
      </categories>
      <tags>
        <tag>职业规划</tag>
        <tag>程序员</tag>
        <tag>心态</tag>
        <tag>老了</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】自由和免费电子书]]></title>
    <url>%2Fblog%2F2017-06-15.%E8%87%AA%E7%94%B1%E5%92%8C%E5%85%8D%E8%B4%B9%E7%94%B5%E5%AD%90%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[将要给大家分享的电子读物不仅仅是免费的，而且是自由的。某些网站虽然提供免费电子书，却侵犯了著作的产权。 英语中，Free既可以当作免费也可理解为自由。法语在这一点上显得便更加缜密，免费是Gratuit， 自由是Libre。 当一本书变得自由的时候，往往是书的作者已经离我们远去的时候。这样以来，它们往往是经过漫漫历史长河沉淀下来的经典。以下是英语和法语两种语言里我找到的最知名的电子书分享网站，并且电子书的格式支持大部分的手持移动设备。 Project Gutenberg 古腾堡工程（Project Gutenberg，缩写：PG），由志愿者参与，致力于将文化作品的数字化和归档，并鼓励创作和发行电子书。该工程肇始于1971年，是最早的数字图书馆。其中的大部分书籍都是公有领域书籍的原本，古腾堡工程确保这些原本自由流通、格式开放，有利于长期保存，并可在各种计算机上阅读。 －－维基 Ebooks libres et gratuits 法语世界里的古腾堡工程。请留意该网站右下角的友情链接部分，您会有意外的发现。 转自 ： http://hui-wang.info/2009/12/28/自由和免费电子书/]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>免费电子书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】你需要的是一个承诺]]></title>
    <url>%2Fblog%2F2017-06-15.%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%98%AF%E4%B8%80%E4%B8%AA%E6%89%BF%E8%AF%BA%2F</url>
    <content type="text"><![CDATA[工作了四年以后，我升职为高级软件工程师。这里的升职不是管理上的提升，其实我现在只需要管好我自己，而是对一个软件工程师成熟度的认可。一个高级工程师，较之一个刚毕业的新手而言，他应该能够独立的推进一个项目，从技术，到和其他组的交流协作，都能够独当一面。我最近遇到的一个难题，就是如何和产品经理有效的协作来保证项目的进度。后来学习到一个秘诀，就是要别人的承诺。 具体的故事，是这样发生的。我和项目经理，一起制定使用者剧本(user story)，会议结束的时候，我们分了工。我的项目经理，要先在这些剧本里，加入验收测试，然后，我再预估它们的复杂度。换句话说，我的任务依赖着他的，他做不完，我就起不了步。 当天下午，大家很高心的散会了。第二天，我问他测试写明白了吗。他说他明天给我，我说好吧。可第三天，依旧没写好。我问他，他又说再等一天。三天过去了，剧本没写好，没测试，我没开工。 后来我的上司看到了，略有不爽，他说，怎么都第四天了，还没有开工。我当时想辩解，说不是我的错，因为我得等别人的活完了才能开始自己的，我是被别人耽误了。后来想辩解也没有意义，特别是这种推卸责任的辩解更没有意义。我的产品经理，当时也意识到自己确实没做好，在第四天，他写了测试。 后来，我找到了老板，高级高级工程师，问他我在这种情况下，应该怎么办？他给我讲了一下他作为新手时犯的错误，也给我说了一个解决办法。 在他是新手的时候，如果他依赖的人太慢，我老板就自己替他人把活做了。这样进度会有，但不是长久之计。首先，替他人把活做了，僭越了不说，到时候万一你做的并不是人家的本意，之后还得重头再来，特别是这种产品经理写验收测试的活，程序员一定要让他们从产品，从用户的角度来写测试，不能以程序员对产品的理解去写。其次，即便替人做的好，可自己的精力毕竟有限，不能作为长久的打算。 所以不可取，那么什么可取呢？回到我的经历中来，第一天，大家高兴散会的时候，不能就那么散了，而要问清楚，你什么时候能给我一个满意的答复，我们需要对方的一个承诺。承诺的远近并不是问题。远了，说明他有优先级更高的事情要做，要么，我不能干等，要么，我们把问题上传给决策者来重新讨论优先级。近了，更好。承诺的重要性在于明确各方的责任点和责任段，是为了更有效的交流，不至于把时间用在等待里。 转自 ： http://hui-wang.info/2016/01/27/你需要的是一个承诺/]]></content>
      <categories>
        <category>职业规划</category>
      </categories>
      <tags>
        <tag>软技能</tag>
        <tag>交流技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用CSS选择器速查表]]></title>
    <url>%2Fblog%2F2017-06-15.css-selector-cheat-sheet%2F</url>
    <content type="text"><![CDATA[常用CSS选择器速查表查看完整选择器列表，详见Selectors Level 3PS: *选择器要慎用，因为它是性能最低的一个CSS选择器。 模式 解释 初次定义的CSS版本 * 任意元素 2 E 类型为E的元素 1 E[foo] 类型为E，且具有属性foo的元素 2 E[foo=”bar”] 类型为E，且属性foo值为bar的元素 2 E[foo~=”bar”] 类型为E，且属性foo的值以空格分隔为值列表，列表中具有bar值的元素E 2 E[foo^=”bar”] 类型为E，且属性foo值以bar开头的元素 3 E[foo$=”bar”] 类型为E，且属性foo值以bar结尾的元素 3 E[foo*=”bar”] 类型为E，且属性foo值包含子字符串bar的元素 3 E[foo&#124;=”en”] 类型为E，且属性foo值以连字符“-”分隔成列表后，列表以en开头的元素 (&amp;#124;是 （竖）html 转义， 部分 md 转换有问题)[^1] 2 E:root 类型为E，且是文档的根元素 3 E:nth-child(n) 类型为E，且它是父元素的第n个子元素 3 E:nth-last-child(n) 类型为E，且它是父元素的倒数第n个元素 3 E:nth-of-type(n) 类型为E，且它是所有E兄弟元素的第n个 3 E:nth-last-of-type(n) 类型为E，且它是所有E兄弟元素的倒数第n个 3 E:first-child 类型为E，且它是父元素的第1个子元素 2 E:last-child 类型为E，且它是父元素的倒数第1个子元素 3 E:first-of-type 类型为E，且它是所有E兄弟元素中的第1个 3 E:last-of-type 类型为E，且它是所有E兄弟元素中的倒数第1个 3 E:only-child 类型为E，且它是父元素的唯一子元素 3 E:only-of-type 类型为E，且它是兄弟元素中的唯一一个类型为E的元素 3 E:empty 类型为E，且它没有子元素（包括文本元素） 3 E:link 作为超链接的元素E 1 E:visited 被执行了用户动作visited的元素E 1 E:active 被执行了用户动作active的元素E 1 and 2 E:hover 被执行了用户动作hover的元素E 1 and 2 E:focus 被执行了用户动作focus的元素E 1 and 2 E:target 相关URI目标的元素E 3 E:lang(fr) 使用语言fr的元素E 2 E:enabled 被enable的交互元素E 3 E:disabled 被disabled的交互元素E 3 E:checked 被checked过的交互元素E 3 E::first-line 元素E的首行字符 1 E:first-letter 元素E的首个字符 1 E::before 元素E的before伪元素 2 E::after 元素E的after伪元素 2 E.warning 类为warning的E元素 1 E#myid id为myid的E元素 1 E:not(s) 不满足选择器条件s的E元素 2 E F 元素E的所有后代F元素 1 E &gt; F 元素E的所有子F元素 2 E + F 元素E的紧邻F兄弟元素 2 E ~ F 元素E的兄弟F元素 3 markdwon 的表格中需要竖线“|”这样的特殊符号，咋办？1234567那就只能用html字符实体了： &amp;verbar; &amp;vert; &amp;VerticalLine; &amp;#x0007C; &amp;#124; 这五个，任选一个吧~ [^1]: markdwon 的表格中需要竖线“|”这样的特殊符号，详见： markdwon 的表格中需要竖线“|”这样的特殊符号，咋办？@v2ex http://www.asciitable.com/ 转自 ： https://yanyinhong.github.io/2017/04/30/CSS-selector-cheat-sheet/]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>CSS选择器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】程序员必备的六本书]]></title>
    <url>%2Fblog%2F2017-06-11.programmer-6-bibei-books%2F</url>
    <content type="text"><![CDATA[我喜欢读书，并且偏爱读传统的纸质书籍（看着电脑忙乎了一天，不喜欢继续盯着电脑或者手机读书了），因此我经常买一些书来读。到目前为止，我已经买下了各类书籍50本左右了，花了有4000多RMB。有些书是一时心血来潮，买来之后就没怎么看，但有些好书，看过之后，或许只是有那么一点有触动，但带来的价值是很高的，它让我明白前进的方向并教导我怎么走向目标。话说钱不是省出来的，得赚，更得学会花钱。我觉得，在书籍阅读上花钱，是很值得的。在此分享一些我认为好的书籍给朋友们，希望对你们有所帮助。 改变思想的大作《浪潮之巅》我唯一一本完整读完的书籍，^_^，吴军博士介绍了IT行业的发展历史，并讲解了很多典型的巨头公司，最后还对未来做了展望。这本书的内容不限于IT行业，对IT背后的银行、风投等做了深刻的描述，还介绍了其他的高科技产业，比如医药。现在时代的企业竞争，已经不是同行业的竞争了，跨界竞争不时的发生，这本书对于开阔眼界很有帮助。 《大数据时代：生活、工作与思维的大变革》这本书同样是开阔眼界、转变思想的书（思想的变更很重要，技术的更新随后）。不过略微显得啰嗦了些。现在云计算和大数据炒的很热，看这本书可以了解到很多深层次的东西。 程序员晋级之路《IT项目经理成长手记》程序员需要晋级，如果要向项目经理方向发展，此书很实用。这本书介绍了项目管理的很多理论以及实战的工具（之前我喜欢用各种软件工具，现在越来越发现，真正的工具不一定是软件，更多的是一种资料的整理方式，例如某种格式的表格等），此外还介绍了项目管理的软知识，这点很实用。 如果对项目经理没兴趣，但做项目的同学，还是应该了解项目管理的知识的，只有管理的和被管理的都了解管理是怎么回事的情况下，管理工作才能更好的进行，此时项目团队就向着管理项目进发，而不是陷于团队的内部管理上（甚至可以认为是内耗）。 《从技术走向管理 李元芳履职记》这本书是技术人员（程序员、架构师等等）转向部门经理的参考工具。当然，并非你要有当经理的意愿或者有晋级经理的机会才需要学习，作为被管理者，能够让管理者省心省力也是很重要的。在项目团队中，并非只有项目经理是管理者，同样在公司部门中，并非只有部门经理是管理者，每个员工都有培训、指导同事的机会，都有需要向同事需求帮助的机会，老人带新人也是一种管理。这本书介绍的更多的是管理的软技能，对于所有职场人员来说，学习沟通等是必须的。 这本书同样是以小说体的形式讲述的，很容易学习。但此类知识，重在实践，要多多实践，多多体会。 个人管理《高效能人士的七个习惯》小时候成绩好，长辈们会夸赞聪明，高中、大学时候如果成绩好，别人会评价你很努力。事实上，高中大学里，如果你努力学习了，成绩自然会好的，但是工作了之后，不是光靠努力就可以的。在工作中，我们的自主选择的余地更大了，所以走对路子很重要，找到捷径很重要，提高效率很重要，不能光靠吃苦努力了。 当然，踏踏实实的做技术，加班加点的攻坚很重要，但更多的时候，我们可以停下来，想一想怎么做更有效。 其他《编程之美》这本书我只能说是买后发现我没兴趣读，并不能说这书不好。 这本书更多的是算法逻辑方面的，可能对技术面试或者纯技术朋友们有帮助。如果你是一心一意做技术，而且是做类似于SqlServer、Office这类软件的开发，那你可以学习如何写出高效的代码。但是一般的码农朋友们，大家的产品或者项目，技术经常不是最重要的。 作者：马洪彪出处：cnblogs.com/mahongbiao/]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>book</tag>
        <tag>程序员</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jxy.me分享的 《二手前端心得》等]]></title>
    <url>%2Fblog%2F2017-06-11.shared-by-jxy-me%2F</url>
    <content type="text"><![CDATA[说回正事，一直想写些长篇大论，如果在blog上写，写一篇文章显得太长；如果分成多篇，又要在标题上加上“1/2/3”之类的序号，很low，想看时也不方便。正好最近发现了GitBook，觉得这种写作方式很好，干脆在gitbook上写吧，类似写一本书的形式，相同主题的文章都聚合在一起，看起来方便。其实gitbook本来是用来多人协作的，被我用来当blog了。。。blog本身就只写一些能单独成篇的文章，和一些思考吧。 本篇文章用来做个汇总，在menubar中新增个入口，开的坑都会列在这里，不定期更新。 另外要吐槽下NexT主题的图标，用的linecons，但居然把不用的图标都删除了。我本来想选个书籍的图标的，但没有合适的，只能选择个铅笔的。如果要自己新增图标，还要去编辑字体文件，实在懒得折腾了。 《Guava豆知识》 进度为0 地址：https://www.gitbook.com/book/jiangxy/guava-tips/details 进度：0% 备注：基于18.0版本 Guava一直是我最喜欢的java类库，没有之一。但工作中却见得较少。所以打算总结下guava的各种用法。其实guava的很多思想已经被吸收进jdk了吧。我不打算翻译官方文档，首先官方文档本身就不够详细，从googlecode迁移到github后，wiki的内容好像丢了很多。。。其次很多人已经翻译过官方文档了。我是打算看遍guava的源码，结合自身的一些使用经验，总结下常见的用法。看源码的过程也是自己学习的过程。其实从源码中能翻出很多好玩的东西，很多工具类官方都没有文档。虽然API可能不稳定就是了。如果这次搞guava顺利的话，打算以后把apache commons系列也这么搞一次。基于18.0版本。 《LeetCode Gossip》 地址：https://www.gitbook.com/book/jiangxy/leetcode-gossip/details 进度：10% 备注：基于java 其实就是leetcode题解，总结下解题的思路，附加各种吐槽。其实主要是吐槽。。。本职不能忘。但我本身是算法弱鸡，所以也不追求算法速度了，能AC就好，未必是最优的解法。之前只刷了50多道题，还有很多水题，借这个机会，强迫自己把leetcode重刷一遍，复习下算法。 分享一些书籍借着开坑的机会，分享我之前看过的一些书吧。书上有我的注释&amp;吐槽，这个是个人习惯。。。也是不定期更新。另外我习惯看最新版的，所以会有很多是英文版的。 坑爹的是，很多注释是我以前用windows时用foxit reader加的，在mac下显示会有些问题。 《HBase权威指南》中文版 《Hadoop权威指南》英文第三版 《Hadoop.Application.Architectures》英文版 以上是比较完整的看过的，注释也比较多，其他的还在整理。另外因为是pirated edition，请低调。。。本来想放在dropbox的，但转念一想会不会被封啊，还是放baidu吧。。。 一些文档顺便分享自己写的一些文档吧，主要是一些内部分享和调研。有些简略，有些详细。 原作者放在 baidu 网盘上的。 整理了一些暂时用到的， 如： 二手前端心得 DNS 原理&amp;安全 Google Analytics Hadoop和Mapreduce YARN代码分析 PowerDrill&amp;Tenzing Tenzing Muppet Twitter uni-log Google Prediction API Google Analytics | @blog DNS原理&amp;安全 | @blog 二手前端心得 | 二手前端心得@blog]]></content>
      <categories>
        <category>别人的分享</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>DNS</tag>
        <tag>DNS原理&amp;安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[39个必知必会的SQL 性能调优方法]]></title>
    <url>%2Fblog%2F2017-06-08.tips-about-SQL-optimize%2F</url>
    <content type="text"><![CDATA[转自 ：https://mp.weixin.qq.com/s/jSYyXiE-kNoE9jpZ4kAEhw http://www.cnblogs.com/llrr/p/6655977.html 我们要做到不但会写SQL,还要做到写出性能优良的SQL,以下为笔者学习、摘录、并汇总部分资料与大家分享！ 1、选择最有效率的表名顺序(只在基于规则的优化器中有效)ORACLE 的解析器按照从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表(基础表 driving table)将被最先处理，在FROM子句中包含多个表的情况下,你必须选择记录条数最少的表作为基础表。如果有3个以上的表连接查询, 那就需要选择交叉表(intersection table)作为基础表, 交叉表是指那个被其他表所引用的表. 2、WHERE子句中的连接顺序ORACLE采用自下而上的顺序解析WHERE子句,根据这个原理,表之间的连接必须写在其他WHERE条件之前, 那些可以过滤掉最大数量记录的条件必须写在WHERE子句的末尾. 3、SELECT子句中避免使用 ‘ * ‘ORACLE在解析的过程中, 会将’*’ 依次转换成所有的列名, 这个工作是通过查询数据字典完成的, 这意味着将耗费更多的时间 4、减少访问数据库的次数ORACLE在内部执行了许多工作: 解析SQL语句, 估算索引的利用率, 绑定变量 , 读数据块等； 5、在SQL*Plus , SQLForms和ProC中重新设置ARRAYSIZE参数, 可以增加每次数据库访问的检索数据量 ,建议值为2006、使用DECODE函数来减少处理时间使用DECODE函数可以避免重复扫描相同记录或重复连接相同的表. 7、整合简单,无关联的数据库访问如果你有几个简单的数据库查询语句,你可以把它们整合到一个查询中(即使它们之间没有关系) 8、删除重复记录最高效的删除重复记录方法 ( 因为使用了ROWID)例子： DELETE FROM EMP E WHERE E.ROWID &gt; (SELECT MIN(X.ROWID) FROM EMP X WHERE X.EMP_NO = E.EMP_NO); 9、用TRUNCATE替代DELETE当删除表中的记录时,在通常情况下, 回滚段(rollback segments ) 用来存放可以被恢复的信息. 如果你没有COMMIT事务,ORACLE会将数据恢复到删除之前的状态(准确地说是恢复到执行删除命令之前的状况) 而当运用TRUNCATE时, 回滚段不再存放任何可被恢复的信息.当命令运行后,数据不能被恢复.因此很少的资源被调用,执行时间也会很短. (译者按: TRUNCATE只在删除全表适用,TRUNCATE是DDL不是DML) 10、尽量多使用COMMIT只要有可能,在程序中尽量多使用COMMIT, 这样程序的性能得到提高,需求也会因为COMMIT所释放的资源而减少: COMMIT所释放的资源： a. 回滚段上用于恢复数据的信息. b. 被程序语句获得的锁 c. redo log buffer 中的空间 d. ORACLE为管理上述3种资源中的内部花费 11、用Where子句替换HAVING子句避免使用HAVING子句, HAVING 只会在检索出所有记录之后才对结果集进行过滤. 这个处理需要排序,总计等操作. 如果能通过WHERE子句限制记录的数目,那就能减少这方面的开销. (非oracle中)on、where、having这三个都可以加条件的子句中，on是最先执行，where次之，having最后，因为on是先把不 符合条件的记录过滤后才进行统计，它就可以减少中间运算要处理的数据，按理说应该速度是最快的，where也应该比having快点的，因为它过滤数据后 才进行sum，在两个表联接时才用on的，所以在一个表的时候，就剩下where跟having比较了。在这单表查询统计的情况下，如果要过滤的条件没有涉及到要计算字段，那它们的结果是一样的，只是where可以使用rushmore技术，而having就不能，在速度上后者要慢如果要涉及到计算的字 段，就表示在没计算之前，这个字段的值是不确定的，根据上篇写的工作流程，where的作用时间是在计算之前就完成的，而having就是在计算后才起作 用的，所以在这种情况下，两者的结果会不同。在多表联接查询时，on比where更早起作用。系统首先根据各个表之间的联接条件，把多个表合成一个临时表 后，再由where进行过滤，然后再计算，计算完后再由having进行过滤。由此可见，要想过滤条件起到正确的作用，首先要明白这个条件应该在什么时候起作用，然后再决定放在那里 12、 减少对表的查询在含有子查询的SQL语句中,要特别注意减少对表的查询.例子： 123SELECT TAB_NAME FROM TABLES WHERE (TAB_NAME,DB_VER) = ( SELECTTAB_NAME,DB_VER FROM TAB_COLUMNS WHERE VERSION = 604) 13、通过内部函数提高SQL效率复杂的SQL往往牺牲了执行效率. 能够掌握上面的运用函数解决问题的方法在实际工作中是非常有意义的 14、使用表的别名(Alias)当在SQL语句中连接多个表时, 请使用表的别名并把别名前缀于每个Column上.这样一来,就可以减少解析的时间并减少那些由Column歧义引起的语法错误. 15、 用EXISTS替代IN、用NOT EXISTS替代NOT IN在许多基于基础表的查询中,为了满足一个条件,往往需要对另一个表进行联接.在这种情况下, 使用EXISTS(或NOT EXISTS)通常将提高查询的效率. 在子查询中,NOT IN子句将执行一个内部的排序和合并. 无论在哪种情况下,NOT IN都是最低效的(因为它对子查询中的表执行了一个全表遍历). 为了避免使用NOT IN ,我们可以把它改写成外连接(Outer Joins)或NOT EXISTS. 例子： 1234567高效：SELECT * FROM EMP (基础表) WHERE EMPNO &gt; 0 AND EXISTS (SELECT ‘X' FROM DEPT WHERE DEPT.DEPTNO = EMP.DEPTNO AND LOC = ‘MELB')低效：SELECT * FROM EMP (基础表) WHERE EMPNO &gt; 0 AND DEPTNO IN(SELECT DEPTNO FROM DEPT WHERE LOC = ‘MELB') 16、识别’低效执行’的SQL语句虽然目前各种关于SQL优化的图形化工具层出不穷,但是写出自己的SQL工具来解决问题始终是一个最好的方法： 1234567891011121314151617SELECT EXECUTIONS , DISK_READS, BUFFER_GETS,ROUND((BUFFER_GETS-DISK_READS)/BUFFER_GETS,2) Hit_radio,ROUND(DISK_READS/EXECUTIONS,2) Reads_per_run,SQL_TEXTFROM V$SQLAREAWHERE EXECUTIONS&gt;0AND BUFFER_GETS &gt; 0AND (BUFFER_GETS-DISK_READS)/BUFFER_GETS &lt; 0.8ORDER BY 4 DESC; 17、用索引提高效率索引是表的一个概念部分,用来提高检索数据的效率，ORACLE使用了一个复杂的自平衡B-tree结构. 通常,通过索引查询数据比全表扫描要快. 当ORACLE找出执行查询和Update语句的最佳路径时, ORACLE优化器将使用索引. 同样在联结多个表时使用索引也可以提高效率. 另一个使用索引的好处是,它提供了主键(primary key)的唯一性验证.。那些LONG或LONG RAW数据类型, 你可以索引几乎所有的列. 通常, 在大型表中使用索引特别有效. 当然,你也会发现, 在扫描小表时,使用索引同样能提高效率. 虽然使用索引能得到查询效率的提高,但是我们也必须注意到它的代价. 索引需要空间来存储,也需要定期维护, 每当有记录在表中增减或索引列被修改时, 索引本身也会被修改. 这意味着每条记录的INSERT , DELETE , UPDATE将为此多付出4 , 5 次的磁盘I/O . 因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢.。定期的重构索引是有必要的.： 1ALTER INDEX &lt;INDEXNAME&gt; REBUILD &lt;TABLESPACENAME&gt; 18、用EXISTS替换DISTINCT当提交一个包含一对多表信息(比如部门表和雇员表)的查询时,避免在SELECT子句中使用DISTINCT. 一般可以考虑用EXIST替换, EXISTS 使查询更为迅速,因为RDBMS核心模块将在子查询的条件一旦满足后,立刻返回结果. 例子： 1234567891011低效：SELECT DISTINCT DEPT_NO,DEPT_NAME FROM DEPT D , EMP EWHERE D.DEPT_NO = E.DEPT_NO高效：SELECT DEPT_NO,DEPT_NAME FROM DEPT D WHERE EXISTS ( SELECT ‘X'FROM EMP E WHERE E.DEPT_NO = D.DEPT_NO); 19、sql语句用大写的；因为oracle总是先解析sql语句，把小写的字母转换成大写的再执行20、在java代码中尽量少用连接符“＋”连接字符串！21、避免在索引列上使用NOT 通常我们要避免在索引列上使用NOT, NOT会产生在和在索引列上使用函数相同的影响. 当ORACLE”遇到”NOT,他就会停止使用索引转而执行全表扫描. 22、避免在索引列上使用计算WHERE子句中，如果索引列是函数的一部分．优化器将不使用索引而使用全表扫描． 举例: 1234567低效：SELECT … FROM DEPT WHERE SAL * 12 &gt; 25000;高效:SELECT … FROM DEPT WHERE SAL &gt; 25000/12; 23、用&gt;=替代&gt;1234567高效:SELECT * FROM EMP WHERE DEPTNO &gt;=4低效:SELECT * FROM EMP WHERE DEPTNO &gt;3 两者的区别在于, 前者DBMS将直接跳到第一个DEPT等于4的记录而后者将首先定位到DEPTNO=3的记录并且向前扫描到第一个DEPT大于3的记录. 24、用UNION替换OR (适用于索引列)通常情况下, 用UNION替换WHERE子句中的OR将会起到较好的效果. 对索引列使用OR将造成全表扫描. 注意, 以上规则只针对多个索引列有效. 如果有column没有被索引, 查询效率可能会因为你没有选择OR而降低. 在下面的例子中, LOC_ID 和REGION上都建有索引. 1234567891011121314151617181920212223高效:SELECT LOC_ID , LOC_DESC , REGIONFROM LOCATIONWHERE LOC_ID = 10UNIONSELECT LOC_ID , LOC_DESC , REGIONFROM LOCATIONWHERE REGION = “MELBOURNE”低效：SELECT LOC_ID , LOC_DESC , REGIONFROM LOCATIONWHERE LOC_ID = 10 OR REGION = “MELBOURNE” 如果你坚持要用OR, 那就需要返回记录最少的索引列写在最前面. 25、用IN来替换OR 这是一条简单易记的规则，但是实际的执行效果还须检验，在ORACLE8i下，两者的执行路径似乎是相同的． 1234567低效:SELECT…. FROM LOCATION WHERE LOC_ID = 10 OR LOC_ID = 20 OR LOC_ID = 30高效SELECT… FROM LOCATION WHERE LOC_IN IN (10,20,30); 26、避免在索引列上使用IS NULL和IS NOT NULL避免在索引中使用任何可以为空的列，ORACLE将无法使用该索引．对于单列索引，如果列包含空值，索引中将不存在此记录. 对于复合索引，如果每个列都为空，索引中同样不存在此记录. 如果至少有一个列不为空，则记录存在于索引中．举例: 如果唯一性索引建立在表的A列和B列上, 并且表中存在一条记录的A,B值为(123,null) , ORACLE将不接受下一条具有相同A,B值（123,null）的记录(插入). 然而如果所有的索引列都为空，ORACLE将认为整个键值为空而空不等于空. 因此你可以插入1000 条具有相同键值的记录,当然它们都是空! 因为空值不存在于索引列中,所以WHERE子句中对索引列进行空值比较将使ORACLE停用该索引. 1234567低效: (索引失效)SELECT … FROM DEPARTMENT WHERE DEPT_CODE IS NOT NULL;高效: (索引有效)SELECT … FROM DEPARTMENT WHERE DEPT_CODE &gt;=0; 27、 总是使用索引的第一个列如果索引是建立在多个列上, 只有在它的第一个列(leading column)被where子句引用时,优化器才会选择使用该索引. 这也是一条简单而重要的规则，当仅引用索引的第二个列时,优化器使用了全表扫描而忽略了索引 28、用UNION-ALL 替换UNION ( 如果有可能的话)当SQL 语句需要UNION两个查询结果集合时,这两个结果集合会以UNION-ALL的方式被合并, 然后在输出最终结果前进行排序. 如果用UNION ALL替代UNION, 这样排序就不是必要了. 效率就会因此得到提高. 需要注意的是，UNION ALL 将重复输出两个结果集合中相同记录. 因此各位还是要从业务需求分析使用UNION ALL的可行性. UNION 将对结果集合排序,这个操作会使用到SORT_AREA_SIZE这块内存. 对于这块内存的优化也是相当重要的. 下面的SQL可以用来查询排序的消耗量 12345678910111213141516171819202122232425262728293031低效：SELECT ACCT_NUM, BALANCE_AMTFROM DEBIT_TRANSACTIONSWHERE TRAN_DATE = '31-DEC-95'UNIONSELECT ACCT_NUM, BALANCE_AMTFROM DEBIT_TRANSACTIONSWHERE TRAN_DATE = '31-DEC-95'高效:SELECT ACCT_NUM, BALANCE_AMTFROM DEBIT_TRANSACTIONSWHERE TRAN_DATE = '31-DEC-95'UNION ALLSELECT ACCT_NUM, BALANCE_AMTFROM DEBIT_TRANSACTIONSWHERE TRAN_DATE = '31-DEC-95' 29、用WHERE替代ORDER BY：ORDER BY 子句只在两种严格的条件下使用索引. ORDER BY中所有的列必须包含在相同的索引中并保持在索引中的排列顺序. ORDER BY中所有的列必须定义为非空. WHERE子句使用的索引和ORDER BY子句中所使用的索引不能并列. 例如: 表DEPT包含以下列: DEPT_CODE PK NOT NULL DEPT_DESC NOT NULL DEPT_TYPE NULL 1234567低效: (索引不被使用)SELECT DEPT_CODE FROM DEPT ORDER BY DEPT_TYPE高效: (使用索引)SELECT DEPT_CODE FROM DEPT WHERE DEPT_TYPE &gt; 0 30、避免改变索引列的类型当比较不同数**据类型的数据时, ORACLE自动对列进行简单的类型转换. 假设 EMPNO是一个数值类型的索引列. 1SELECT … FROM EMP WHERE EMPNO = ‘123' 实际上,经过ORACLE类型转换, 语句转化为: 1SELECT … FROM EMP WHERE EMPNO = TO_NUMBER(‘123') 幸运的是,类型转换没有发生在索引列上,索引的用途没有被改变. 现在,假设EMP_TYPE是一个字符类型的索引列. 1SELECT … FROM EMP WHERE EMP_TYPE = 123 这个语句被ORACLE转换为: 1SELECT … FROM EMP WHERETO_NUMBER(EMP_TYPE)=123 因为内部发生的类型转换, 这个索引将不会被用到! 为了避免ORACLE对你的SQL进行隐式的类型转换, 最好把类型转换用显式表现出来. 注意当字符和数值比较时, ORACLE会优先转换数值类型到字符类型 31、需要当心的WHERE子句某些SELECT 语句中的WHERE子句不使用索引. 这里有一些例子. 在下面的例子里, (1)‘!=’ 将不使用索引. 记住, 索引只能告诉你什么存在于表中, 而不能告诉你什么不存在于表中. (2) ‘ | |’是字符连接函数. 就象其他函数那样, 停用了索引. (3) ‘+’是数学函数. 就象其他数学函数那样, 停用了索引. (4)相同的索引列不能互相比较,这将会启用全表扫描. 32、a. 如果检索数据量超过30%的表中记录数.使用索引将没有显著的效率提高b. 在特定情况下, 使用索引也许会比全表扫描慢, 但这是同一个数量级上的区别. 而通常情况下,使用索引比全表扫描要块几倍乃至几千倍! 33、避免使用耗费资源的操作带有DISTINCT,UNION,MINUS,INTERSECT,ORDER BY的SQL语句会启动SQL引擎 执行耗费资源的排序(SORT)功能. DISTINCT需要一次排序操作, 而其他的至少需要执行两次排序. 通常, 带有UNION, MINUS , INTERSECT的SQL语句都可以用其他方式重写. 如果你的数据库的SORT_AREA_SIZE调配得好, 使用UNION , MINUS, INTERSECT也是可以考虑的, 毕竟它们的可读性很强 34、优化GROUP BY提高GROUP BY 语句的效率, 可以通过将不需要的记录在GROUP BY 之前过滤掉.下面两个查询返回相同结果但第二个明显就快了许多. 1234567891011121314151617181920212223低效:SELECT JOB , AVG(SAL)FROM EMPGROUP by JOBHAVING JOB = ‘PRESIDENT'OR JOB = ‘MANAGER'高效:SELECT JOB , AVG(SAL)FROM EMPWHERE JOB = ‘PRESIDENT'OR JOB = ‘MANAGER'GROUP by JOB 35、Select Count (*)和Select Count(1) 区别一般情况下，Select Count (*)和Select Count(1)两着返回结果是一样的 假如表沒有主键(Primary key), 那么count(1)比count(*)快， 如果有主键的話，那主键作为count的条件时候count(主键)最快 如果你的表只有一个字段的话那count(*)就是最快的 count(*) 跟 count(1) 的结果一样，都包括对NULL的统计，而count(column) 是不包括NULL的统计 selelct 常量 from … 对应所有行，返回的永远只有一个值，即常量 。所以正常只会用来判断是否有还是没有（比如exists子句）。而select * from … 是返回所有行的所有列。 性能上的差异，关键看你的from和where子句。比如说如果你的where条件中可以通过索引，那显然 select 1 from … 的性能比 select * from … 好。 select count(*)返回所有满足条件的记录数，此时同select sum(1) 但是sum()可以传任意数字，负数、浮点数都可以，返回的值是传入值n*满足条件记录数m 36、IS NULL 与 IS NOT NULL不能用null作索引，任何包含null值的列都将不会被包含在索引中。即使索引有多列这样的情况下，只要这些列中有一列含有null，该列就会从索引中排除。也就是说如果某列存在空值，即使对该列建索引也不会提高性能。 任何在where子句中使用is null或is not null的语句优化器是不允许使用索引的。 37、联接列对于有联接的列，即使最后的联接值为一个静态值，优化器是不会使用索引的。我们一起来看一个例子，假定有一个职工表(employee)，对于一个职工的姓和名分成两列存放(FIRST_NAME和LAST_NAME)，现在要查询一个叫比尔.克林顿(Bill Cliton)的职工。 下面是一个采用联接查询的SQL语句， 1select * from employss where first_name||''||last_name ='Beill Cliton'; ​ 上面这条语句完全可以查询出是否有Bill Cliton这个员工，但是这里需要注意，系统优化器对基于last_name创建的索引没有使用。 当采用下面这种SQL语句的编写，Oracle系统就可以采用基于last_name创建的索引。 1*** where first_name ='Beill' and last_name ='Cliton'; 带通配符(%)的like语句 同样以上面的例子来看这种情况。目前的需求是这样的，要求在职工表中查询名字中包含cliton的人。可以采用如下的查询SQL语句: 1select * from employee where last_name like '%cliton%'; 这里由于通配符(%)在搜寻词首出现，所以Oracle系统不使用last_name的索引。在很多情况下可能无法避免这种情况，但是一定要心中有底，通配符如此使用会降低查询速度。然而当通配符出现在字符串其他位置时，优化器就能利用索引。在下面的查询中索引得到了使用: 1select * from employee where last_name like 'c%'; 38、Order by语句ORDER BY语句决定了Oracle如何将返回的查询结果排序。Order by语句对要排序的列没有什么特别的限制，也可以将函数加入列中(象联接或者附加等)。任何在Order by语句的非索引项或者有计算表达式都将降低查询速度。 仔细检查order by语句以找出非索引项或者表达式，它们会降低性能。解决这个问题的办法就是重写order by语句以使用索引，也可以为所使用的列建立另外一个索引，同时应绝对避免在order by子句中使用表达式。 39、 NOT我们在查询时经常在where子句使用一些逻辑表达式，如大于、小于、等于以及不等于等等，也可以使用and(与)、or(或)以及not(非)。NOT可用来对任何逻辑运算符号取反。下面是一个NOT子句的例子: 1... where not (status ='VALID') 如果要使用NOT，则应在取反的短语前面加上括号，并在短语前面加上NOT运算符。NOT运算符包含在另外一个逻辑运算符中，这就是不等于(&lt;&gt;)运算符。换句话说，即使不在查询where子句中显式地加入NOT词，NOT仍在运算符中，见下例: 1... where status &lt;&gt;'INVALID'; 对这个查询，可以改写为不使用NOT: 1select * from employee where salary&lt;3000 or salary&gt;3000; 虽然这两种查询的结果一样，但是第二种查询方案会比第一种查询方案更快些。第二种查询允许Oracle对salary列使用索引，而第一种查询则不能使用索引。]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>SQL优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【推荐】Hexo 的 Next 主题优化/个性化]]></title>
    <url>%2Fblog%2F2017-06-06.Hexo-theme-next-optimize%2F</url>
    <content type="text"><![CDATA[参考自： Hexo 官方 Doc NexT 官方 Doc 【主要来源】hexo的next主题个性化教程:打造炫酷网站 Hexo常见问题解决方案 hexo优化 0. 基本配置部署到多平台 参考 ： 将hexo-github博客同步托管至coding 由于百度蜘蛛把github屏蔽了，导致百度搜不到博客文章，let me feel a little unhappy，为了扩大网站收录率，我将hexo-github博客同步托管到国内coding上。 Hexo提供了hexo-deployer-git工具，可以帮助部署Hexo到很多平台。 1$ npm install hexo-deployer-git --save 修改_config.yml中的配置： 123456deploy: type: git repo: coding: git@git.coding.net:yafey/blog.git github: git@github.com:yafey/blog.git branch: master 然后执行命令： 12hexo g # 生成， hexo generate 的缩写hexo d # 部署， hexo deploy 的缩写 以下参考自 ： Hexo博客搭建之使用Hexo+GitHub搭建个人博客 在使用框架时，会常用到以下几个命令： 12345$ hexo generate // 简写：hexo g，生成静态文件，会在当前目录下生成一个public文件夹$ hexo server // 简写：hexo s，启动本地服务，用于博客的预览$ hexo deploy // 简写：hexo d，部署到远程（如GitHub，可以在_config.yml中配置）$ hexo new post-name // 简写：hexo n post-name， 新建文章$ hexo new page page-name //简写：hexo n page page-name，新建页面 还有常用的组合命令： 12$ hexo d -g // 生成和部署$ hexo s -g // 生成和预览 草稿命令： 123$ hexo new draft &lt;title&gt; // 新建草稿，存放在source/_drafts$ hexo publish post &lt;title&gt; // 发布草稿为文章，文章转移到source/_posts$ hexo s -g --drafts // 显示草稿 简单必要设置 注意：配置文件要符合英文标点符号使用规范: 冒号后必须空格，否则会编译错误 a. Hexo _config.yml 修改语言 123language: - zh-Hans # 中文 - defaults b. next _config.yml 修改 主题 1scheme: Mist #整洁有序的单栏外观 ， 右侧边栏 c. 网站标题，作者Hexo _config.yml ，修改这些值：12345title: Y.a.F.e.Y Blog #博客标题subtitle: #博客副标题description: #博客描述author: YaFey #作者timezone: Asia/Chongqing d. 域名，文章链接 Hexo _config.yml ，修改这些值：1234url: http://xxx #你的博客网址root: /blog/ #博客跟目录，如果你的博客在网址的二级目录下，在这里填上permalink: :year/:month/:day/:title/permalink_defaults: #可以不填 e. 创建页面 &amp; 修改菜单 添加「标签」页面 添加「分类」页面 标签 和 分类 禁用评论 123456---title: categories # 若 标签， title 为 tagsdate: 2017-05-28 09:53:57type: "categories" # 若 标签， 引号内 为 tagscomments: false #禁用评论--- 1. next 主题优化 看到有些next主题的网站很炫酷，那么是怎么配置的呢？接下来我会讲一讲如何实现一些炫酷的效果 主要有以下29种： 在右上角或者左上角实现fork me on github 添加RSS 添加动态背景 实现点击出现桃心效果 修改文章内链接文本样式 修改文章底部的那个带#号的标签 在每篇文章末尾统一添加“本文结束”标记 修改作者头像并旋转 博文压缩 修改``代码块自定义样式 侧边栏社交小图标设置 主页文章添加阴影效果 在网站底部加上访问量 添加热度 网站底部字数统计 添加 README.md 文件 设置网站的图标Favicon 实现统计功能 添加顶部加载条 在文章底部增加版权信息 添加网易云跟帖 隐藏网页底部powered By Hexo / 强力驱动 修改网页底部的桃心 文章加密访问 添加jiathis分享 博文置顶 修改字体大小 修改打赏字体不闪动 侧边栏推荐阅读 0. 无痛使用图片参考另一篇文章 在 hexo 中无痛使用本地图片 1. 在右上角或者左上角实现fork me on github实现效果图 具体实现方法 点击这里挑选自己喜欢的样式，并复制代码。 例如，我是复制如下代码：然后粘贴刚才复制的代码到themes/next/layout/_layout.swig文件中(放在&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;的下面)，并把href改为你的github地址 2.添加RSS实现效果图 具体实现方法 切换到你的blog（我是取名blog，具体的看你们的取名是什么）的路径，例如我是在/Users/chenzekun/Code/Hexo/blog这个路径上，也就是在你的根目录下 然后安装 Hexo 插件：(这个插件会放在node_modules这个文件夹里) 1$ npm install --save hexo-generator-feed 接下来打开画红线的文件，如下图： 在里面的末尾添加：(请注意在冒号后面要加一个空格，不然会发生错误！) 123# Extensions## Plugins: http://hexo.io/plugins/plugins: hexo-generate-feed 然后打开next主题文件夹里面的_config.yml,在里面配置为如下样子：(就是在rss:的后面加上/atom.xml,注意在冒号后面要加一个空格) 1234# Set rss to false to disable feed link.# Leave rss as empty to use site's feed link.# Set rss to specific value if you have burned your feed already.rss: /atom.xml 配置完之后运行： 1$ hexo g 重新生成一次，你会在./public 文件夹中看到 atom.xml 文件。然后启动服务器查看是否有效，之后再部署到 Github 中。 3. 添加动态背景实现效果图 具体实现方法 这个我之前有一篇文章有讲过了，详情点击我的博客 修改_layout.swig打开 next/layout/_layout.swig在 &lt; /body&gt;之前添加代码(注意不要放在&lt; /head&gt;的后面) 123&#123;% if theme.canvas_nest %&#125;&lt;script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"&gt;&lt;/script&gt;&#123;% endif %&#125; 修改配置文件打开 /next/_config.yml,在里面添加如下代码：(可以放在最后面) 123456# --------------------------------------------------------------# background settings# --------------------------------------------------------------# add canvas-nest effect# see detail from https://github.com/hustcc/canvas-nest.jscanvas_nest: true 到此就结束了，运行 hexo clean，然后运行 hexo g,然后运行 hexo s，最后打开浏览器在浏览器的地址栏输入 localhost:4000 就能看到效果了\（￣︶￣）/ 如果你感觉默认的线条太多的话可以这么设置====&gt;在上一步修改 _layout.swig中，把刚才的这些代码： 123&#123;% if theme.canvas_nest %&#125;&lt;script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"&gt;&lt;/script&gt;&#123;% endif %&#125; 改为 1234&#123;% if theme.canvas_nest %&#125;&lt;script type="text/javascript"color="0,0,255" opacity='0.7' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"&gt;&lt;/script&gt;&#123;% endif %&#125; 配置项说明 color ：线条颜色, 默认: &#39;0,0,0&#39;；三个数字分别为(R,G,B) opacity: 线条透明度（0~1）, 默认: 0.5 count: 线条的总数量, 默认: 150 zIndex: 背景的z-index属性，css属性用于控制所在层的位置, 默认: -1 4. 实现点击出现桃心效果实现效果图 具体实现方法 在网址输入如下 1http://7u2ss1.com1.z0.glb.clouddn.com/love.js 然后将里面的代码copy一下，新建love.js文件并且将代码复制进去，然后保存。将love.js文件放到路径/themes/next/source/js/src里面，然后打开\themes\next\layout\_layout.swig文件,在末尾（在前面引用会出现找不到的bug）添加以下代码： 12&lt;!-- 页面点击小红心 --&gt;&#123;% include '_third-party/love.swig' %&#125; 新建 love.swig 1&lt;script type="text/javascript" src="&#123;&#123; url_for(theme.js) &#125;&#125;/src/love.js"&gt;&lt;/script&gt; 5. 修改文章内链接文本样式实现效果图 具体实现方法 修改文件 themes\next\source\css\_common\components\post\post.styl，在末尾添加如下css样式，： 1234567891011// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 其中选择.post-body 是为了不影响标题，选择 p 是为了不影响首页“阅读全文”的显示样式,颜色可以自己定义。 6. 修改文章底部的那个带#号的标签实现效果图 具体实现方法 修改模板/themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将 # 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 7. 在每篇文章末尾统一添加“本文结束”标记实现效果图 具体实现方法 在路径 \themes\next\layout\_macro 中新建 passage-end-tag.swig 文件,并添加以下内容： 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;-------------本文结束&lt;i class="fa fa-paw"&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 接着打开\themes\next\layout\_macro\post.swig文件，在post-body 之后， post-footer 之前添加如下画红色部分代码（post-footer之前两个DIV）： 代码如下： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 然后打开主题配置文件（_config.yml),在末尾添加： 123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 完成以上设置之后，在每篇文章之后都会添加如上效果图的样子。 8. 修改作者头像并旋转实现效果图 具体实现方法 打开\themes\next\source\css\_common\components\sidebar\sidebar-author.styl，在里面添加如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125; 9. 博文压缩在站点的根目录下执行以下命令： 12$ npm install gulp -g$ npm install gulp-clean-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save 在如下图所示，新建 gulpfile.js ，并填入以下内容： 123456789101112131415161718192021222324252627282930313233var gulp = require('gulp');var minifycss = require('gulp-clean-css');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');// 压缩 public 目录 cssgulp.task('minify-css', function() &#123; return gulp.src('./public/**/*.css') .pipe(minifycss()) .pipe(gulp.dest('./public'));&#125;);// 压缩 public 目录 htmlgulp.task('minify-html', function() &#123; return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest('./public'))&#125;);// 压缩 public/js 目录 jsgulp.task('minify-js', function() &#123; return gulp.src('./public/**/*.js') .pipe(uglify()) .pipe(gulp.dest('./public'));&#125;);// 执行 gulp 命令时执行的任务gulp.task('default', [ 'minify-html','minify-css','minify-js']); 生成博文时执行 hexo g &amp;&amp; gulp 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。 10. 修改``代码块自定义样式实现效果图 具体实现方法 打开\themes\next\source\css\_custom\custom.styl,向里面加入：(颜色可以自己定义) 123456789101112131415// Custom styles.code &#123; color: #ff7600; background: #fbf7f8; margin: 2px;&#125;// 大代码块的自定义样式.highlight, pre &#123; margin: 5px 0; padding: 5px; border-radius: 3px;&#125;.highlight, code, pre &#123; border: 1px solid #d6d6d6;&#125; 11. 侧边栏社交小图标设置实现效果图 具体实现方法 打开主题配置文件（_config.yml），搜索social_icons:,在图标库找自己喜欢的小图标，并将名字复制在如下位置，保存即可 12. 主页文章添加阴影效果实现效果图 具体实现方法 打开\themes\next\source\css\_custom\custom.styl,向里面加入： 12345678// 主页文章添加阴影效果 .post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 13. 在网站底部加上访问量实现效果图 具体实现方法打开\themes\next\layout\_partials\footer.swig文件,在copyright前加上画红线这句话： 代码如下： 1&lt;script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt; 然后再合适的位置添加显示统计的代码，如图：代码如下： 12345&lt;div class="powered-by"&gt;&lt;i class="fa fa-user-md"&gt;&lt;/i&gt;&lt;span id="busuanzi_container_site_uv"&gt; 本站访客数:&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt; 在这里有两中不同计算方式的统计代码： pv的方式，单个用户连续点击n篇文章，记录n次访问量 123&lt;span id="busuanzi_container_site_pv"&gt; 本站总访问量&lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt;次&lt;/span&gt; uv的方式，单个用户连续点击n篇文章，只记录1次访客数 123&lt;span id="busuanzi_container_site_uv"&gt; 本站总访问量&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;次&lt;/span&gt; 添加之后再执行hexo d -g，然后再刷新页面就能看到效果 14. 添加热度实现效果图 具体实现方法 next主题集成leanCloud，打开/themes/next/layout/_macro/post.swig,在画红线的区域添加℃： 然后打开，/themes/next/languages/zh-Hans.yml,将画红框的改为热度就可以了 15. 网站底部字数统计实现效果图 具体方法实现切换到根目录下，然后运行如下代码 1$ npm install hexo-wordcount --save 然后在/themes/next/layout/_partials/footer.swig文件尾部加上： 1234&lt;div class="theme-info"&gt; &lt;div class="powered-by"&gt;&lt;/div&gt; &lt;span class="post-count"&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 16. 添加 README.md 文件每个项目下一般都有一个 README.md 文件，但是使用 hexo 部署到仓库后，项目下是没有 README.md 文件的。 在 Hexo 目录下的 source 根目录下添加一个 README.md 文件，修改站点配置文件 _config.yml，将 skip_render 参数的值设置为 1skip_render: README.md 保存退出即可。再次使用 hexo d 命令部署博客的时候就不会在渲染 README.md 这个文件了。 17. 设置网站的图标Favicon实现效果图 具体方法实现 在EasyIcon中找一张（32*32）的ico图标,或者去别的网站下载或者制作，并将图标名称改为favicon.ico，然后把图标放在/themes/next/source/images里，并且修改主题配置文件： 12# Put your favicon.ico into `hexo-site/source/` directory.favicon: /favicon.ico 18. 实现统计功能实现效果图 具体实现方法 在根目录下安装 hexo-wordcount,运行： 1$ npm install hexo-wordcount --save 然后在主题的配置文件中，配置如下： 123456# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true 19. 添加顶部加载条实现效果图 具体实现方法 打开/themes/next/layout/_partials/head.swig文件，添加红框上的代码代码如下： 12&lt;script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"&gt;&lt;/script&gt;&lt;link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"&gt; 但是，默认的是粉色的，要改变颜色可以在/themes/next/layout/_partials/head.swig文件中添加如下代码（接在刚才link的后面） 12345678910111213&lt;style&gt; .pace .pace-progress &#123; background: #1E92FB; /*进度条颜色*/ height: 3px; &#125; .pace .pace-progress-inner &#123; box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/ &#125; .pace .pace-activity &#123; border-top-color: #1E92FB; /*上边框颜色*/ border-left-color: #1E92FB; /*左边框颜色*/ &#125;&lt;/style&gt; 目前，博主的增加顶部加载条的pull request 已被Merge😀===&gt;详情现在升级最新版的next主题，升级后只需修改主题配置文件(_config.yml)将pace: false改为pace: true就行了，你还可以换不同样式的加载条，如下图： 20. 在文章底部增加版权信息实现效果图 在目录 next/layout/_macro/下添加 my-copyright.swig： 1234567891011121314151617181920212223242526272829303132&#123;% if page.copyright %&#125;&lt;div class="my_post_copyright"&gt; &lt;script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script type="text/javascript" src="http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js"&gt;&lt;/script&gt; &lt;script src="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" type="text/css" href="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css"&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;"&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href="/" title="访问 &#123;&#123; theme.author &#125;&#125; 的个人博客"&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format("YYYY年MM月DD日 - HH:MM") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format("YYYY年MM月DD日 - HH:MM") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;" title="&#123;&#123; page.title &#125;&#125;"&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class="copy-path" title="点击复制文章链接"&gt;&lt;i class="fa fa-clipboard" data-clipboard-text="&#123;&#123; page.permalink &#125;&#125;" aria-label="复制成功！"&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class="fa fa-creative-commons"&gt;&lt;/i&gt; &lt;a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)"&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard('.fa-clipboard'); clipboard.on('success', $(function()&#123; $(".fa-clipboard").click(function()&#123; swal(&#123; title: "", text: '复制成功', html: false, timer: 500, showConfirmButton: false &#125;); &#125;); &#125;)); &lt;/script&gt;&#123;% endif %&#125; 在目录next/source/css/_common/components/post/下添加my-post-copyright.styl： 123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 修改next/layout/_macro/post.swig，在代码 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'wechat-subscriber.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 之前添加增加如下代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'my-copyright.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 如下： 修改next/source/css/_common/components/post/post.styl文件，在最后一行增加代码： 1@import "my-post-copyright" 保存重新生成即可。如果要在该博文下面增加版权信息的显示，需要在 Markdown 中增加copyright: true的设置，类似： 1234567---title: 前端小项目：使用canvas绘画哆啦A梦date: 2017-05-22 22:53:53tags: canvascategories: 前端copyright: true--- 小技巧：如果你觉得每次都要输入copyright: true很麻烦的话,那么在/scaffolds/post.md文件中添加：这样每次hexo new &quot;你的内容&quot;之后，生成的md文件会自动把copyright:加到里面去(注意：如果解析出来之后，你的原始链接有问题：如：http://yoursite.com/前端小项目：使用canvas绘画哆啦A梦.html,那么在根目录下_config.yml中写成类似这样：）就行了。 21. 添加网易云跟帖实现效果图 具体方法实现有两种实现方法：①更新next主题，因为最新版本的主题已经支持这种评论。直接在主题配置文件_config.yml 文件中添加如下配置: 12 1gentie_productKey: #your-gentie-product-key ②如果你不想更新的话，那么按下面步骤进行：首先，还是在主题配置文件_config.yml 文件中添加如下配置: 12 1gentie_productKey: #your-gentie-product-key 你的productKey就是下面画红线部分 然后在在layout/_scripts/third-party/comments/ 目录中添加 gentie.swig，文件内容如下： 12 1234567891011121314&#123;% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname and not theme.disqus_shortname and not theme.hypercomments_id %&#125; &#123;% if theme.gentie_productKey %&#125; &#123;% set gentie_productKey = theme.gentie_productKey %&#125; &lt;script&gt; var cloudTieConfig = &#123; url: document.location.href, sourceId: "", productKey: "&#123;&#123;gentie_productKey&#125;&#125;", target: "cloud-tie-wrapper" &#125;; &lt;/script&gt; &lt;script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"&gt;&lt;/script&gt; &#123;% endif %&#125;&#123;% endif %&#125; 然后在layout/_scripts/third-party/comments.swig文件中追加： 12 1&#123;% include './comments/gentie.swig' %&#125; 最后，在 layout/_partials/comments.swig 文件中条件最后追加网易云跟帖插件引用的判断逻辑： 12 123&#123;% elseif theme.gentie_productKey %&#125; &lt;div id="cloud-tie-wrapper" class="cloud-tie-wrapper"&gt; &lt;/div&gt; 具体位置如下： 可能你hexo s时可能看不到，直接hexo d就可以看到了 22. 隐藏网页底部powered By Hexo / 强力驱动打开themes/next/layout/_partials/footer.swig,使用””隐藏之间的代码即可，或者直接删除。位置如图： 23. 修改网页底部的桃心还是打开themes/next/layout/_partials/footer.swig，找到：，然后还是在图标库中找到你自己喜欢的图标，然后修改画红线的部分就可以了。 24. 文章加密访问实现效果图 具体实现方法 打开themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件,在以下位置插入这样一段代码： 代码如下： 12345678910&lt;script&gt; (function()&#123; if('&#123;&#123; page.password &#125;&#125;')&#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;')&#123; alert('密码错误！'); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 然后在文章上写成类似这样： 25. 添加jiathis分享在主题配置文件中，jiathis为true，就行了，如下图 默认是这样子的：如果你想自定义话，打开themes/next/layout/_partials/share/jiathis.swig修改画红线部分就可以了 26. 博文置顶修改 hero-generator-index 插件，把文件：node_modules/hexo-generator-index/lib/generator.js 内的代码替换为： 12345678910111213141516171819202122232425262728'use strict';var pagination = require('hexo-pagination');module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 在文章中添加 top 值，数值越大文章越靠前，如 12345678---title: 解决Charles乱码问题date: 2017-05-22 22:45:48tags: 技巧categories: 技巧copyright: truetop: 100--- 27. 修改字体大小打开\themes\next\source\css\ _variables\base.styl文件，将$font-size-base改成16px，如下所示： 1$font-size-base =16px 28. 修改打赏字体不闪动修改文件next/source/css/_common/components/post/post-reward.styl，然后注释其中的函数wechat:hover和alipay:hover，如下： 123456789101112/* 注释文字闪动函数 #wechat:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125; #alipay:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125;*/ 29. 侧边栏推荐阅读今天有位网友问推荐阅读是怎么弄，其实挺简单的，打开主题配置文件修改成这样就行了(links里面写你想要的链接): 1234567891011# Blogrollslinks_title: 推荐阅读#links_layout: blocklinks_layout: inlinelinks: 优设: http://www.uisdc.com/ 张鑫旭: http://www.zhangxinxu.com/ Web前端导航: http://www.alloyteam.com/nav/ 前端书籍资料: http://www.36zhen.com/t?id=3448 百度前端技术学院: http://ife.baidu.com/ google前端开发基础: http://wf.uisdc.com/cn/ 致谢 感谢大神们的文章，真的学到了许多，有些忘了记录下来，在这里由衷的感谢。虽然比较折腾，但是确实满满的成就感，Road endless its long and far, I will seek up and down！ 欢迎访问我的博客 参考的文章： http://blog.csdn.net/MasterAnt_D/article/details/56839222 http://zidingyi4qh.com/2017/04/27/NexT%E5%BA%95%E9%83%A8logo%E6%B7%BB%E5%8A%A0%E8%AE%BF%E9%97%AE%E9%87%8F/ https://fuyis.me/2017/01/25/Hexo-theme-next-and-optimized-configuration/ http://www.vitah.net/posts/20f300cc/ http://thief.one/2017/03/03/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next 主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 常用操作]]></title>
    <url>%2Fblog%2F2017-06-06.git-brief%2F</url>
    <content type="text"><![CDATA[git 初始化（以下命令在 Git Bash中操作）添加 Coding 账户 SSH 公钥 TL;DR [^1] 参考 ： coding 帮助中心 生成公钥打开命令行终端输入ssh-keygen -t rsa -C “username@example.com”,( 注册的邮箱)，接下来点击enter键即可（也可以输入密码）。 12345ssh-keygen -t rsa -b 4096 -C "your_email@example.com"# Creates a new ssh key, using the provided email as a label# Generating public/private rsa key pair.Enter file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter] // 因为有多个git 仓库，所以 推荐跟仓库名及使用的电脑相关， 如：coding_pcEnter passphrase (empty for no passphrase): 成功之后 1234Your identification has been saved in /Users/you/.ssh/id_rsa.# Your public key has been saved in /Users/you/.ssh/id_rsa.pub.# The key fingerprint is:# 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com 添加公钥 本地打开 id_rsa.pub 文件，复制其中全部内容，填写到SSH_RSA公钥key下的一栏，公钥名称可以随意起名字。 完成后点击“添加”，然后输入密码或动态码即可添加完成。 完成后在命令行测试，首次建立链接会要求信任主机。 ssh -T git@git.coding.net 12~/git $ ssh -T git@git.coding.netHello yafey! You've connected to Coding.net via SSH successfully! 【知识点】多个账户配置 （如 github + coding）如果需要使用多个账户建议生成多个公钥，可以在 ~/.ssh/config文件中加上下边一段 12345# 该文件用于配置私钥对应的服务器Host git.coding.netUser xxxx@email.com # 这里 也可以配置成 `User git`PreferredAuthentications publickeyIdentityFile ~/.ssh/coding_rsa # 生成的非默认地址的公钥存放点 git clone --recursive好像是会把 submodule 也更新好， 待验证。 git 初始化项目在命令行中创建 Git 仓库 12345678mkdir HexoBlogSourcecd HexoBlogSourcegit initecho "# HexoBlogSource" &gt;&gt; README.mdgit add README.mdgit commit -m "first commit"git remote add origin https://git.coding.net/yafey/HexoBlogSource.gitgit push -u origin master 已有项目 12git remote add origin https://git.coding.net/yafey/HexoBlogSource.gitgit push -u origin master git 常用操作集锦tag remote branch HEAD directly 参考 ： Git: Is there a way to tag remote branch HEAD directly by commit id? No real need to mess with local tags, just do the rewrite while pushing. 12# 替换下面的 &lt;&gt; 中的内容， 如果只有一个 remote ，origin 不用替换。git push &lt;origin&gt; refs/remotes/&lt;origin&gt;/&lt;branch1&gt;:refs/tags/&lt;tagged-branch1&gt; [^1]: Too Long; Don’t Read的缩写，换成中国话，就是太长了，读不下去的意思。 网络上的文章都太长了？ @2012-11-27 09:30 根据字典解释，“TL;DR”发源自网络。一般用于回复别人写得太多，反而让人抓不住重点，现在有的人把它放在一段话的开头，代表“长话短说”的意思——如今不少服务都直接以“TL;DR”为命名，把网络上一篇很长的报道，缩短成简单的三两句话，让人快速抓住文章的精华。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【简要】记录搭建 Hexo 的一些步骤]]></title>
    <url>%2Fblog%2F2017-06-06.Hexo-brief%2F</url>
    <content type="text"><![CDATA[总想有个自己的地方记录一些东西， 兜兜转转，还是选择了GitHub Pages。试过Jekyll，可惜ruby跟我相性实在不合，折腾了半天也没搞明白。于是选择了Hexo。使用很简单，js也比ruby亲切些，但搭建过程中还是碰到一些问题，这里记录下。 安装 Node.js暂时略， 可参考 记录下搭建hexo的一些问题 by 自制node.js + npm绿色版 安装 Git略， 作为开发， 你电脑上都没有 Git ？ 教程网上一大把。 建议： 安装的时候， 不要选择 checkout Window ，commit Linux ， 这样自动转换 EOL 的 默认选项。 安装 Hexo 【重头戏开始了】写博客时 2017年6月6日23:46:34 的 版本信息 ，Hexo 不同的版本变化还挺大的。 12345678910111213PS ~\git\HexoBlogSource&gt; hexo versionhexo: 3.3.7hexo-cli: 1.0.3os: Windows_NT 10.0.14393 win32 x64http_parser: 2.7.0node: 6.9.2v8: 5.1.281.88uv: 1.9.1zlib: 1.2.8ares: 1.10.1-DEVicu: 57.1modules: 48openssl: 1.0.2j Hexo 官网 给出了 最简单的 安装步骤 (稍加整理) 1234567891011# npm安装时其实可以指定版本号npm install hexo-cli -ghexo init blogcd blog# 安装一些必要的依赖 ， 执行前看下 &lt;【知识点】在中国，npm 使用优化 &gt;npm installhexo s[erver] -p 80 # [] 方括号中的内容可省略# 可选，使用rss时才需要npm install hexo-generator-feed --save# 可选，生成sitemapnpm install hexo-generator-sitemap --save 【知识点】在中国，npm 使用优化 网络不好、被墙的话，npm会很慢，试试加参数--registry=http://r.cnpmjs.org，国内的镜像。 出现各种奇怪的错误的话，试试npm cache clear。 将 Npm 的源替换成淘宝的源 参考 ： 将 Npm 的源替换成淘宝的源 by sg.ff @2016年02月17日发布 在墙内久了，难免会碰到撞墙的时候，所幸国内也有众多 NPM 镜像可供选择，在大多数情况下我们可以使用国内的源（比如 淘宝 NPM 镜像 http://npm.taobao.org）去替换官方的源以加快下载包的速度。 不过呢，我们在发布自己的包的时候却需要将源修改回官方的 https://registry.npmjs.org 源。 1234567# 修改源地址为淘宝 NPM 镜像npm config set registry http://registry.npm.taobao.org/# 修改源地址为官方源npm config set registry https://registry.npmjs.org/ 安装 Next 主题 hexo的主题很多，但感觉好看的不多。。。最终选择了NexT，很喜欢这种简洁的风格，作者更新也很积极。 你会爱上 Next 的 。 Hexo 主题的同步目前是个问题， 详见 另一篇文章 《Hexo 主题同步》 Next 主题优化内容太多， 详见 另一篇文章 《Hexo Next 主题优化》 未解之谜 可能的原因： 参考自： Hexo部署常见问题解决方案 将自己的Blog文件夹使用Git来管理，需要注意一下几点。 如果主题是通过git管理的，需要将主题文件夹下的.git文件夹删除，才能同步Blog文件夹（.git文件夹是隐藏的，需要显示隐藏文件才能删除，Linux下需要rm -rf命令才能删除，Mac没用过，不清楚）。 按照Blog目录下自带的.gitignore文件，node_modules文件夹是不会同步的，所以同步之后需要自己再次进行npm install，但是注意，不要进行hexo init了，否则_config.yml全都白弄了。 可以看到 hexo init a 时， 会自动把 landscape 下载好， 日志中也打出了 Submodule &#39;themes/landscape&#39; (...) registered for path &#39;themes/landscape&#39; 这样的信息， 但是： 奇怪的就是 ， landscape 在 Hexo 根目录 用 git gui 命令 是可以看到 文件的， 但是 next 主题只显示 subproject 一个文件， 难道是因为 hexo init a 用了类似 git clone --recursive 的语法，然后就不作为一个 subproject 了？ 然后我把 landscape 目录删了， 按 Next 方式 clone 了一遍， landscape 目录也像 next 那样只显示 subproject 一个文件， 这样也好，减少了很多文件。 1234567891011121314151617181920212223242526272829303132333435363738PS ~\git&gt; hexo init aINFO Cloning hexo-starter to ~\git\aCloning into '~\git\a'...remote: Counting objects: 53, done.remote: Total 53 (delta 0), reused 0 (delta 0), pack-reused 53Unpacking objects: 100% (53/53), done.Submodule 'themes/landscape' (https://github.com/hexojs/hexo-theme-landscape.git) registered for path 'themes/landscape'Cloning into '~/git/a/themes/landscape'...remote: Counting objects: 775, done.remote: Total 775 (delta 0), reused 0 (delta 0), pack-reused 775Receiving objects: 100% (775/775), 2.53 MiB | 1.18 MiB/s, done.Resolving deltas: 100% (397/397), done.INFO Install dependencies��Ϣ: ���ṩ��ģʽ�޷��ҵ��ļ�npm WARN deprecated swig@1.4.2: This package is no longer maintainednpm WARN prefer global marked@0.3.6 should be installed with -g&gt; fsevents@1.1.1 install ~\git\a\node_modules\fsevents&gt; node install&gt; dtrace-provider@0.8.2 install ~\git\a\node_modules\dtrace-provider&gt; node scripts/install.js&gt; hexo-util@0.6.0 postinstall ~\git\a\node_modules\hexo-util&gt; npm run build:highlightnpm WARN invalid config loglevel="notice"&gt; hexo-util@0.6.0 build:highlight ~\git\a\node_modules\hexo-util&gt; node scripts/build_highlight_alias.js &gt; highlight_alias.jsonnpm notice created a lockfile as package-lock.json. You should commit this file.added 438 packages in 200.46sINFO Start blogging with Hexo! 参考 ： 【重点参考】记录下搭建hexo的一些问题 最简便的方法搭建Hexo+Github博客,基于Next主题 Hexo部署常见问题解决方案 – 传送门]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 主题同步]]></title>
    <url>%2Fblog%2F2017-06-06.Hexo-theme-sync%2F</url>
    <content type="text"><![CDATA[主题同步的时候肯定会产生冲突，不要害怕冲突，有冲突是好事，还能增强对 Git 的使用，只能这样安慰自己了。 关于 主题 同步，考虑了好几天， 还是采用这个方案吧。 参考 ： 同步hexo主题 主题作者一直在增加新功能，我偶尔会修改下主题的样式，如何应用到我自己的站点里？其实就是git的submodule的用法。 12345678910111213# 首先clone我自己的 repo 到 Hexo 的根目录 ， 注意最后的 ` themes/next`git clone &lt;hexo-theme-next@bitbucket.org&gt; themes/next# cd themes/next 并 添加一个github的remotecd themes/nextgit remote add github git@github.com:iissnan/hexo-theme-next.git # 注意这是不是 origin , origin 其实是默认的别名# 将作者的一些更新合并到我自己的分支git pull github master # 注意这是不是 origingit checkout foolbeargit merge master# 肯定会有些冲突，解决冲突后commitgit commit -m "xxx"# 修改后的foolbear分支push到我自己的repogit push origin foolbear 以下操作在我自己笔记本上 123cd themes/nextgit pullgit checkout foolbear 概念上是很简单的，只是记录下。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next 主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 ES Decorators 构建一致性 API「淘宝FED前端团队」]]></title>
    <url>%2Fblog%2F2017-06-02.building-consistent-api-with-es-decorators%2F</url>
    <content type="text"><![CDATA[使用 ES decorators 构建一致性 API作者: 法海 发表于: 2017-04-27 重用和一致性是程序设计中经久不衰的两个课题。在最新的 ES Proposal 中，「decorators 语法」为此带来了一定的便利，并且，很适合应用于大型的类库中。 装饰模式提到 decorator 大家都不会陌生，即「装饰模式」—— 我们可以在「不侵入原有代码」的情况下，为代码增加一些「额外的功能」。 所谓「额外的功能」一般都比较独立，不和原有逻辑耦合，只是做一层包装。你也可以把它看成「包装模式」。形如： 123456789101112131415// 旧方法function func() &#123;&#125;// 包装后的新方法function funcWrapped() &#123; // 有的没的 doSomethingBefore(); // 旧方法的过程本身并不变化 func(); // 这啊那的 doSomethingAfter();&#125; 这样看来，有一些场景特别适用这个模式，比如： 记录方法的开始执行和结束执行。 为运算过程提供额外的缓存能力。 标记方法为 deprecated。 等等。 编写一个装饰器如果有好多方法都想包上这种「额外的功能」，那么我们不会一个个地去改写，而是考虑抽出一个「装饰器」—— 它能够接受原方法，然后生成包装后的方法。比如，我们想记录所有方法的运行时间： 12345678910111213141516171819function performanceTimingDecorator(func) &#123; // 返回包装后的新方法 return function(...args) &#123; const start = Date.now(); func(...args); const end = Date.now(); const t = end - start; console.log(`$&#123;func.name&#125; performed $&#123;t&#125;ms.`); &#125;;&#125;function func() &#123;&#125;const funcWrapped = performanceTimingDecorator(func);// func performed 2ms.funcWrapped(); 使用 ES decorators如果一个系统内需要大量运用装饰器，那么上述的写法可读性还有待提高。ES decorators 解决了这个问题，这是一个新的语法（语法糖）： 123456789101112131415// 定义 decoratorfunction performanceTiming(...args) &#123; // 返回包装后的方法 return function(target, key, descriptor) &#123; // ... &#125;;&#125;class MyClass &#123; // 使用这种语法修饰方法 func @performanceTiming func() &#123;&#125;&#125; 新的 decorator 语法 @xxx 的形式非常类似 Java Annotation，不过后者作为静态语言，其 Annotation 的实现机制以及使用场景和 ES decorators 都有区别，这是一个题外话。事实上，ES decorators 完全借鉴自 Python 的 decorators。 同时，聪明的你应该发现，相比手写装饰器，新的语法中其实「该写的东西一个都没少」。那这个 decorators 语法有什么意义呢？ 在我看来，这种语法糖对 decorators 的「定义」和「调用」都做了收敛，带来了「形式美感」。说人话，可读性更好。 在 decorators 定义时，约束了装饰器的输入（固定的几个相关参数）和输出（返回一个 function），使所有装饰器风格得到收敛。 在 decorators 调用时，以无侵入的语法「修饰」类或方法，可维护性和可读性都提升很多。 这两个优势，让我想到 ES decorators 的一个重要使用场景，便是应用于构架一致性 API。 构架一致性 API对于多人开发的大型类库来说，「一致性」是很重要同时也很难执行的一个课题。这里的「一致性」包括： 各模块提供一致的标准公用功能。 公用功能的实现和调用方式也保持一致。 整体 API 的风格一致。 其中 1、2 两点可以通过引入 ES decorators 机制来更好地达到。 实践演示先封装好部分 decorators（可参见 @ali/universal-decorator 这个包），这里选取两个装饰器： @deprecated - 用于修饰类的方法，如果方法被调用，则在 console 中提示此方法已经过时，以便开发者转而调用其他方法。 @moduleLevel - 这是 Rax 体系下模块类的一个静态成员标准字段，可取值为几个有限的枚举，此装饰器对此做了约束。 接下来具体地应用到库中。 例如 @ali/universal-tracker 中，report() 方法已经迁移到了 @ali/universal-goldlog，原方法已经废弃，则可以写作： 1234567891011import &#123;deprecated&#125; from '@ali/universal-decorator';class Tracker &#123; @deprecated('This method is moved to universal-goldlog.', &#123; url: 'http://web.npm.alibaba-inc.com/package/@ali/universal-goldlog' &#125;) report() &#123; // ... &#125;&#125; 然后在调用 report() 后则会提示： 这样，在相关的所有库中都引入类似的装饰器，从而保证 API 表达上的一致，并且这些公共逻辑遵循一致的实现。 另外还有一个例子，可以用来对类的字段做约束。以大量基于 Rax 的页面模块为例，这些模块 class 需要声明一个静态属性 moduleLevel 是 app 级别还是 page 级别，以便于框架将其渲染到对应的容器中。但是静态成员的赋值不够清晰明朗，也不能对枚举值做约束。使用 decorators 来改写则： 1234567import &#123;moduleLevel&#125; from '@ali/universal-decorator';@moduleLevel('page')class MyModule1 &#123;&#125;@moduleLevel('other')class MyModule2 &#123;&#125; moduleLevel 这个 decorator 将为类赋上一个名为 moduleLevel 的静态成员，并且会对传入值作判断，如果入参不是 &#39;page&#39; 或 &#39;app&#39;，则发出警告： 最后，由于使用了 ES decorators 语法的代码，类似于一种声明式的标记，所以更利于我们对这些代码作静态分析，比如进一步的提前校验，或是条件编译等等。这部分更多的想法和思路，有待发掘。 引用 Exploring EcmaScript Decorators 题图：一棵被装饰得五光十色的圣诞树。很多涉及到 decorator 的文章动不动就拿圣诞树来举例子，俨然 Christmas tree 是 decorate 的固定宾语。🎄]]></content>
      <categories>
        <category>Web开发</category>
      </categories>
      <tags>
        <tag>decorator</tag>
        <tag>es7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES7 Decorator 装饰者模式「淘宝FED前端团队」]]></title>
    <url>%2Fblog%2F2017-06-02.es7-decorator%2F</url>
    <content type="text"><![CDATA[ES7 Decorator 装饰者模式作者: 玄农 发表于: 2015-11-16 1、装饰模式设计模式大家都有了解，网上有很多系列教程。 这里只分享 装饰者模式 以及如何使用 ES7 的 decorator 概念。 1.1、装饰模式 v.s. 适配器模式装饰模式和适配器模式都是 包装模式 (Wrapper Pattern)，它们都是通过封装其他对象达到设计的目的的，但是它们的形态有很大区别。 适配器模式我们使用的场景比较多，比如连接不同数据库的情况，你需要包装现有的模块接口，从而使之适配数据库 —— 好比你手机使用转接口来适配插座那样； 装饰模式不一样，仅仅包装现有的模块，使之 “更加华丽” ，并不会影响原有接口的功能 —— 好比你给手机添加一个外壳罢了，并不影响手机原有的通话、充电等功能； 更多区别参见：设计模式——装饰模式（Decorator） 1.2、装饰模式场景 —— 面向 AOP 编程装饰模式经典的应用是 AOP 编程，比如“日志系统”，日志系统的作用是记录系统的行为操作，它在不影响原有系统的功能的基础上增加记录环节 —— 好比你佩戴了一个智能手环，并不影响你日常的作息起居，但你现在却有了自己每天的行为记录。 更加抽象的理解，可以理解为给数据流做一层filter，因此 AOP 的典型应用包括 安全检查、缓存、调试、持久化等等。可参考Spring aop 原理及各种应用场景 。 2、使用 ES7 的 decoratorES7 中增加了一个 decorator 属性，它借鉴自 Python，请参考文章Decorators in ES7。 下面我们以 钢铁侠 为例讲解如何使用 ES7 的 decorator。 以钢铁侠为例，钢铁侠本质是一个人，只是“装饰”了很多武器方才变得那么 NB，不过再怎么装饰他还是一个人。 我们的示例场景是这样的 首先创建一个普通的Man类，它的抵御值 2，攻击力为 3，血量为 3； 然后我们让其带上钢铁侠的盔甲，这样他的抵御力增加 100，变成 102； 让其带上光束手套，攻击力增加 50，变成 53； 最后让他增加“飞行”能力 2.1、【Demo 1】对方法的装饰：装备盔甲创建 Man 类： 1234567891011121314151617181920class Man&#123; constructor(def = 2,atk = 3,hp = 3)&#123; this.init(def,atk,hp); &#125; init(def,atk,hp)&#123; this.def = def; // 防御值 this.atk = atk; // 攻击力 this.hp = hp; // 血量 &#125; toString()&#123; return `防御力:$&#123;this.def&#125;,攻击力:$&#123;this.atk&#125;,血量:$&#123;this.hp&#125;`; &#125;&#125;var tony = new Man();console.log(`当前状态 ===&gt; $&#123;tony&#125;`);// 输出：当前状态 ===&gt; 防御力:2,攻击力:3,血量:3 代码直接放在 http://babeljs.io/repl/ 中运行查看结果，记得勾选Experimental选项和Evaluate选项 创建 decorateArmour 方法，为钢铁侠装配盔甲——注意 decorateArmour 是装饰在方法init上的。 1234567891011121314151617181920212223242526272829303132function decorateArmour(target, key, descriptor) &#123; const method = descriptor.value; let moreDef = 100; let ret; descriptor.value = (...args)=&gt;&#123; args[0] += moreDef; ret = method.apply(target, args); return ret; &#125; return descriptor;&#125;class Man&#123; constructor(def = 2,atk = 3,hp = 3)&#123; this.init(def,atk,hp); &#125; @decorateArmour init(def,atk,hp)&#123; this.def = def; // 防御值 this.atk = atk; // 攻击力 this.hp = hp; // 血量 &#125; toString()&#123; return `防御力:$&#123;this.def&#125;,攻击力:$&#123;this.atk&#125;,血量:$&#123;this.hp&#125;`; &#125;&#125;var tony = new Man();console.log(`当前状态 ===&gt; $&#123;tony&#125;`);// 输出：当前状态 ===&gt; 防御力:102,攻击力:3,血量:3 我们先看输出结果，防御力的确增加了 100，看来盔甲起作用了。 初学者这里会有两个疑问： decorateArmour方法的参数为啥是这三个？可以更换么？ decorateArmour方法为什么返回的是descriptor 这里给出个人的解答作为参考： Decorators 的本质是利用了 ES5 的 Object.defineProperty 属性，这三个参数其实是和 Object.defineProperty 参数一致的，因此不能更改，详细分析请见 细说 ES7 JavaScript Decorators 可以看看 bable 转换后 的代码，其中有一句是 descriptor = decorator(target, key, descriptor) || descriptor; ，点到为止，这里不详细展开了，可自行看看这行代码的上下文（参考文献中也涉及到这句代码的解释）。 2.2、【Demo 2】装饰器叠加：增加光束手套在上面的示例中，我们成功为 普通人 增加 “盔甲” 这个装饰；现在我想再给他增加 “光束手套”，希望额外增加 50 点防御值。 Step 1：拷贝一份decorateArmour方法，改名为decorateLight，同时修改防御值的属性： 1234567891011function decorateLight(target, key, descriptor) &#123; const method = descriptor.value; let moreAtk = 50; let ret; descriptor.value = (...args)=&gt;&#123; args[1] += moreAtk; ret = method.apply(target, args); return ret; &#125; return descriptor;&#125; Step 2：直接在init方法上添加装饰语法： 123456789.... @decorateArmour @decorateLight init(def,atk,hp)&#123; this.def = def; // 防御值 this.atk = atk; // 攻击力 this.hp = hp; // 血量 &#125; ... 最后的代码如下： 123456789101112131415161718192021222324252627282930...function decorateLight(target, key, descriptor) &#123; const method = descriptor.value; let moreAtk = 50; let ret; descriptor.value = (...args)=&gt;&#123; args[1] += moreAtk; ret = method.apply(target, args); return ret; &#125; return descriptor;&#125;class Man&#123; constructor(def = 2,atk = 3,hp = 3)&#123; this.init(def,atk,hp); &#125; @decorateArmour @decorateLight init(def,atk,hp)&#123; this.def = def; // 防御值 this.atk = atk; // 攻击力 this.hp = hp; // 血量 &#125;...&#125;var tony = new Man();console.log(`当前状态 ===&gt; $&#123;tony&#125;`);//输出：当前状态 ===&gt; 防御力:102,攻击力:53,血量:3 在这里你就能看出装饰模式的优势了，它可以对某个方法进行叠加使用，对原类的侵入性非常小，只是增加一行@decorateLight而已，可以方便地增删；（同时还可以复用） 2.3、【Demo 3】对类的装饰：增加飞行能力按文章 装饰模式所言，装饰模式有两种：纯粹的装饰模式 和 半透明的装饰模式。 上述的两个 demo 中所使用的应该是 纯粹的装饰模式，它并不增加对原有类的接口；下面要讲 demo 是给普通人增加“飞行”能力，相当于给类新增一个方法，属于 半透明的装饰模式，有点儿像适配器模式的样子。 Step 1：增加一个方法： 1234567891011function addFly(canFly)&#123; return function(target)&#123; target.canFly = canFly; let extra = canFly ? '(技能加成:飞行能力)' : ''; let method = target.prototype.toString; target.prototype.toString = (...args)=&gt;&#123; return method.apply(target.prototype,args) + extra; &#125; return target; &#125;&#125; Step 2：这个方法将直接去装饰类： 12345678910111213141516171819202122232425262728293031323334...// 3function addFly(canFly)&#123; return function(target)&#123; target.canFly = canFly; let extra = canFly ? '(技能加成:飞行能力)' : ''; let method = target.prototype.toString; target.prototype.toString = (...args)=&gt;&#123; return method.apply(target.prototype,args) + extra; &#125; return target; &#125;&#125;@addFly(true)class Man&#123; constructor(def = 2,atk = 3,hp = 3)&#123; this.init(def,atk,hp); &#125; @decorateArmour @decorateLight init(def,atk,hp)&#123; this.def = def; // 防御值 this.atk = atk; // 攻击力 this.hp = hp; // 血量 &#125; ...&#125;...console.log(`当前状态 ===&gt; $&#123;tony&#125;`);// 输出：当前状态 ===&gt; 防御力:102,攻击力:53,血量:3(技能加成:飞行能力) 作用在方法上的 decorator 接收的第一个参数（target ）是类的 prototype；如果把一个decorator 作用到类上，则它的第一个参数 target 是 类本身。（参考 Decorators in ES7） 3、使用原生 JS 实现装饰器模式关于如何用现有标准的原生 JS 实现的装饰模式，可参考译文JavaScript设计模式：装饰者模式，这是一篇值得一读的文章，深入浅出。 这里用 ES5 重写一下上面的 Demo 1的场景，简略说一下关键点： Man 是具体的类，Decorator 是针对 Man 的装饰器基类 具体的装饰类 DecorateArmour 典型地使用 prototype 继承方式 继承自Decorator 基类； 基于 IOC（控制反转）思想 ，Decorator 是接受 Man 类，而不是自己创建 Man类； 最后代码是： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 首先我们要创建一个基类function Man()&#123; this.def = 2; this.atk = 3; this.hp = 3;&#125;// 装饰者也需要实现这些方法，遵守 Man 的接口Man.prototype=&#123; toString:function()&#123; return `防御力:$&#123;this.def&#125;,攻击力:$&#123;this.atk&#125;,血量:$&#123;this.hp&#125;`; &#125;&#125;// 创建装饰器，接收 Man 对象作为参数。var Decorator = function(man)&#123; this.man = man;&#125;// 装饰者要实现这些相同的方法Decorator.prototype.toString = function()&#123; return this.man.toString();&#125;// 继承自装饰器对象// 创建具体的装饰器，也是接收 Man 作对参数var DecorateArmour = function(man)&#123; var moreDef = 100; man.def += moreDef; Decorator.call(this,man);&#125;DecorateArmour.prototype = new Decorator();// 接下来我们要为每一个功能创建一个装饰者对象，重写父级方法，添加我们想要的功能。DecorateArmour.prototype.toString = function()&#123; return this.man.toString();&#125;// 注意这里的调用方式// 构造器相当于“过滤器”，面向切面的var tony = new Man();tony = new DecorateArmour(tony);console.log(`当前状态 ===&gt; $&#123;tony&#125;`);// 输出：当前状态 ===&gt; 防御力:102,攻击力:3,血量:3 4、经典实现：LoggerAOP 的经典应用就是 日志系统 了，那么我们也用 ES7 的语法给钢铁侠打造一个日志系统吧。 下面是最终的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Created by jscon on 15/10/16. */let log = (type) =&gt; &#123; return (target, name, descriptor) =&gt; &#123; const method = descriptor.value; descriptor.value = (...args) =&gt; &#123; console.info(`($&#123;type&#125;) 正在执行: $&#123;name&#125;($&#123;args&#125;) = ?`); let ret; try &#123; ret = method.apply(target, args); console.info(`($&#123;type&#125;) 成功 : $&#123;name&#125;($&#123;args&#125;) =&gt; $&#123;ret&#125;`); &#125; catch (error) &#123; console.error(`($&#123;type&#125;) 失败: $&#123;name&#125;($&#123;args&#125;) =&gt; $&#123;error&#125;`); &#125; return ret; &#125; &#125;&#125;class IronMan &#123; @log('IronMan 自检阶段') check()&#123; return '检查完毕'; &#125; @log('IronMan 攻击阶段') attack()&#123; return '击倒敌人'; &#125; @log('IronMan 机体报错') error()&#123; throw 'Something is wrong!'; &#125;&#125;var tony = new IronMan();tony.check();tony.attack();tony.error();// 输出：// (IronMan 自检阶段) 正在执行: check() = ?// (IronMan 自检阶段) 成功 : check() =&gt; 检查完毕// (IronMan 攻击阶段) 正在执行: attack() = ?// (IronMan 攻击阶段) 成功 : attack() =&gt; 击倒敌人// (IronMan 机体报错) 正在执行: error() = ?// (IronMan 机体报错) 失败: error() =&gt; Something is wrong! Logger 方法的关键在于： 首先使用 const method = descriptor.value; 将原有方法提取出来，保障原有方法的纯净； 在 try..catch 语句是 调用 ret = method.apply(target, args);在调用之前之后分别进行日志汇报； 最后返回 return ret; 原始的调用结果 相信这套思路会给后续我们实现 AOP 模式提供良好的借鉴。 5、扩展：基于工厂模式当你想要一个有 3 种功能的钢铁侠，就得用 new 操作符 创建 4 个对象。这么做单调乏味又烦人，所以我们打算只调用一个方法就能创建出一部拥有所有功能的钢铁侠。 这就需要 工厂模式 了，工厂模式的官方定义是：在子类中对一个类的成员对象进行实例化。比如定义 decorateIronMan（person,feature） 方法，里面接受一个 Person 对象（而不是自己初始化）,相当于流水线生产了。 如何 结合装饰模式和工厂模式 提高代码效能，这篇优秀的译文 JavaScript设计模式：工厂模式 给出了详细的方法，这里不再赘述 ，强烈推荐阅读此文。 6、现在就想用？decorator 目前还只是一个提议，但是感谢 Babel ，我们现在就可以体验它了。首先，安装babel： 1npm install babel -g 然后，开启 decorator： 1babel --optional es7.decorators foo.js &gt; foo.es5.js babel 也提供了一个在线的 REPL ，勾选 experimental 选项，就可以了。 在 webstorm 中设置 babelStep 1 ：首先全局安装babel组件模块 1npm install -g babel Step 2 ：设置 scope （这一步可以省略） 命名 scope： 将文件添加到当前 scope： Step 3 ：设置 ES 版本 Step 4 ：添加 watcher arguments 内可以填写：$FilePathRelativeToProjectRoot$ --stage --out-file $FileNameWithoutExtension$-es5.js $FilePath$ . 如果需要 source-map，需要添加--source-map选项，同时在Output paths to refresh中填写 $FileNameWithoutExtension$-es5.js:$FileNameWithoutExtension$-es5.js.map 更多设置参考babel cli 7、总结虽然它是 ES7 的特性，但在 Babel 大势流行的今天，我们可以利用 Babel 来使用它。我们可以利用 Babel 命令行工具，或者 grunt、gulp、webpack 的 babel 插件来使用 Decorators。 上述的代码都可以直接放在 http://babeljs.io/repl/ 中运行查看结果； 关于 ES7 Decorators 的更有意思的玩法，你可以参见牛人实现的常用的 Decorators：core-decorators。以及 raganwald 的 如何用 Decorators 来实现 Mixin。 参考文献 Decorators in ES7：装饰者模式让你包装已有的方法，从而扩展已有函数。 JavaScript设计模式：装饰者模式：严重推荐，这一系列让你比较透彻明白设计模式在 JS 中的应用。 ES7 之 Decorators 实现 AOP 示例：如何实现一个简单的 AOP。 细说 ES7 JavaScript Decorators：讲解 ES7 Decorator的背后原理，就是使用了 Object.defineProperty 方法； How To Set Up the Babel Plugin in WebStorm：图文并茂，教你如何设置 babel. Rest 参数和参数默认值：ES6 为我们提供一种新的方式来创建可变参数的函数，Rest 参数和参数默认值 Exploring ES2016 Decorators：很完整的一个教程，里面涉及比较全面。 Traits with ES7 Decorators：相当于是介绍 traits-decorator 模块；]]></content>
      <categories>
        <category>Web开发</category>
      </categories>
      <tags>
        <tag>decorator</tag>
        <tag>es7</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从达标到卓越 —— API 设计之道「淘宝FED前端团队」]]></title>
    <url>%2Fblog%2F2017-06-02.from-done-to-better%2F</url>
    <content type="text"><![CDATA[从达标到卓越 —— API 设计之道作者: 法海 发表于: 2017-02-16 新技术层出不穷，长江后浪推前浪，而浪潮褪去后能留下来的，是一些经典的设计思想。 在前端界，以前有远近闻名的 jQuery，近来有声名鹊起的 Vue.js。这两者叫好又叫座的原因固然有很多，但是其中有一个共同特质不可忽视，那便是它们的 API 设计 非常优雅。 因此这次我想来谈个大课题 —— API 设计之道。 讨论内容的定义域本文并不是《jQuery API 赏析》，当我们谈论 API 的设计时，不只局限于讨论「某个框架应该如何设计暴露出来的方法」。作为程序世界分治复杂逻辑的基本协作手段，广义的 API 设计涉及到我们日常开发中的方方面面。 最常见的 API 暴露途径是函数声明（Function Signiture），以及属性字段（Attributes）；而当我们涉及到前后端 IO 时，则需要关注通信接口的数据结构（JSON Schema）；如果还有异步的通信，那么事件（Events）或消息（Message）如何设计也是个问题；甚至，依赖一个包（Package）的时候，包名本身就是接口，你是否也曾碰到过一个奇葩的包名而吐槽半天？ 总之，「API 设计」不只关乎到框架或库的设计者，它和每个开发者息息相关。 提纲挈领有一个核心问题是，我们如何评判一个 API 的设计算「好」？在我看来，一言以蔽之，易用。 那「易用」又是什么呢？我的理解是，只要能够足够接近人类的日常语言和思维，并且不需要引发额外的大脑思考，那就是易用。 Don’t make me think. 具体地，我根据这些年来碰到的大量（反面和正面）案例，归纳出以下这些要点。按照要求从低到高的顺序如下： 达标：词法和语法 正确拼写 准确用词 注意单复数 不要搞错词性 处理缩写 用对时态和语态 进阶：语义和可用性 单一职责 避免副作用 合理设计函数参数 合理运用函数重载 使返回值可预期 固化术语表 遵循一致的 API 风格 卓越：系统性和大局观 版本控制 确保向下兼容 设计扩展机制 控制 API 的抽象级别 收敛 API 集 发散 API 集 制定 API 的支持策略 （本文主要以 JavaScript 作为语言示例。） 达标：词法和语法高级语言和自然语言（英语）其实相差无几，因此正确地使用（英语的）词法和语法是程序员最基本的素养。而涉及到 API 这种供用户调用的代码时，则尤其重要。 但事实上，由于亚洲地区对英语的掌握能力普遍一般……所以现实状况并不乐观 —— 如果以正确使用词法和语法作为达标的门槛，很多 API 都没能达标。 正确拼写正确地拼写一个单词是底线，这一点无需赘述。然而 API 中的各种错别字现象仍屡见不鲜，即使是在我们阿里这样的大公司内。 曾经有某个 JSON 接口（mtop）返回这样一组店铺数据，以在前端模板中渲染： 12345678910// json[ &#123; "shopBottom": &#123; "isTmall": "false", "shopLevel": "916", "shopLeveImg": "//xxx.jpg" &#125; &#125;] 乍一看平淡无奇，结果我调试了小半天都没能渲染出店铺的「店铺等级标识图片」，即shopLevelImg 字段。问题到底出在了哪里？ 眼细的朋友可能已经发现，接口给的字段名是 shopLeveImg，少了一个 l，而在其后字母 I的光辉照耀下，肉眼很难分辨出这个细节问题。 拼错单词的问题真的是太普遍了，再比如： 某个叫做 toast 的库，package.json 中的 name 写成了 taost。导致在 npm 中没能找到这个包。 某个跑马灯组件，工厂方法中的一个属性错将 panel 写成了 pannel。导致以正确的属性名初始化时代码跑不起来。 某个 URL（www.ruanyifeng.com/blog/2017/01/entainment.html）中错将entertainment 写成了 entainment……这倒没什么大影响，只是 URL 发布后就改不了了，留下了错别字不好看。 …… 注意到，这些拼写错误经常出现在 字符串 的场景中。不同于变量名，IDE 无法检查字符串中的单词是否科学、是否和一些变量名一致，因此，我们在对待一些需要公开出去的 API 时，需要尤其注意这方面的问题；另一方面，更认真地注意 IDE 的 typo 提示（单词拼写错误提示），也会对我们产生很大帮助。 准确用词我们知道，中英文单词的含义并非一一对应，有时一个中文意思可以用不同的英文单词来解释，这时我们需要选择使用恰当的准确的词来描述。 比如中文的「消息」可以翻译为 message、notification、news 等。虽然这几个不同的单词都可以有「消息」的意思，但它们在用法和语境场景上存在着细微差异： message：一般指双方通信的消息，是内容载体。而且经常有来有往、成对出现。比如 postMessage() 和 receiveMessage()。 notification：经常用于那种比较短小的通知，现在甚至专指 iOS / Android 那样的通知消息。比如 new NotificationManager()。 news：内容较长的新闻消息，比 notification 更重量级。比如 getTopNews()。 feed：自从 RSS 订阅时代出现的一个单词，现在 RSS 已经日薄西山，但是 feed 这个词被用在了更多的地方。其含义只可意会不可言传。比如 fetchWeitaoFeeds()。 所以，即使中文意思大体相近，也要准确地用词，从而让读者更易理解 API 的作用和 上下文场景。 有一个正面案例，是关于 React 的。（在未使用 ES2015 的）React 中，有两个方法叫做： 12345678React.createClass(&#123; getDefaultProps: function() &#123; // return a dictionary &#125;, getInitialState: function() &#123; // return a dictionary either &#125;&#125;); 它们的作用都是用来定义初始化的组件信息，返回值的类型也都一样，但是在方法名上却分别用了 default 和 initial 来修饰，为什么不统一为一个呢？ 原因和 React 的机制有关： props 是指 Element 的属性，要么是不存在某个属性值后来为它赋值，要么是存在属性的默认值后来将其覆盖。所以这种行为，default 是合理的修饰词。 state 是整个 Component 状态机中的某一个特定状态，既然描述为了状态机，那么状态和状态之间是互相切换的关系。所以对于初始状态，用 initial 来修饰。 就这么个小小的细节，就可一瞥 React 本身的机制，足以体现 API 设计者的智慧。 另外，最近我还碰到了这样一组事件 API： 12345// event name 1page.emit('pageShowModal');// event name 2page.emit('pageCloseModal'); 这两个事件显然是一对正反义的动作，在上述案例中，表示「显示窗口」时使用了 show，表示「关闭窗口」时使用了 close，这都是非常直觉化的直译。而事实上，成对出现的词应该是：show &amp; hide、open &amp; close。 因此这里必须强调：成对出现的正反义词不可混用。在程序世界经常成对出现的词还有： in &amp; out on &amp; off previous &amp; next forward &amp; backward success &amp; failure … 总之，我们可以试着扩充英语的词汇量，使用合适的词，这对我们准确描述 API 有很大的帮助。 注意单复数所有涉及到诸如数组（Array）、集合（Collection）、列表（List）这样的数据结构，在命名时都要使用复数形式： 123456789101112var shopItems = [ // ...];export function getShopItems() &#123; // return an array&#125;// failexport function getShopItem() &#123; // unless you really return a non-array&#125; 现实往往出人意表地糟糕，前不久刚改一个项目，我就碰到了这样的写法： 1234567class MarketFloor extends Component &#123; state = &#123; item: [ &#123;&#125; ] &#125;;&#125; 这里的 item 实为一个数组，即使它内部只有一个成员。因此应该命名为 items 或itemList，无论如何，不应该是表示单数的 item。 同时要注意，在复数的风格上保持一致，要么所有都是 -s，要么所有都是 -list。 反过来，我们在涉及到诸如字典（Dictionary）、表（Map）的时候，不要使用复数！ 123456// failvar EVENT_MAPS = &#123; MODAL_WILL_SHOW: 'modalWillShow', MODAL_WILL_HIDE: 'modalWillHide', // ...&#125;; 虽然这个数据结构看上去由很多 key-value 对组成，是个类似于集合的存在，但是「map」本身已经包含了这层意思，不需要再用复数去修饰它。 不要搞错词性另外一个容易犯的低级错误是搞错词性，即命名时拎不清名词、动词、形容词…… 1234asyncFunc(&#123; success: function() &#123;&#125;, fail: function() &#123;&#125;&#125;); success 算是一个在程序界出镜率很高的词了，但是有些同学会搞混，把它当做动词来用。在上述案例中，成对出现的单词其词性应该保持一致，这里应该写作 succeed 和 fail；当然，在这个语境中，最好遵从惯例，使用名词组合 success 和 failure。 这一对词全部的词性如下： n. 名词：success, failure v. 动词：succeed, fail adj. 形容词：successful, failed（无形容词，以过去分词充当） adv. 副词：successfully, fail to do sth.（无副词，以不定式充当） 注意到，如果有些词没有对应的词性，则考虑变通地采用其他形式来达到同样的意思。 所以，即使我们大部分人都知道：方法命名用动词、属性命名用名词、布尔值类型用形容词（或等价的表语），但由于对某些单词的词性不熟悉，也会导致最终的 API 命名有问题，这样的话就很尴尬了。 处理缩写关于词法最后一个要注意的点是缩写。有时我们经常会纠结，首字母缩写词（acronym）如 DOM、SQL 是用大写还是小写，还是仅首字母大写，在驼峰格式中又该怎么办…… 对于这个问题，简单不易混淆的做法是，首字母缩写词的所有字母均大写。（如果某个语言环境有明确的业界惯例，则遵循惯例。） 12345// beforeexport function getDomNode() &#123;&#125;// afterexport function getDOMNode() &#123;&#125; 在经典前端库 KISSY 的早期版本中，DOM 在 API 中都命名为 dom，驼峰下变为 Dom；而在后面的版本内统一写定为全大写的 DOM。 另外一种缩写的情况是对长单词简写（shortened word），如 btn (button)、chk (checkbox)、tpl (template)。这要视具体的语言规范 / 开发框架规范而定。如果什么都没定，也没业界惯例，那么把单词写全了总是不会错的。 用对时态和语态由于我们在调用 API 时一般类似于「调用一条指令」，所以在语法上，一个函数命名是祈使句式，时态使用一般现在时。 但在某些情况下，我们需要使用其他时态（进行时、过去时、将来时）。比如，当我们涉及到 生命周期、事件节点。 在一些组件系统中，必然涉及到生命周期，我们来看一下 React 的 API 是怎么设计的： 12345export function componentWillMount() &#123;&#125;export function componentDidMount() &#123;&#125;export function componentWillUpdate() &#123;&#125;export function componentDidUpdate() &#123;&#125;export function componentWillUnmount() &#123;&#125; React 划分了几个关键的生命周期节点（mount, update, unmount, …），以将来时和过去时描述这些节点片段，暴露 API。注意到一个小细节，React 采用了 componentDidMount这种过去时风格，而没有使用 componentMounted，从而跟 componentWillMount 形成对照组，方便记忆。 同样地，当我们设计事件 API 时，也要考虑使用合适的时态，特别是希望提供精细的事件切面时。或者，引入 before、after 这样的介词来简化： 12345678// will renderComponent.on('beforeRender', function() &#123;&#125;);// now renderingComponent.on('rendering', function() &#123;&#125;);// has renderedComponent.on('afterRender', function() &#123;&#125;); 另一方面是关于语态，即选用主动语态和被动语态的问题。其实最好的原则就是 尽量避免使用被动语态。因为被动语态看起来会比较绕，不够直观，因此我们要将被动语态的 API 转换为主动语态。 写成代码即形如： 12345// passive voice, make me confusedobject.beDoneSomethingBy(subject);// active voice, much more clear nowsubject.doSomething(object); 进阶：语义和可用性说了那么多词法和语法的注意点，不过才是达标级别而已。确保 API 的可用性和语义才使 API 真正「可用」。 无论是友好的参数设置，还是让人甜蜜蜜的语法糖，都体现了程序员的人文关怀。 单一职责单一职责是软件工程中一条著名的原则，然而知易行难，一是我们对于具体业务逻辑中「职责」的划分可能存在难度，二是部分同学仍没有养成贯彻此原则的习惯。 小到函数级别的 API，大到整个包，保持单一核心的职责都是很重要的一件事。 123456// failcomponent.fetchDataAndRender(url, template);// goodvar data = component.fetchData(url);component.render(data, template); 如上，将混杂在一个大坨函数中的两件独立事情拆分出去，保证函数（function）级别的职责单一。 更进一步地，（假设）fetchData 本身更适合用另一个类（class）来封装，则对原来的组件类 Component 再进行拆分，将不属于它的取数据职责也分离出去： 1234567891011121314class DataManager &#123; fetchData(url) &#123;&#125;&#125;class Component &#123; constructor() &#123; this.dataManager = new DataManager(); &#125; render(data, template) &#123;&#125;&#125;// more code, less responsibilityvar data = component.dataManager.fetchData(url);component.render(data, template); 在文件（file）层面同样如此，一个文件只编写一个类，保证文件的职责单一（当然这对很多语言来说是天然的规则）。 最后，视具体的业务关联度而决定，是否将一簇文件做成一个包（package），或是拆成多个。 避免副作用严格「无 副作用) 的编程」几乎只出现在纯函数式程序中，现实中的 OOP 编程场景难免触及副作用。因此在这里所说的「避免副作用」主要指的是： 函数本身的运行稳定可预期。 函数的运行不对外部环境造成意料外的污染。 对于无副作用的纯函数而言，输入同样的参数，执行后总能得到同样的结果，这种幂等性使得一个函数无论在什么上下文中运行、运行多少次，最后的结果总是可预期的 —— 这让用户非常放心，不用关心函数逻辑的细节、考虑是否应该在某个特定的时机调用、记录调用的次数等等。希望我们以后设计的 API 不会出现这个案例中的情况： 12345// return x.x.x.1 while call it oncethis.context.getSPM();// return x.x.x.2 while call it twicethis.context.getSPM(); 在这里，getSPM() 用来获取每个链接唯一的 SPM 码（SPM 是阿里通用的埋点统计方案）。但是用法却显得诡异：每调用一次，就会返回一个不同的 SPM 串，于是当我们需要获得几个 SPM 时，就会这样写： 123var spm1 = this.context.getSPM();var spm2 = this.context.getSPM();var spm3 = this.context.getSPM(); 虽然在实现上可以理解 —— 此函数内部维护了一个计数器，每次返回一个自增的 SPM D 位，但是 这样的实现方式与这个命名看似是幂等的 getter 型函数完全不匹配，换句话说，这使得这个 API 不可预期。 如何修改之？一种做法是，不改变此函数内部的实现，而是将 API 改为 Generator 式的风格，通过形如 SPMGenerator.next() 接口来获取自增的 SPM 码。 另一种做法是，如果要保留原名称，可以将函数签名改为 getSPM(spmD)，接受一个自定义的 SPM D 位，然后返回整个 SPM 码。这样在调用时也会更明确。 除了函数内部的运行需可预期外，它对外部一旦造成不可预期的污染，那么影响将更大，而且更隐蔽。 对外部造成污染一般是两种途径：一是在函数体内部直接修改外部作用域的变量，甚至全局变量；二是通过修改实参间接影响到外部环境，如果实参是引用类型的数据结构。 曾经也有发生因为对全局变量操作而导致整个容器垮掉的情况，这里就不再展开。 如何防止此类副作用发生？本质上说，需要控制读写权限。比如： 模块沙箱机制，严格限定模块对外部作用域的修改； 对关键成员作访问控制（access control），冻结写权限等等。 合理设计函数参数对一个函数来说，「函数签名」（Function Signature）比函数体本身更重要。函数名、参数设置、返回值类型，这三要素构成了完整的函数签名。而其中，参数设置对用户来说是接触最频繁，也最为关心的部分。 那如何优雅地设计函数的入口参数呢？我的理解是这样几个要点： 优化参数顺序。相关性越高的参数越要前置。 这很好理解，相关性越高的参数越重要，越要在前面出现。其实这还有两个隐含的意思，即可省略的参数后置，以及 为可省略的参数设定缺省值。对某些语言来说（如 C++），调用的时候如果想省略实参，那么一定要为它定义缺省值，而带缺省值的参数必须后置，这是在编译层面就规定死的。而对另一部分灵活的语言来说（如 JS），将可省参数后置同样是最佳实践。 1234567891011// badfunction renderPage(pageIndex, pageData) &#123;&#125;renderPage(0, &#123;&#125;);renderPage(1, &#123;&#125;);// goodfunction renderPage(pageData, pageIndex = 0) &#123;&#125;renderPage(&#123;&#125;);renderPage(&#123;&#125;, 1); 第二个要点是控制参数个数。用户记不住过多的入口参数，因此，参数能省略则省略，或更进一步，合并同类型的参数。 由于可以方便地创建 Object 这种复合数据结构，合并参数的这种做法在 JS 中尤为普遍。常见的情况是将很多配置项都包成一个配置对象： 12345678910// traditional$.ajax(url, params, success);// or$.ajax(&#123; url, params, success, failure&#125;); 这样做的好处是： 用户虽然仍需记住参数名，但不用再关心参数顺序。 不必担心参数列表过长。将参数合并为字典这种结构后，想增加多少参数都可以，也不用关心需要将哪些可省略的参数后置的问题。 当然，凡事有利有弊，由于缺乏顺序，就无法突出哪些是最核心的参数信息；另外，在设定参数的默认值上，会比参数列表的形式更繁琐。因此，需要兼顾地使用最优的办法来设计函数参数，为了同一个目的：易用。 合理运用函数重载谈到 API 的设计，尤其是函数的设计，总离不开一个机制：重载（overload）。 对于强类型语言来说，重载是个很 cool 的功能，能够大幅减少函数名的数量，避免命名空间的污染。然而对于弱类型语言而言，由于不需要在编译时做 type-binding，函数在调用阶段想怎么传实参都行……所以重载在这里变得非常微妙。以下着重谈一下，什么时候该选择重载，什么时候又不该。 12345Element getElementById(String: id)HTMLCollection getElementsByClassName(String: names)HTMLCollection getElementsByTagName(String: name) 以上三个函数是再经典不过的 DOM API，而在当初学习它们的时候（从 Java 思维转到 JS 思维）我就在想这两个问题： 为什么要设计成 getSomethingBySomething 这么复杂结构的名字，而不是使用getSomething 做重载？ 这三个函数只有 getElementById 是单数形式，为何不设计为返回 HTMLCollection（即使只返回一个成员也可以包一个 Collection 嘛），以做成复数形式的函数名从而保持一致性？ 两个问题中，如果第二个问题能解决，那么这三个函数的结构将完全一致，从而可以考虑解决第一个问题。 先来看问题二。稍微深入下 DOM 知识后就知道，id 对于整个 DOM 来说必须是唯一的，因此在理论上 getElementsById（注意有复数）将永远返回仅有 0 或 1 个成员的 Collection，这样一来用户的调用方式将始终是 var element = getElementsById(id)[0]，而这是非常荒谬的。所以 DOM API 设计得没问题。 既然问题二无解，那么自然这三个函数没法做成一个重载。退一步说，即使问题二能解决，还存在另外一个麻烦：它们的入口参数都是一样的，都是 String！对于强类型语言来说，参数类型和顺序、返回值统统一样的情况下，压根无法重载。因为编译器无法通过任何一个有效的特征，来执行不同的逻辑！ 所以，如果入口参数无法进行有效区分，不要选择重载。 当然，有一种奇怪的做法可以绕过去： 123456789101112// failfunction getElementsBy(byWhat, name) &#123; switch(byWhat) &#123; case 'className': // ... case 'tagName': // ... &#125;&#125;getElementsBy('tagName', name);getElementsBy('className', name); 一种在风格上类似重载的，但实际是在运行时走分支逻辑的做法……可以看到，API 的信息总量并没降低。不过话不能说死，这种风格在某些特定场景也有用武之地，只是多数情况下并不推荐。 与上述风格类似的，是这样一种做法： 12345// get elements by tag-name by defaultHTMLCollection getElements(String: name)// if you add a flag, it goes by class-nameHTMLCollection getElements(String: name, Boolean: byClassName) 「将 flag 标记位作为了重载手段」—— 在早期微软的一些 API 中经常能见到这样的写法，可以说一旦离开了文档就无法编码，根本不明白某个 Boolean 标记位是用来干嘛的，这大大降低了用户的开发体验，以及代码可读性。 这样看起来，可重载的场景真是太少了！也不尽然，在我看来有一种场景很适合用重载：批量处理。 123Module handleModules(Module: module)Collection&lt;Module&gt; handleModules(Collection&lt;Module&gt;: modules) 当用户经常面临处理一个或多个不确定数量的对象时，他可能需要思考和判断，什么时候用单数 handleModule、什么时候用复数 handleModules。将这种类型的操作重载为一个（大抵见于 setter 型操作），同时支持单个和批量的处理，可以降低用户的认知负担。 所以，在合适的时机重载，否则宁愿选择「函数名结构相同的多个函数」。原则是一样的，保证逻辑正确的前提下，尽可能降低用户负担。 对了，关于 getElements 那三个 API，它们最终的进化版本回到了同一个函数：querySelector(selectors)。 使返回值可预期函数的易用性体现在两方面：入口和出口。上面已经讲述了足够多关于入口的设计事项，这一节讲出口：函数返回值。 对于 getter 型的函数来说，调用的直接目的就是为了获得返回值。因此我们要让返回值的类型和函数名的期望保持一致。 12345678// expect 'a.b.c.d'function getSPMInString() &#123; // fail return &#123; a, b, c, d &#125;;&#125; 从这一点上来讲，要慎用 ES2015 中的新特性「解构赋值」。 而对于 setter 型的函数，调用的期望是它能执行一系列的指令，然后去达到一些副作用，比如存文件、改写变量值等等。因此绝大多数情况我们都选择了返回 undefined / void —— 这并不总是最好的选择。 回想一下，我们在调用操作系统的命令时，系统总会返回「exit code」，这让我们能够获知系统命令的执行结果如何，而不必通过其他手段去验证「这个操作到底生效了没」。因此，创建这样一种返回值风格，或可一定程度增加健壮性。 另外一个选项，是让 setter 型 API 始终返回 this。这是 jQuery 为我们带来的经典启示 —— 通过返回 this，来产生一种「链式调用（chaining）」的风格，简化代码并且增加可读性： 1234$('div') .attr('foo', 'bar') .data('hello', 'world') .on('click', function() &#123;&#125;); 最后还有一个异类，就是异步执行的函数。由于异步的特性，对于这种需要一定延时才能得到的返回值，只能使用 callback 来继续操作。使用 Promise 来包装它们尤为必要。对异步操作都返回一个 Promise，使整体的 API 风格更可预期。 固化术语表在前面的词法部分中曾经提到「准确用词」，但即使我们已经尽量去用恰当的词，在有些情况下仍然不免碰到一些难以抉择的尴尬场景。 比如，我们经常会看到 pic 和 image、path 和 url 混用的情况，这两组词的意思非常接近（当然严格来说 path 和 url 的意义是明确不同的，在此暂且忽略），稍不留神就会产生 4 种组合…… picUrl picPath imageUrl imagePath 更糟糕的情况是 imgUrl、picUri、picURL…… 所以，在一开始就要 产出术语表，包括对缩写词的大小写如何处理、是否有自定义的缩写词等等。一个术语表可以形如： 标准术语 含义 禁用的非标准词 pic 图片 image, picture path 路径 URL, url, uri on 绑定事件 bind, addEventListener off 解绑事件 unbind, removeEventListener emit 触发事件 fire, trigger module 模块 mod 不仅在公开的 API 中要遵守术语表规范，在局部变量甚至字符串中都最好按照术语表来。 1234page.emit('pageRenderRow', &#123; index: this.props.index, modList: moduleList&#125;); 比如这个我最近碰到的案例，同时写作了 modList 和 moduleList，这就有点怪怪的。 另外，对于一些创造出来的、业务特色的词汇，如果不能用英语简明地翻译，就直接用拼音： 淘宝 Taobao 微淘 Weitao 极有家 Jiyoujia …… 在这里，千万不要把「微淘」翻译为 MicroTaobao……当然，专有词已经有英文名的除外，如 Tmall。 遵循一致的 API 风格这一节算得上是一个复习章节。词法、语法、语义中的很多节都指向同一个要点：一致性。 一致性可以最大程度降低信息熵。 好吧，这句话不是什么名人名言，就是我现编的。总而言之，一致性能大大降低用户的学习成本，并对 API 产生准确的预期。 在词法上，提炼术语表，全局保持一致的用词，避免出现不同的但是含义相近的词。 在语法上，遵循统一的语法结构（主谓宾顺序、主被动语态），避免天马行空的造句。 在语义上，合理运用函数的重载，提供可预期的甚至一致类型的函数入口和出口。 甚至还可以一致得更细节些，只是举些例子： 打 log 要么都用中文，要么都用英文。 异步接口要么都用回调，要么都改成 Promise。 事件机制只能选择其一：object.onDoSomething = func 或 object.on(&#39;doSomething&#39;, func)。 所有的 setter 操作必须返回 this。 …… 一份代码写得再怎么烂，把某个单词都拼成一样的错误，也好过这个单词只出现一次错误。 是的，一致性，再怎么强调都不为过。 卓越：系统性和大局观不管是大到发布至业界，或小到在公司内跨部门使用，一组 API 一旦公开，整体上就是一个产品，而调用方就是用户。所谓牵一发而动全身，一个小细节可能影响整个产品的面貌，一个小改动也可能引发整个产品崩坏。因此，我们一定要站在全局的层面，甚至考虑整个技术环境，系统性地把握整个体系内 API 的设计，体现大局观。 版本控制80% 的项目开发在版本控制方面做得都很糟糕：随心所欲的版本命名、空洞诡异的提交信息、毫无规划的功能更新……人们显然需要一段时间来培养规范化开发的风度，但是至少得先保证一件事情： 在大版本号不变的情况下，API 保证向前兼容。 这里说的「大版本号」即「语义化版本命名」&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt; 中的第一位 &lt;major&gt;位。 这一位的改动表明 API 整体有大的改动，很可能不兼容，因此用户对大版本的依赖改动会慎之又慎；反之，如果 API 有不兼容的改动，意味着必须修改大版本号，否则用户很容易出现在例行更新依赖后整个系统跑不起来的情况，更糟糕的情况则是引发线上故障。 如果这种情况得不到改善，用户们就会选择 永远不升级依赖，导致更多的潜在问题。久而久之，最终他们便会弃用这些产品（库、中间件、whatever）。 所以，希望 API 的提供者们以后不会再将大版本锁定为 0。更多关于「语义化版本」的内容，请参考我的另一篇文章《论版本号的正确打开方式》。 确保向下兼容如果不希望对客户造成更新升级方面的困扰，我们首先要做好的就是确保 API 向下兼容。 API 发生改动，要么是需要提供新的功能，要么是为之前的糟糕设计买单……具体来说，改动无外乎：增加、删除、修改 三方面。 首先是删除。不要轻易删除公开发布的 API，无论之前写得多么糟糕。如果一定要删除，那么确保正确使用了「Deprecated」： 对于某个不想保留的可怜 API，先不要直接删除，将其标记为 @deprecated 后置入下一个小版本升级（比如从 1.0.2 到 1.1.0）。 123456789/*** @deprecated*/export function youWantToRemove(foo, bar) &#123;&#125;/*** This is the replacement.*/export function youWantToKeep(foo) &#123;&#125; 并且，在 changelog 中明确指出这些 API 即将移除（不推荐使用，但是目前仍然能用）。 之后，在下一个 大版本 中（比如 1.1.0 到 2.0.0）删除标记为 @deprecated 的部分，同时在 changelog 中指明它们已删除。 其次是 API 的修改。如果我们仅仅是修复 bug、重构实现、或者添加一些小特性，那自然没什么可说的；但是如果想彻底修改一个 API……比如重做入口参数、改写业务逻辑等等，建议的做法是： 确保原来的 API 符合「单一职责」原则，如果不是则修改之。 增加一个全新的 API 去实现新的需求！由于我们的 API 都遵循「单一职责」，因此一旦需要彻底修改 API，意味着新需求和原来的职责已经完全无法匹配，不如干脆新增一个 API。 视具体情况选择保留或移除旧 API，进入前面所述「删除 API」的流程。 最后是新增 API。事实上，即使是只加代码不删代码，整体也不一定是向下兼容的。有一个经典的正面案例是： 12345// modern browsersdocument.hidden == false;// out-of-date browsersdocument.hidden == undefined; 浏览器新增的一个 API，用以标记「当前文档是否可见」。直观的设计应该是新增document.visible 这样的属性名……问题是，在逻辑上，文档默认是可见的，即document.visible 默认为 true，而不支持此新属性的旧浏览器返回 document.visible == undefined，是个 falsy 值。因此，如果用户在代码中简单地以： 123if (document.visible) &#123; // do some stuff&#125; 做特征检测的话，在旧浏览器中就会进入错误的条件分支……而反之，以 document.hiddenAPI 来判断，则是向下兼容的。 设计扩展机制毫无疑问，在保证向下兼容的同时，API 需要有一个对应的扩展机制以可持续发展 —— 一方面便于开发者自身增加功能，另一方面用户也能参与进来共建生态。 技术上来说，接口的扩展方式有很多，比如：继承（extend）、组合（mixin）、装饰（decorate）……选择没有对错，因为不同的扩展方式适用于不同的场景：在逻辑上确实存在派生关系，并且需要沿用基类行为同时自定义行为的，采用重量级的继承；仅仅是扩充一些行为功能，但是逻辑上压根不存在父子关系的，使用组合；而装饰手法更多应用于给定一个接口，将其包装成多种适用于不同场景新接口的情况…… 另一方面，对于不同的编程语言来说，由于不同的语言特性……静态、动态等，各自更适合用某几种扩展方式。所以，到底采用什么扩展办法，还是得视情况而定。 在 JS 界，有一些经典的技术产品，它们的扩展甚至已经形成生态，如： jQuery。耳熟能详的 $.fn.customMethod = function() {};。这种简单的 mixin 做法已经为 jQuery 提供了成千上万的插件，而 jQuery 自己的大部分 API 本身也是基于这个写法构建起来的。 React。React 自身已经处理了所有有关组件实例化、生命周期、渲染和更新等繁琐的事项，只要开发者基于 React.Component 来继承出一个组件类。对于一个 component system 来说，这是一个经典的做法。 Gulp。相比于近两年的大热 Webpack，个人认为 Gulp 更能体现一个 building system 的逻辑 —— 定义各种各样的「任务」，然后用「管道」将它们串起来。一个 Gulp 插件也是那么的纯粹，接受文件流，返回文件流，如是而已。 Koa。对于主流的 HTTP Server 来说，中间件的设计大同小异：接受上一个 request，返回一个新的 response。而对天生 Promise 化的 Koa 来说，它的中间件风格更接近于 Gulp 了，区别仅在于一个是 file stream，一个是 HTTP stream。 不只是庞大的框架需要考虑扩展性，设计可扩展的 API 应该变成一种基本的思维方式。比如这个活生生的业务例子： 12345678910111213141516171819202122232425// json[ &#123; "type": "item", "otherAttrs": "foo" &#125;, &#123; "type": "shop", "otherAttrs": "bar" &#125;]// render logicswitch(feed.type) &#123; case 'item': console.log('render in item-style.'); break; case 'shop': console.log('render in shop-style.'); break; case 'other': default: console.log('render in other styles, maybe banner or sth.'); break;&#125; 根据不同的类型渲染一组 feeds 信息：商品模块、店铺模块，或是其他。某天新增了需求说要支持渲染天猫的店铺模块（多显示个天猫标等等），于是 JSON 接口直接新增一个type = &#39;tmallShop&#39; —— 这种接口改法很简单直观，但是并不好。在不改前端代码的情况下，tmallShop 类型默认进入 default 分支，导致奇奇怪怪的渲染结果。 考虑到 tmallShop 和 shop 之间是一个继承的关系，tmallShop 完全可以当一个普通的 shop来用，执行后者的所有逻辑。用 Java 的表达方式来说就是： 123// a tmallShop is a shopShop tmallShop = new TmallShop();tmallShop.doSomeShopStuff(); 将这个逻辑关系反映到 JSON 接口中，合理的做法是新增一个 subType 字段，用来标记tmallShop，而它的 type 仍然保持为 shop。这样一来，即使原来的前端代码完全不修改，仍然可以正常运行，除了无法渲染出一些天猫店铺的特征。 这里还有一个非常类似的正面案例，是 ABS 搭建系统（淘宝 FED 出品的站点搭建系统）设计的模块 JSON Schema： 12345678910// json[ &#123; "type": "string", "format": "enum" &#125;, &#123; "type": "string", "format": "URL" &#125;] 同样采用了 type 为主类型，而扩展字段在这里变成了 format，用来容纳一些扩展特性。在实际开发中，的确也很方便新增各种新的数据结构逻辑。 控制 API 的抽象级别API 能扩展的前提是什么？是接口足够抽象。这样才能够加上各种具体的定语、装饰更多功能。用日常语言举个例子： 123456789// abstractI want to go to a place.// when&#123;Today, Tomorrow, Jan. 1st&#125; I want to go to a place.// whereI want to go to &#123;mall, cafe, bed&#125;.// concrete, no extends any moreToday I want to go to a cafe for my business. 所以，在设计 API 时要高抽象，不要陷入具体的实现，不要陷入具体的需求，要高屋建瓴。 看个实际的案例：一个类 React Native 的页面框架想暴露出一个事件「滚动到第二屏」，以便页面开发者能监听这个事件，从而更好地控制页面资源的加载策略（比如首屏默认加载渲染、到第二屏之后再去加载剩下的资源）。 但是因为一些实现上的原因，页面框架还不能通过页面位移（offset）来精确地通知「滚动到了第二屏」，而只能判断「第二屏的第一个模块出现了」。于是这个事件没有被设计为secondScreenReached，而变成了 secondScreenFirstModuleAppear……虽然secondScreenFirstModuleAppear 不能精确定义 secondScreenReached，但是直接暴露这个具体的 API 实在太糟糕了，问题在于： 用户在依赖一个非常非常具体的 API，给用户造成了额外的信息负担。「第二屏的第一个模块出现了！」这很怪异，用户根本不关心模块的事情，用户关心的只是他是否到达了第二屏。 一旦页面框架能够真正通过页面位移来实现「滚动到第二屏」，如果我们暴露的是高抽象的 secondScreenReached，那么只需要更改一下这个接口的具体实现即可；反之，我们暴露的是很具体的 secondScreenFirstModuleAppear，就只能挨个通知用户：「你现在可以不用依赖这个事件了，改成我们新出的 secondScreenReached 吧！」 是的，抽象级别一般来说越高越好，将 API 设计成业务无关的，更通用，而且方便扩展。但是物极必反，对于像我这样的抽象控来说，最好能学会控制接口的抽象级别，将其保持在一个恰到好处的层次上，不要做无休止的抽象。 还是刚才的例子 secondScreenReached，我们还可以将其抽象成 targetScreenReached，可以支持到达首屏、到达第二屏、第三屏……的事件，这样是不是更灵活、更优雅呢？并没有 —— 抽象时一定要考虑到具体的业务需求场景，有些实现路径如果永远不可能走到，就没必要抽出来。比如这个例子中，没有人会去关心第三屏、第四屏的事件。 太高的抽象容易造成太多的层次，带来额外的耦合、通信等不同层次之间的沟通成本，这将会成为新的麻烦。对用户而言，也是额外的信息负担。 对于特定的业务来说，接口越抽象越通用，而越具体则越能解决特定问题。所以，思考清楚，API 面向的场景范围，避免懒惰设计，避免过度设计。 收敛 API 集对于一整个体系的 API 来说，用户面对的是这个整体集合，而不是其中某几个单一的 API。我们要保证集合内的 API 都在一致的抽象维度上，并且适当地合并 API，减小整个集合的信息量，酌情做减法。 产品开始做减法，便是对用户的温柔。 收敛近似意义的参数和局部变量。下面这样的一组 API 好像没什么不对，但是对强迫症来说一定产生了不祥的直觉： 12345export function selectTab(index) &#123;&#125;export function highlightTab(tabIndex) &#123;&#125;export function gotoPage(index) &#123;&#125; 又是 index 又是 tabIndex 的，或许还会有 pageIndex？诚然，函数形参和局部变量的命名对最终用户来说没有直接影响，但是这些不一致的写法仍然能反映到 API 文档中，并且，对开发者自身也会产生混淆。所以，选一个固定的命名风格，然后从一而终！如果忘了的话，回头看一下前文「固化术语表」这一节吧！ 收敛近似职责的函数。对用户暴露出太多的接口不是好事，但是一旦要合并不同的函数，是否就会破坏「单一职责」原则呢？ 不，因为「单一职责」本身也要看具体的抽象层次。以下这个例子和前文「合理运用函数重载」中的例子有相似之处，但具体又有所不同。 12345678910111213141516171819202122// a complex rendering processfunction renderPage() &#123; // too many APIs here renderHeader(); renderBody(); renderSidebar(); renderFooter();&#125;// now mergedfunction renderPage() &#123; renderSections([ 'header', 'body', 'sidebar', 'footer' ]);&#125;// call renderSectionfunction renderSections(sections) &#123;&#125;// and the real laborfunction renderSection(section) &#123;&#125; 类似于这样，避免暴露过多近似的 API，合理利用抽象将其合并，减小对用户的压力。 对于一个有清晰继承树的场景来说，收敛 API 显得更加自然且意义重大 —— 利用多态性（Polymorphism）构建 Consistent APIs。（以下例子来源于 Clean Code JS。） 12345678910111213// bad: type-checking herefunction travelToTexas(vehicle) &#123; if (vehicle instanceof Bicycle) &#123; vehicle.pedal(this.currentLocation, new Location('texas')); &#125; else if (vehicle instanceof Car) &#123; vehicle.drive(this.currentLocation, new Location('texas')); &#125;&#125;// coolfunction travelToTexas(vehicle) &#123; vehicle.move(this.currentLocation, new Location('texas'));&#125; 有一个将 API 收敛到极致的家伙恐怕大家都不会陌生：jQuery 的 $()。这个风格不正是 jQuery 当年的杀手级特性之一吗？ 如果 $() 能让我搞定这件事，就不要再给我 foo() 和 bar()。 收敛近似功能的包。再往上一级，我们甚至可以合并相近的 package。 淘宝 FED 的 Rax 体系（类 RN 框架）中，有基础的组件标签，如 &lt;Image&gt; (in @ali/rax-components)、&lt;Link&gt; (in @ali/rax-components)，也有一些增强功能的 package，如&lt;Picture&gt; (in @ali/rax-picture)、&lt;Link&gt; (in @ali/rax-spmlink)。 在这里，后者包之于前者相当于装饰了更多功能，是前者的增强版。而在实际应用中，也是推荐使用诸如 &lt;Picture&gt; 而禁止使用 &lt;Image&gt;。那么在这种大环境下，&lt;Image&gt; 等基础 API 的暴露就反而变得很扰民。可以考虑将增强包的功能完全合并入基础组件，即将 &lt;Picture&gt;并入 &lt;Image&gt;，用户只需面对单一的、标准的组件 API。 发散 API 集这听上去很荒谬，为什么一个 API 集合又要收敛又要发散？仅仅是为了大纲上的对称性吗？ 当然不是。存在这个小节是因为我有一个不得不提的案例，不适合放在其他段落，只能放在这里……不，言归正传，我们有时的确需要发散 API 集，提供几个看似接近的 API，以引导用户。因为 —— 虽然这听起来很荒谬 —— 某些情况下，API 其实不够用，但是用户 没有意识到 API 不够用，而是选择了混用、滥用。看下面这个例子： 123456789101112131415// the func is used hererequestAnimationFrame(() =&gt; &#123; // what? trigger an event? emitter.emit('moduleDidRenderRow');&#125;);// ...and thererequestAnimationFrame(() =&gt; &#123; // another one here, I guess rendering? this.setState(&#123; // ... &#125;);&#125;); 在重构一组代码时，我看到代码里充斥着 requestAnimationFrame()，这是一个比较新的全局 API，它会以接近 60 FPS 的速率延时执行一个传入的函数，类似于一个针对特定场景优化过的 setTimeout()，但它的初衷是用来绘制动画帧的，而不应该用在奇奇怪怪的场景中。 在深入地了解了代码逻辑之后，我认识到这里如此调用是为了「延时一丢丢执行一些操作」，避免阻塞主渲染线程。然而这种情况下，还不如直接调用 setTimeout() 来做延时操作。虽然没有太明确的语义，但是至少好过把自己伪装成一次动画的绘制。更可怕的是，据我所知 requestAnimationFrame() 的滥用不仅出现在这次重构的代码中，我至少在三个不同的库见过它的身影 —— 无一例外地，这些库和动画并没有什么关系。 （一个可能的推断是，调用 requestAnimationFrame(callback) 时不用指定 timeout 毫秒数，而 setTimeout(callback, timeout) 是需要的。似乎对很多用户来说，前者的调用方式更 cool？） 所以，在市面上有一些 API 好像是「偏方」一般的存在：虽然不知道为什么要这么用，但是……用它就对了！ 事实上，对于上面这个场景，最恰当的解法是使用一个更加新的 API，叫做requestIdleCallback(callback)。这个 API 从名字上看起来就很有语义：在线程空闲的时候再执行操作。这完全契合上述场景的需求，而且还自带底层的优化。 当然，由于 API 比较新，还不是所有的平台都能支持。即便如此，我们也可以先面向接口编程，自己做一个 polyfill： 1234// simple polyfillexport function requestIdleCallback(callback) =&gt; &#123; callback &amp;&amp; setTimeout(callback, 1e3 / 60);&#125;; 另一个经典的滥用例子是 ES2015 中的「Generator / yield」。 原本使用场景非常有限的生成器 Generator 机制被大神匠心独运地加以改造，包装成用来异步代码同步化的解决方案。这种做法自然很有创意，但是从语义用法上来说实在不足称道，让代码变得非常难读，并且带来维护隐患。与其如此，还不如仅仅使用 Promise。 令人欣慰的是，随后新版的 ES 即提出了新的异步代码关键字「async / await」，真正在语法层面解决了异步代码同步化的问题，并且，新版的 Node.js 也已经支持这种语法。 因此，我们作为 API 的开发者，一定要提供足够场景适用的 API，来引导我们的用户，不要让他们做出一些出人意料的「妙用」之举。 制定 API 的支持策略我们说，一组公开的 API 是产品。而产品，一定有特定的用户群，或是全球的开发者，或仅仅是跨部门的同事；产品同时有保质期，或者说，生命周期。 面向目标用户群体，我们要制定 API 的支持策略： 每一个大版本的支持周期是多久。 是否有长期稳定的 API 支持版本。（Long-term Support） 如何从旧版本升级。 老旧版本很可能还在运行，但维护者已经没时间精力再去管这些历史遗物，这时明确地指出某些版本不再维护，对开发者和用户都好。当然，同时别忘了给出升级文档，指导老用户如何迁移到新版本。还有一个更好的做法是，在我们开启一个新版本之际，就确定好上一个版本的寿命终点，提前知会到用户。 还有一个技术上的注意事项，那就是：大版本间最好有明确的隔离。对于一个复杂的技术产品来说，API 只是最终直接面向用户的接口，背后还有特定的环境、工具组、依赖包等各种支撑，互相之间并不能混用。 比如，曾经的经典前端库 KISSY。在业界技术方案日新月异的大潮下，KISSY 6 版本已经强依赖了 TNPM（阿里内网的 NPM）、DEF 套件组（淘宝 FED 的前端工具套件），虽然和之前的 1.4 版本相比 API 的变化并不大，但是仍然不能在老环境下直接使用 6 版本的代码库……这一定程度上降低了自由组合的灵活度，但事实上随着业务问题场景的复杂度提升，解决方案本身会需要更定制化，因此，将环境、工具等上下游关联物随代码一起打包，做成一整个技术方案，这正是业界的现状。 所以，隔离大版本，制定好 API 支持策略，让我们的产品更专业，让用户免去后顾之忧。 总结以上，便是我从业以来感悟到的一些「道」，三个进阶层次、几十个细分要点，不知有没有给读者您带来一丁点启发。 但实际上，大道至简。我一直认为，程序开发和平时的说话写字其实没有太大区别，无非三者 —— 逻辑和抽象。 领域知识。 语感。 写代码，就像写作，而设计 API 好比列提纲。勤写、勤思，了解前人的模式、套路，学习一些流行库的设计方法，掌握英语、提高语感……相信大家都能设计出卓越的 API。 最后，附上 API 设计的经典原则： Think about future, design with flexibility, but only implement for production. 引用 Framework Design Guidelines.aspx) Page Visibility 的 API 设计 我心目中的优秀 API Clean Code JavaScript 题图：只是一张符合上下文的图片，并没有更深的含义。 花絮：由于文章很长，在编写过程中我也不由得发生了「同一个意思却使用多种表达方式」的情况。某些时候这是必要的 —— 可以丰富文字的多样性；而有些时候，则显得全文缺乏一致性。在发表本文之前，我搜索了这些词语：「调用者」、「调用方」、「引用者」、「使用者」，然后将它们统一修改为我们熟悉的名字：「用户」。]]></content>
      <categories>
        <category>Web开发</category>
      </categories>
      <tags>
        <tag>API设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS in JS 简介 「阮一峰」]]></title>
    <url>%2Fblog%2F2017-06-02.CSS-in-JS-brief%2F</url>
    <content type="text"><![CDATA[CSS in JS 简介作者： 阮一峰 日期： 2017年4月 5日 1、 以前，网页开发有一个原则，叫做“关注点分离”（separation of concerns）。 它的意思是，各种技术只负责自己的领域，不要混合在一起，形成耦合。对于网页开发来说，主要是三种技术分离。 HTML 语言：负责网页的结构，又称语义层 CSS 语言：负责网页的样式，又称视觉层 JavaScript 语言：负责网页的逻辑和交互，又称逻辑层或交互层 简单说，就是一句话，不要写”行内样式”（inline style）和”行内脚本”（inline script）。比如，下面代码就很糟糕（查看完整代码）。 12345&gt; &lt;h1 style="color:red;font-size:46px;" onclick="alert('Hi')"&gt;&gt; Hello World&gt; &lt;/h1&gt;&gt;&gt; 2、 React 出现以后，这个原则不再适用了。因为，React 是组件结构，强制要求把 HTML、CSS、JavaScript 写在一起。 上面的例子使用 React 改写如下（查看完整代码）。 123456789101112131415&gt; const style = &#123;&gt; 'color': 'red',&gt; 'fontSize': '46px'&gt; &#125;;&gt;&gt; const clickHandler = () =&gt; alert('hi');&gt;&gt; ReactDOM.render(&gt; &lt;h1 style=&#123;style&#125; onclick=&#123;clickHandler&#125;&gt;&gt; Hello, world!&gt; &lt;/h1&gt;,&gt; document.getElementById('example')&gt; );&gt;&gt; 上面代码在一个文件里面，封装了结构、样式和逻辑，完全违背了”关注点分离”的原则，很多人不适应。 但是，这有利于组件的隔离。每个组件包含了所有需要用到的代码，不依赖外部，组件之间没有耦合，很方便复用。所以，随着 React 的走红和组件模式深入人心，这种”关注点混合”的新写法逐渐成为主流。 3、 表面上，React 的写法是 HTML、CSS、JavaScript 混合在一起。但是，实际上不是。现在其实是用 JavaScript 在写 HTML 和 CSS。 React 在 JavaScript 里面实现了对 HTML 和 CSS 的封装，我们通过封装去操作 HTML 和 CSS。也就是说，网页的结构和样式都通过 JavaScript 操作。 4、 React 对 HTML 的封装是 JSX 语言 ，这个在各种 React 教程都有详细介绍，本文不再涉及了，下面来看 React 对 CSS 的封装。 React 对 CSS 封装非常简单，就是沿用了 DOM 的 style 属性对象，这个在前面已经看到过了。 123456&gt; const style = &#123;&gt; 'color': 'red',&gt; 'fontSize': '46px'&gt; &#125;;&gt;&gt; 上面代码中，CSS 的font-size属性要写成fontSize，这是 JavaScript 操作 CSS 属性的约定。 由于 CSS 的封装非常弱，导致了一系列的第三方库，用来加强 React 的 CSS 操作。它们统称为 CSS in JS，意思就是使用 JS 语言写 CSS。根据不完全统计，各种 CSS in JS 的库至少有47种。老实说，现在也看不出来，哪一个库会变成主流。 你可能会问，它们与”CSS 预处理器”（比如 Less 和 Sass，包括 PostCSS）有什么区别？回答是 CSS in JS 使用 JavaScript 的语法，是 JavaScript 脚本的一部分，不用从头学习一套专用的 API，也不会多一道编译步骤。 5、 上周，我看到一个新的 CSS in JS 库，叫做 polished.js。它将一些常用的 CSS 属性封装成函数，用起来非常方便，充分体现使用 JavaScript 语言写 CSS 的优势。 我觉得这个库很值得推荐，这篇文章的主要目的，就是想从这个库来看怎么使用 CSS in JS。 首先，加载 polished.js。 123&gt; const polished = require('polished');&gt;&gt; 如果是浏览器，插入下面的脚本。 1234&gt; &lt;script src="https://unpkg.com/polished@1.0.0/dist/polished.min.js"&gt;&gt; &lt;/script&gt;&gt;&gt; polished.js目前有50多个方法，比如clearfix方法用来清理浮动。 12345&gt; const styles = &#123;&gt; ...polished.clearFix(),&gt; &#125;;&gt;&gt; 上面代码中，clearFix就是一个普通的 JavaScript 函数，返回一个对象。 12345678910&gt; polished.clearFix()&gt; // &#123;&gt; // &amp;::after: &#123;&gt; // clear: "both",&gt; // content: "",&gt; // display: "table"&gt; // &#125;&gt; // &#125;&gt;&gt; “展开运算符”（...）将clearFix返回的对象展开，便于与其他 CSS 属性混合。然后，将样式对象赋给 React 组件的style属性，这个组件就能清理浮动了。 123456&gt; ReactDOM.render(&gt; &lt;h1 style=&#123;style&#125;&gt;Hello, React!&lt;/h1&gt;,&gt; document.getElementById('example')&gt; );&gt;&gt; 从这个例子，大家应该能够体会polished.js的用法。 6、 下面再看几个很有用的函数。 ellipsis将超过指定长度的文本，使用省略号替代（查看完整代码）。 123456789101112131415&gt; const styles = &#123;&gt; ...polished.ellipsis('200px')&gt; &#125;&gt;&gt; // 返回值&gt; // &#123;&gt; // 'display': 'inline-block',&gt; // 'max-width': '250px',&gt; // 'overflow': 'hidden',&gt; // 'text-overflow': 'ellipsis',&gt; // 'white-space': 'nowrap',&gt; // 'word-wrap': 'normal'&gt; // &#125;&gt;&gt; hideText用于隐藏文本，显示图片。 1234567891011121314&gt; const styles = &#123;&gt; 'background-image': 'url(logo.png)',&gt; ...polished.hideText(),&gt; &#125;;&gt;&gt; // 返回值&gt; // &#123;&gt; 'background-image': 'url(logo.png)',&gt; 'text-indent': '101%',&gt; 'overflow': 'hidden',&gt; 'white-space': 'nowrap',&gt; &#125;&gt;&gt; hiDPI指定高分屏样式。 12345678910111213141516&gt; const styles = &#123;&gt; [polished.hiDPI(1.5)]: &#123;&gt; width: '200px',&gt; &#125;&gt; &#125;;&gt;&gt; // 返回值&gt; //'@media only screen and (-webkit-min-device-pixel-ratio: 1.5),&gt; // only screen and (min--moz-device-pixel-ratio: 1.5),&gt; // only screen and (-o-min-device-pixel-ratio: 1.5/1),&gt; // only screen and (min-resolution: 144dpi),&gt; // only screen and (min-resolution: 1.5dppx)': &#123;&gt; // 'width': '200px',&gt; //&#125;&gt;&gt; retinaImage为高分屏和低分屏设置不同的背景图。 123456789101112131415&gt; const styles = &#123;&gt; ...polished.retinaImage('my-img')&gt; &#125;;&gt;&gt; // 返回值&gt; // backgroundImage: 'url(my-img.png)',&gt; // '@media only screen and (-webkit-min-device-pixel-ratio: 1.3),&gt; // only screen and (min--moz-device-pixel-ratio: 1.3),&gt; // only screen and (-o-min-device-pixel-ratio: 1.3/1),&gt; // only screen and (min-resolution: 144dpi),&gt; // only screen and (min-resolution: 1.5dppx)': &#123;&gt; // backgroundImage: 'url(my-img_2x.png)',&gt; // &#125;&gt;&gt; 7、 polished.js提供的其他方法如下，详细用法请参考文档。 normalize()：样式表初始化 placeholder()：对 placeholder 伪元素设置样式 selection()：对 selection 伪元素设置样式 darken()：调节颜色深浅 lighten()：调节颜色深浅 desaturate()：降低颜色的饱和度 saturate()：增加颜色的饱和度 opacify()：调节透明度 complement()：返回互补色 grayscale()：将一个颜色转为灰度 rgb()：指定红、绿、蓝三个值，返回一个颜色 rgba()：指定红、绿、蓝和透明度四个值，返回一个颜色 hsl()：指定色调、饱和度和亮度三个值，返回一个颜色 hsla()：指定色调、饱和度、亮度和透明度三个值，返回一个颜色 mix()：混合两种颜色 em()：将像素转为 em rem()：将像素转为 rem 目前，polished.js只是1.0版，以后应该会有越来越多的方法。 8、 polished.js还有一个特色：所有函数默认都是柯里化的，因此可以进行函数组合运算，定制出自己想要的函数。 123456&gt; import &#123; compose &#125; from 'ramda';&gt; import &#123; lighten, desaturate &#125; from 'polished';&gt;&gt; const tone = compose(lighten(10), desaturate(10))&gt;&gt; 上面代码使用 Ramda 函数库完成组合运算。Ramda 的用法可以参考我写的教程。 （正文完）]]></content>
      <categories>
        <category>Web开发</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typora – 终于有一款优美的 Markdown 编辑器[Win/macOS]]]></title>
    <url>%2Fblog%2F2017-06-02.md-best-offline-client%2F</url>
    <content type="text"><![CDATA[0x00 偶然间的邂逅今天偶然间看到了 Typora ， 看了下他的文档， 很好的符合我的要求， 配合 Hexo 使用， 简直完美。下面是 appinn 的评价： 青小蛙 on 2016.07.16. Typora 是一款 Markdown 编辑器，拥有 Windows、macOS 客户端，可以算作一款 Windows 下难得的好看、优美的客户端。@Appinn 0x01 需求对于 md ， 图片一直是个痛点， 看到 Typora 可以支持 Paste images from clipboard , 立刻两眼放光，稍加验证， 完全可以满足需求 。 而且 ， 提供了一些人性化的 快捷键，可以更优雅的编写 md 文件了 :) 。 而且 可以直接在 渲染后的效果进行书写，这个效果很棒。这是一种其他编辑器都没有的体验。 0x02 粘贴图片的配置 官方文档 in English Images in Typora 如果要达到 从 clipboard 粘贴图片的效果， Typora 要求提供图片的存放路径， 这里稍有不足的地方是 – 需要针对每个文件都进行调整。 操作步骤 Paste images from clipboard Since Markdown file is only plain text file, users could not insert image data into Markdown file directly, but can insert image reference to file/url. Typora support paste image data from clipboard, after telling typora where to put those images. Typora would put image data into given folder or server, then insert images referring to that stored file or url One common scenario is to edit *.md posts in static sites (like Jekyll) using Typora. For example, if the .*md file is put under _posts folder while the image files goes into _media folder, you may want to copy images files into folder _media when you drag/drop or paste images into Markdown file automatically. Here’s how: Save your file into some path. (md 文件必须被保存后) Enable Editor → Image Insert → Allow copy images to given folder in preferences panel. Select Edit → Image Tools → When Insert Local Images → Copy Image File to Folder from menubar, pick the target folder. In step 3, a new item typora-copy-images-to: {relative path} will be inserted into the YAML Front Matter block of current document. So you could also manually add typora-copy-images-to property in YAML Front Matter to enable this behaviour. 在 step 3 中，会在文件中添加 YAML 信息， 类似如下效果： 1234---typora-copy-images-to: &lt;path&gt;typora-root-url: &lt;path&gt;--- After that, if you drag &amp; drop local images or paste images into Typora, the image file will be copied into the target file and update related src. 这样操作完成后， 不管是 拖拽 还是 粘贴， 图片都会 被拷贝到 target 目录， 并更新相关的 image 的相对地址。 结合 Hexo 使用参考 之前的文章 在 hexo 中无痛使用本地图片 确保 按 2.1 中的配置好后， 做如下修改，以后就可以基本不用考虑 图片的痛点了： 修改 scaffolds 下面的 post.md 和 draft.md ， 添加如下 YAML ： 12typora-copy-images-to: &#123;&#123; title &#125;&#125;typora-root-url: &#123;&#123; title &#125;&#125; 以后用 hexo new &lt;post&gt; 方式生成的文件，就可以直接贴图片了，这里稍微要注意的地方是： 因为 hexo-asset-image会忽略 以/开头的图片，所以要手动的把 ![123](/123.jpg) 路径中的 /去掉。]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 Hexo 中无痛使用本地图片]]></title>
    <url>%2Fblog%2F2017-06-01.no-pains-with-hexo-local-image%2F</url>
    <content type="text"><![CDATA[原文：http://www.tuicool.com/articles/umEBVfIhttp://codefalling.com/2015/12/19/no-pains-with-hexo-local-image/ 已失效 1 起因在 hexo 中使用本地图片是件非常让人纠结的事情，在 markdown 里的图片地址似乎永远无法和最后生成的网页保持一致。 这些问题使得我一度不愿意使用本地图片而选择用图床，但被移动运营商无耻的横条广告逼得打算上 https，图床只支持 http 就成了问题。 hexo 下插入图片现在大概有几个方案 1.1 放在根目录早期大部分的方案是把图片放在 source/img下，然后在 markdown 里写 ![img](/source/img/img.png)。显然这样在本地的编辑器里完全不能正确识别图片的位置。 1.2 asset-image在 hexo 2.x 时出现的插件，后来被吸纳进 hexo 3 core，用法的介绍见 资源文件夹 | Hexo。比较尴尬的是，这种方法直接放弃了 markdown 原来的语法，使用类似 ``的语法，。markdown 本来有插入图片的语法不好好支持，专门用一个新的语法来插入本地图片，让我这种强迫症不太能接受。 2 解决方案CodeFalling/hexo-asset-image 2.1使用首先确认 _config.yml中有 post_asset_folder:true。 在 hexo 目录，执行 1234npm install https://github.com/CodeFalling/hexo-asset-image --save# 在 pull request merged 之前使用下面的npm install https://github.com/yafey/hexo-asset-image --save 假设在 12345MacGesture2-Publish├── apppicker.jpg├── logo.jpg└── rules.jpgMacGesture2-Publish.md 这样的目录结构（目录名和文章名一致），只要使用 ![logo](MacGesture2-Publish/logo.jpg)就可以插入图片。 生成的结构为 12345public/2015/10/18/MacGesture2-Publish├── apppicker.jpg├── index.html├── logo.jpg└── rules.jpg 同时，生成的 html 是 1&lt;img src="/HexoBlog/2015/10/18/MacGesture2-Publish/logo.jpg" alt="logo"&gt; 而不是愚蠢的 1&lt;img src="MacGesture2-Publish/logo.jpg" alt="logo"&gt; 值得一提的是，这个插件对于( yafey 注：我现在还不知道这货是干嘛用的 –&gt; ) CodeFalling/hexo-renderer-org 同样有效。 2.1.1 兼容性问题？在本地使用过程中发现，在 使用了 hexo-asset-image 之后， 如果更新了文件， 预览的时候 文件就无法正常显示， 一定要 重新 hexo g ， 然后 hexo s -p 80 才能预览， 这个估计值得 enhance ， 可以去 提个 issue 。 2.2 第一次 raise a pull request to an open source project因为我的 Hexo 现在是放在 xxx.github.io/HexoBlog 上的， hexo-asset-image 生成的 link 原先是 不带 HexoBlog 的，竟然被我稀里糊涂的改掉了， 那就 raise pull request 给 作者吧， 这算是我第一次给 open source 提 pull request ， 以后也可以说是 给 open source 做过贡献了 :) 。 pull request 链接 ： https://github.com/CodeFalling/hexo-asset-image/pull/25/files]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nvm or N]]></title>
    <url>%2Fblog%2F2017-06-01.node-version-control-nvm-or-n%2F</url>
    <content type="text"><![CDATA[如何选择 nvm 还是 n ? 管理 node 版本，选择 nvm 还是 n？@「淘宝前端团队(FED)」 nvm 和 n 的差异还是比较大的，具体体现在： 安装简易度。nvm 安装起来显然是要麻烦不少；n 这种安装方式更符合 node 的惯性思维。见仁见智吧。 系统支持。注意， nvm 不支持 Windows n 不支持 windows。 对全局模块的管理。n 对全局模块毫无作为，因此有可能在切换了 node 版本后发生全局模块执行出错的问题；nvm 的全局模块存在于各自版本的沙箱中，切换版本后需要重新安装，不同版本间也不存在任何冲突。 关于 node 路径。n 是万年不变的 /usr/local/bin；nvm 需要手动指定路径。 所以，如何选择？真心见仁见智了，不过这里可以给出大体的建议： 如果你使用 Windows，那没得选了，使用 n，或者换一台 Mac。 如果你会频繁切换 node 版本（比如本地经常测试最新版的特性，同时又要兼顾代码在生产环境的兼容性），那么从全局模块兼容性的角度考虑，只能使用 nvm。 如果你是一个轻量级的用户，不需要担心兼容性的问题，更关心 node 安装和使用上的体验，那么选择 n。 你如果要问，楼主最终选用了谁？我会说，我选择了更流行的那一个。 升级node.js和npm [注] 参考：https://segmentfault.com/a/1190000009025883 n 模块不支持windows系统，官方文档(Unfortunately n is not supported on Windows yet. If you’re able to make it work, send in a pull request!) 一行命令搞定npm和node.js的升级，省去了重新编译和安装的过程。具体如下： 升级node.jsnpm中有一个模块叫做 “n”，专门用来管理node.js版本的。 更新到最新的稳定版只需要在命令行中打下如下代码： 12345# 第一步，安装 n (n 模块不支持 windows 系统)npm install -g n# 第二步，升级 node 到最新稳定版本n stable 如需最新版本则用n latest 当然，n后面也可以跟具体的版本号：n v6.2.0 或 n 6.2.0 node.js升级就是这么简单。 升级npmnpm升级就更简单了，只需要在终端中输入： 1npm -g install npm@next 补充常用 npm 命令 参考 ： https://segmentfault.com/a/1190000006869650 1234567891011121314151617$ npm -v #显示版本，检查npm 是否正确安装。 $ npm install express #安装express模块 $ npm install -g express #全局安装express模块 $ npm list #列出已安装模块 $ npm show express #显示模块详情 $ npm update #升级当前目录下的项目的所有模块 $ npm update express #升级当前目录下的项目的指定模块 $ npm update -g express #升级全局安装的express模块 $ npm uninstall express #删除指定的模块 Windows 强行安装 n 模块（然并软） 参考 ： http://blog.csdn.net/u013474104/article/details/52197772 123456789101112131415PS C:\Users\yafey&gt; npm install -g nnpm ERR! Windows_NT 10.0.14393npm ERR! argv "C:\\_installed_soft\\nodejs\\node.exe" "C:\\_installed_soft\\nodejs\\node_modules\\npm\\bin\\npm-cli.js" "install" "-g" "n"npm ERR! node v6.9.2npm ERR! npm v3.10.9npm ERR! code EBADPLATFORMnpm ERR! notsup Unsupported platform for n@2.1.7: wanted &#123;"os":"!win32","arch":"any"&#125; (current: &#123;"os":"win32","arch":"x64"&#125;)npm ERR! notsup Valid OS: !win32npm ERR! notsup Valid Arch: anynpm ERR! notsup Actual OS: win32npm ERR! notsup Actual Arch: x64npm ERR! Please include the following file with any support request:npm ERR! C:\Users\yafey\npm-debug.log 解决方案在后面加上 --force 即可。 1npm install -g n --force 然并软该报错 还是 继续报错。 1234PS C:\Users\yafey&gt; n stable/bin/bash: C:\Users\yafey\AppData\Roaming\npm\node_modules\n\bin\n: No such file or directoryPS C:\Users\yafey&gt; n v4.4.7/bin/bash: C:\Users\yafey\AppData\Roaming\npm\node_modules\n\bin\n: No such file or directory]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git_clone_include_submodule]]></title>
    <url>%2Fblog%2F2017-06-01.git-clone-include-submodule%2F</url>
    <content type="text"><![CDATA[git clone 指定分支，并 register and update submodulesIf your submodule was added in a branch be sure to include it in your clone command…1git clone -b &lt;branch_name&gt; --recursive &lt;remote&gt; &lt;directory&gt; If --recursive is specified, this command will recurse into the registered submodules, and update any nested submodules within. 参考： How to `git clone` including submodules?]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>submodule</tag>
        <tag>clone</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tools]]></title>
    <url>%2Fblog%2F2017-05-31.tools%2F</url>
    <content type="text"><![CDATA[Web tool.oschina Bootcss 前端开发资源导航 Linux explainshell Miscellaneous (杂项) Youtube downloader 伪射手字幕 谷粉搜搜-谷歌替代品 【c#版】我为开源做贡献，网页正文提取——Html2Article 【php版】如何将CSDN的文章转成.md的markdown文件 玩转Google: 我有特殊的使用方式 我的时间管理与方法论 GitPage 上的镜像React 【推荐】胡子大哈的 《React 小书》 | 自己github镜像 ES6 《ES6 标准入门》（第二版）出版了 by 阮一峰 | 自己github镜像 《JavaScript 闯关记》本课程之所以叫做《JavaScript 闯关记》，是因为部分章节精心设计了挑战关卡，通过提供更多的实战机会，让大家可以循序渐进地、有目的地、有挑战地开展学习。 博客 github | github forked 参考自 ： http://www.zipperary.com/tools/ 临时链接 ： bk.html]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fblog%2F2017-05-28.hello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>new to Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Doc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HelloHexo Test]]></title>
    <url>%2Fblog%2F2017-05-28.HelloHexo-Test%2F</url>
    <content type="text"><![CDATA[测试 1Git submodules: Specify a branch/taghttps://stackoverflow.com/questions/1777854/git-submodules-specify-a-branch-tagumläute refines dtmland’s command with a simplified version in the comments:1git submodule foreach -q --recursive 'git checkout $(git config -f $toplevel/.gitmodules submodule.$name.branch || echo master)' multiple lines:123git submodule foreach -q --recursive \ 'git checkout \ $(git config -f $toplevel/.gitmodules submodule.$name.branch || echo master)' GETTING GIT SUBMODULE TO TRACK A BRANCH (add submodule 的步骤)https://www.activestate.com/blog/2014/05/getting-git-submodule-track-branch 删除 submodule : git rm --cached &lt;mysubmodule&gt; add submodule : git submodule add --force -b BUAT &lt;git url&gt; &lt;submodule path&gt; Add a submodule which can’t be removed from the indexhttps://stackoverflow.com/questions/12218420/add-a-submodule-which-cant-be-removed-from-the-index If the output adding a new submodule is: 12345678 #'FolderName' already exists in the index # Tip the next commandsgit ls-files --stage # The output will be something similar to:160000 d023657a21c1bf05d0eeaac6218eb5cca8520d16 0 FolderName # Then, to remove the folder index tip:git rm -r --cached FolderName #Try again add the submodule]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>
<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[39个必知必会的SQL 性能调优方法]]></title>
    <url>%2Fblog%2F2017-06-08.39-tips-about-SQL-optimize%2F</url>
    <content type="text"><![CDATA[转自 ：https://mp.weixin.qq.com/s/jSYyXiE-kNoE9jpZ4kAEhw http://www.cnblogs.com/llrr/p/6655977.html 我们要做到不但会写SQL,还要做到写出性能优良的SQL,以下为笔者学习、摘录、并汇总部分资料与大家分享！ 1、选择最有效率的表名顺序(只在基于规则的优化器中有效)ORACLE 的解析器按照从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表(基础表 driving table)将被最先处理，在FROM子句中包含多个表的情况下,你必须选择记录条数最少的表作为基础表。如果有3个以上的表连接查询, 那就需要选择交叉表(intersection table)作为基础表, 交叉表是指那个被其他表所引用的表. 2、WHERE子句中的连接顺序ORACLE采用自下而上的顺序解析WHERE子句,根据这个原理,表之间的连接必须写在其他WHERE条件之前, 那些可以过滤掉最大数量记录的条件必须写在WHERE子句的末尾. 3、SELECT子句中避免使用 ‘ * ‘ORACLE在解析的过程中, 会将’*’ 依次转换成所有的列名, 这个工作是通过查询数据字典完成的, 这意味着将耗费更多的时间 4、减少访问数据库的次数ORACLE在内部执行了许多工作: 解析SQL语句, 估算索引的利用率, 绑定变量 , 读数据块等； 5、在SQL*Plus , SQLForms和ProC中重新设置ARRAYSIZE参数, 可以增加每次数据库访问的检索数据量 ,建议值为2006、使用DECODE函数来减少处理时间使用DECODE函数可以避免重复扫描相同记录或重复连接相同的表. 7、整合简单,无关联的数据库访问如果你有几个简单的数据库查询语句,你可以把它们整合到一个查询中(即使它们之间没有关系) 8、删除重复记录最高效的删除重复记录方法 ( 因为使用了ROWID)例子： DELETE FROM EMP E WHERE E.ROWID &gt; (SELECT MIN(X.ROWID) FROM EMP X WHERE X.EMP_NO = E.EMP_NO); 9、用TRUNCATE替代DELETE当删除表中的记录时,在通常情况下, 回滚段(rollback segments ) 用来存放可以被恢复的信息. 如果你没有COMMIT事务,ORACLE会将数据恢复到删除之前的状态(准确地说是恢复到执行删除命令之前的状况) 而当运用TRUNCATE时, 回滚段不再存放任何可被恢复的信息.当命令运行后,数据不能被恢复.因此很少的资源被调用,执行时间也会很短. (译者按: TRUNCATE只在删除全表适用,TRUNCATE是DDL不是DML) 10、尽量多使用COMMIT只要有可能,在程序中尽量多使用COMMIT, 这样程序的性能得到提高,需求也会因为COMMIT所释放的资源而减少: COMMIT所释放的资源： a. 回滚段上用于恢复数据的信息. b. 被程序语句获得的锁 c. redo log buffer 中的空间 d. ORACLE为管理上述3种资源中的内部花费 11、用Where子句替换HAVING子句避免使用HAVING子句, HAVING 只会在检索出所有记录之后才对结果集进行过滤. 这个处理需要排序,总计等操作. 如果能通过WHERE子句限制记录的数目,那就能减少这方面的开销. (非oracle中)on、where、having这三个都可以加条件的子句中，on是最先执行，where次之，having最后，因为on是先把不 符合条件的记录过滤后才进行统计，它就可以减少中间运算要处理的数据，按理说应该速度是最快的，where也应该比having快点的，因为它过滤数据后 才进行sum，在两个表联接时才用on的，所以在一个表的时候，就剩下where跟having比较了。在这单表查询统计的情况下，如果要过滤的条件没有涉及到要计算字段，那它们的结果是一样的，只是where可以使用rushmore技术，而having就不能，在速度上后者要慢如果要涉及到计算的字 段，就表示在没计算之前，这个字段的值是不确定的，根据上篇写的工作流程，where的作用时间是在计算之前就完成的，而having就是在计算后才起作 用的，所以在这种情况下，两者的结果会不同。在多表联接查询时，on比where更早起作用。系统首先根据各个表之间的联接条件，把多个表合成一个临时表 后，再由where进行过滤，然后再计算，计算完后再由having进行过滤。由此可见，要想过滤条件起到正确的作用，首先要明白这个条件应该在什么时候起作用，然后再决定放在那里 12、 减少对表的查询在含有子查询的SQL语句中,要特别注意减少对表的查询.例子： 123SELECT TAB_NAME FROM TABLES WHERE (TAB_NAME,DB_VER) = ( SELECTTAB_NAME,DB_VER FROM TAB_COLUMNS WHERE VERSION = 604) 13、通过内部函数提高SQL效率复杂的SQL往往牺牲了执行效率. 能够掌握上面的运用函数解决问题的方法在实际工作中是非常有意义的 14、使用表的别名(Alias)当在SQL语句中连接多个表时, 请使用表的别名并把别名前缀于每个Column上.这样一来,就可以减少解析的时间并减少那些由Column歧义引起的语法错误. 15、 用EXISTS替代IN、用NOT EXISTS替代NOT IN在许多基于基础表的查询中,为了满足一个条件,往往需要对另一个表进行联接.在这种情况下, 使用EXISTS(或NOT EXISTS)通常将提高查询的效率. 在子查询中,NOT IN子句将执行一个内部的排序和合并. 无论在哪种情况下,NOT IN都是最低效的(因为它对子查询中的表执行了一个全表遍历). 为了避免使用NOT IN ,我们可以把它改写成外连接(Outer Joins)或NOT EXISTS. 例子： 1234567高效：SELECT * FROM EMP (基础表) WHERE EMPNO &gt; 0 AND EXISTS (SELECT ‘X' FROM DEPT WHERE DEPT.DEPTNO = EMP.DEPTNO AND LOC = ‘MELB')低效：SELECT * FROM EMP (基础表) WHERE EMPNO &gt; 0 AND DEPTNO IN(SELECT DEPTNO FROM DEPT WHERE LOC = ‘MELB') 16、识别’低效执行’的SQL语句虽然目前各种关于SQL优化的图形化工具层出不穷,但是写出自己的SQL工具来解决问题始终是一个最好的方法： 1234567891011121314151617SELECT EXECUTIONS , DISK_READS, BUFFER_GETS,ROUND((BUFFER_GETS-DISK_READS)/BUFFER_GETS,2) Hit_radio,ROUND(DISK_READS/EXECUTIONS,2) Reads_per_run,SQL_TEXTFROM V$SQLAREAWHERE EXECUTIONS&gt;0AND BUFFER_GETS &gt; 0AND (BUFFER_GETS-DISK_READS)/BUFFER_GETS &lt; 0.8ORDER BY 4 DESC; 17、用索引提高效率索引是表的一个概念部分,用来提高检索数据的效率，ORACLE使用了一个复杂的自平衡B-tree结构. 通常,通过索引查询数据比全表扫描要快. 当ORACLE找出执行查询和Update语句的最佳路径时, ORACLE优化器将使用索引. 同样在联结多个表时使用索引也可以提高效率. 另一个使用索引的好处是,它提供了主键(primary key)的唯一性验证.。那些LONG或LONG RAW数据类型, 你可以索引几乎所有的列. 通常, 在大型表中使用索引特别有效. 当然,你也会发现, 在扫描小表时,使用索引同样能提高效率. 虽然使用索引能得到查询效率的提高,但是我们也必须注意到它的代价. 索引需要空间来存储,也需要定期维护, 每当有记录在表中增减或索引列被修改时, 索引本身也会被修改. 这意味着每条记录的INSERT , DELETE , UPDATE将为此多付出4 , 5 次的磁盘I/O . 因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢.。定期的重构索引是有必要的.： 1ALTER INDEX &lt;INDEXNAME&gt; REBUILD &lt;TABLESPACENAME&gt; 18、用EXISTS替换DISTINCT当提交一个包含一对多表信息(比如部门表和雇员表)的查询时,避免在SELECT子句中使用DISTINCT. 一般可以考虑用EXIST替换, EXISTS 使查询更为迅速,因为RDBMS核心模块将在子查询的条件一旦满足后,立刻返回结果. 例子： 1234567891011低效：SELECT DISTINCT DEPT_NO,DEPT_NAME FROM DEPT D , EMP EWHERE D.DEPT_NO = E.DEPT_NO高效：SELECT DEPT_NO,DEPT_NAME FROM DEPT D WHERE EXISTS ( SELECT ‘X'FROM EMP E WHERE E.DEPT_NO = D.DEPT_NO); 19、sql语句用大写的；因为oracle总是先解析sql语句，把小写的字母转换成大写的再执行20、在java代码中尽量少用连接符“＋”连接字符串！21、避免在索引列上使用NOT 通常我们要避免在索引列上使用NOT, NOT会产生在和在索引列上使用函数相同的影响. 当ORACLE”遇到”NOT,他就会停止使用索引转而执行全表扫描. 22、避免在索引列上使用计算WHERE子句中，如果索引列是函数的一部分．优化器将不使用索引而使用全表扫描． 举例: 1234567低效：SELECT … FROM DEPT WHERE SAL * 12 &gt; 25000;高效:SELECT … FROM DEPT WHERE SAL &gt; 25000/12; 23、用&gt;=替代&gt;1234567高效:SELECT * FROM EMP WHERE DEPTNO &gt;=4低效:SELECT * FROM EMP WHERE DEPTNO &gt;3 两者的区别在于, 前者DBMS将直接跳到第一个DEPT等于4的记录而后者将首先定位到DEPTNO=3的记录并且向前扫描到第一个DEPT大于3的记录. 24、用UNION替换OR (适用于索引列)通常情况下, 用UNION替换WHERE子句中的OR将会起到较好的效果. 对索引列使用OR将造成全表扫描. 注意, 以上规则只针对多个索引列有效. 如果有column没有被索引, 查询效率可能会因为你没有选择OR而降低. 在下面的例子中, LOC_ID 和REGION上都建有索引. 1234567891011121314151617181920212223高效:SELECT LOC_ID , LOC_DESC , REGIONFROM LOCATIONWHERE LOC_ID = 10UNIONSELECT LOC_ID , LOC_DESC , REGIONFROM LOCATIONWHERE REGION = “MELBOURNE”低效：SELECT LOC_ID , LOC_DESC , REGIONFROM LOCATIONWHERE LOC_ID = 10 OR REGION = “MELBOURNE” 如果你坚持要用OR, 那就需要返回记录最少的索引列写在最前面. 25、用IN来替换OR 这是一条简单易记的规则，但是实际的执行效果还须检验，在ORACLE8i下，两者的执行路径似乎是相同的． 1234567低效:SELECT…. FROM LOCATION WHERE LOC_ID = 10 OR LOC_ID = 20 OR LOC_ID = 30高效SELECT… FROM LOCATION WHERE LOC_IN IN (10,20,30); 26、避免在索引列上使用IS NULL和IS NOT NULL避免在索引中使用任何可以为空的列，ORACLE将无法使用该索引．对于单列索引，如果列包含空值，索引中将不存在此记录. 对于复合索引，如果每个列都为空，索引中同样不存在此记录. 如果至少有一个列不为空，则记录存在于索引中．举例: 如果唯一性索引建立在表的A列和B列上, 并且表中存在一条记录的A,B值为(123,null) , ORACLE将不接受下一条具有相同A,B值（123,null）的记录(插入). 然而如果所有的索引列都为空，ORACLE将认为整个键值为空而空不等于空. 因此你可以插入1000 条具有相同键值的记录,当然它们都是空! 因为空值不存在于索引列中,所以WHERE子句中对索引列进行空值比较将使ORACLE停用该索引. 1234567低效: (索引失效)SELECT … FROM DEPARTMENT WHERE DEPT_CODE IS NOT NULL;高效: (索引有效)SELECT … FROM DEPARTMENT WHERE DEPT_CODE &gt;=0; 27、 总是使用索引的第一个列如果索引是建立在多个列上, 只有在它的第一个列(leading column)被where子句引用时,优化器才会选择使用该索引. 这也是一条简单而重要的规则，当仅引用索引的第二个列时,优化器使用了全表扫描而忽略了索引 28、用UNION-ALL 替换UNION ( 如果有可能的话)当SQL 语句需要UNION两个查询结果集合时,这两个结果集合会以UNION-ALL的方式被合并, 然后在输出最终结果前进行排序. 如果用UNION ALL替代UNION, 这样排序就不是必要了. 效率就会因此得到提高. 需要注意的是，UNION ALL 将重复输出两个结果集合中相同记录. 因此各位还是要从业务需求分析使用UNION ALL的可行性. UNION 将对结果集合排序,这个操作会使用到SORT_AREA_SIZE这块内存. 对于这块内存的优化也是相当重要的. 下面的SQL可以用来查询排序的消耗量 12345678910111213141516171819202122232425262728293031低效：SELECT ACCT_NUM, BALANCE_AMTFROM DEBIT_TRANSACTIONSWHERE TRAN_DATE = '31-DEC-95'UNIONSELECT ACCT_NUM, BALANCE_AMTFROM DEBIT_TRANSACTIONSWHERE TRAN_DATE = '31-DEC-95'高效:SELECT ACCT_NUM, BALANCE_AMTFROM DEBIT_TRANSACTIONSWHERE TRAN_DATE = '31-DEC-95'UNION ALLSELECT ACCT_NUM, BALANCE_AMTFROM DEBIT_TRANSACTIONSWHERE TRAN_DATE = '31-DEC-95' 29、用WHERE替代ORDER BY：ORDER BY 子句只在两种严格的条件下使用索引. ORDER BY中所有的列必须包含在相同的索引中并保持在索引中的排列顺序. ORDER BY中所有的列必须定义为非空. WHERE子句使用的索引和ORDER BY子句中所使用的索引不能并列. 例如: 表DEPT包含以下列: DEPT_CODE PK NOT NULL DEPT_DESC NOT NULL DEPT_TYPE NULL 1234567低效: (索引不被使用)SELECT DEPT_CODE FROM DEPT ORDER BY DEPT_TYPE高效: (使用索引)SELECT DEPT_CODE FROM DEPT WHERE DEPT_TYPE &gt; 0 30、避免改变索引列的类型当比较不同数**据类型的数据时, ORACLE自动对列进行简单的类型转换. 假设 EMPNO是一个数值类型的索引列. 1SELECT … FROM EMP WHERE EMPNO = ‘123' 实际上,经过ORACLE类型转换, 语句转化为: 1SELECT … FROM EMP WHERE EMPNO = TO_NUMBER(‘123') 幸运的是,类型转换没有发生在索引列上,索引的用途没有被改变. 现在,假设EMP_TYPE是一个字符类型的索引列. 1SELECT … FROM EMP WHERE EMP_TYPE = 123 这个语句被ORACLE转换为: 1SELECT … FROM EMP WHERETO_NUMBER(EMP_TYPE)=123 因为内部发生的类型转换, 这个索引将不会被用到! 为了避免ORACLE对你的SQL进行隐式的类型转换, 最好把类型转换用显式表现出来. 注意当字符和数值比较时, ORACLE会优先转换数值类型到字符类型 31、需要当心的WHERE子句某些SELECT 语句中的WHERE子句不使用索引. 这里有一些例子. 在下面的例子里, (1)‘!=’ 将不使用索引. 记住, 索引只能告诉你什么存在于表中, 而不能告诉你什么不存在于表中. (2) ‘ | |’是字符连接函数. 就象其他函数那样, 停用了索引. (3) ‘+’是数学函数. 就象其他数学函数那样, 停用了索引. (4)相同的索引列不能互相比较,这将会启用全表扫描. 32、a. 如果检索数据量超过30%的表中记录数.使用索引将没有显著的效率提高b. 在特定情况下, 使用索引也许会比全表扫描慢, 但这是同一个数量级上的区别. 而通常情况下,使用索引比全表扫描要块几倍乃至几千倍! 33、避免使用耗费资源的操作带有DISTINCT,UNION,MINUS,INTERSECT,ORDER BY的SQL语句会启动SQL引擎 执行耗费资源的排序(SORT)功能. DISTINCT需要一次排序操作, 而其他的至少需要执行两次排序. 通常, 带有UNION, MINUS , INTERSECT的SQL语句都可以用其他方式重写. 如果你的数据库的SORT_AREA_SIZE调配得好, 使用UNION , MINUS, INTERSECT也是可以考虑的, 毕竟它们的可读性很强 34、优化GROUP BY提高GROUP BY 语句的效率, 可以通过将不需要的记录在GROUP BY 之前过滤掉.下面两个查询返回相同结果但第二个明显就快了许多. 1234567891011121314151617181920212223低效:SELECT JOB , AVG(SAL)FROM EMPGROUP by JOBHAVING JOB = ‘PRESIDENT'OR JOB = ‘MANAGER'高效:SELECT JOB , AVG(SAL)FROM EMPWHERE JOB = ‘PRESIDENT'OR JOB = ‘MANAGER'GROUP by JOB 35、Select Count (*)和Select Count(1) 区别一般情况下，Select Count (*)和Select Count(1)两着返回结果是一样的 假如表沒有主键(Primary key), 那么count(1)比count(*)快， 如果有主键的話，那主键作为count的条件时候count(主键)最快 如果你的表只有一个字段的话那count(*)就是最快的 count(*) 跟 count(1) 的结果一样，都包括对NULL的统计，而count(column) 是不包括NULL的统计 selelct 常量 from … 对应所有行，返回的永远只有一个值，即常量 。所以正常只会用来判断是否有还是没有（比如exists子句）。而select * from … 是返回所有行的所有列。 性能上的差异，关键看你的from和where子句。比如说如果你的where条件中可以通过索引，那显然 select 1 from … 的性能比 select * from … 好。 select count(*)返回所有满足条件的记录数，此时同select sum(1) 但是sum()可以传任意数字，负数、浮点数都可以，返回的值是传入值n*满足条件记录数m 36、IS NULL 与 IS NOT NULL不能用null作索引，任何包含null值的列都将不会被包含在索引中。即使索引有多列这样的情况下，只要这些列中有一列含有null，该列就会从索引中排除。也就是说如果某列存在空值，即使对该列建索引也不会提高性能。 任何在where子句中使用is null或is not null的语句优化器是不允许使用索引的。 37、联接列对于有联接的列，即使最后的联接值为一个静态值，优化器是不会使用索引的。我们一起来看一个例子，假定有一个职工表(employee)，对于一个职工的姓和名分成两列存放(FIRST_NAME和LAST_NAME)，现在要查询一个叫比尔.克林顿(Bill Cliton)的职工。 下面是一个采用联接查询的SQL语句， 1select * from employss where first_name||''||last_name ='Beill Cliton'; ​ 上面这条语句完全可以查询出是否有Bill Cliton这个员工，但是这里需要注意，系统优化器对基于last_name创建的索引没有使用。 当采用下面这种SQL语句的编写，Oracle系统就可以采用基于last_name创建的索引。 1*** where first_name ='Beill' and last_name ='Cliton'; 带通配符(%)的like语句 同样以上面的例子来看这种情况。目前的需求是这样的，要求在职工表中查询名字中包含cliton的人。可以采用如下的查询SQL语句: 1select * from employee where last_name like '%cliton%'; 这里由于通配符(%)在搜寻词首出现，所以Oracle系统不使用last_name的索引。在很多情况下可能无法避免这种情况，但是一定要心中有底，通配符如此使用会降低查询速度。然而当通配符出现在字符串其他位置时，优化器就能利用索引。在下面的查询中索引得到了使用: 1select * from employee where last_name like 'c%'; 38、Order by语句ORDER BY语句决定了Oracle如何将返回的查询结果排序。Order by语句对要排序的列没有什么特别的限制，也可以将函数加入列中(象联接或者附加等)。任何在Order by语句的非索引项或者有计算表达式都将降低查询速度。 仔细检查order by语句以找出非索引项或者表达式，它们会降低性能。解决这个问题的办法就是重写order by语句以使用索引，也可以为所使用的列建立另外一个索引，同时应绝对避免在order by子句中使用表达式。 39、 NOT我们在查询时经常在where子句使用一些逻辑表达式，如大于、小于、等于以及不等于等等，也可以使用and(与)、or(或)以及not(非)。NOT可用来对任何逻辑运算符号取反。下面是一个NOT子句的例子: 1... where not (status ='VALID') 如果要使用NOT，则应在取反的短语前面加上括号，并在短语前面加上NOT运算符。NOT运算符包含在另外一个逻辑运算符中，这就是不等于(&lt;&gt;)运算符。换句话说，即使不在查询where子句中显式地加入NOT词，NOT仍在运算符中，见下例: 1... where status &lt;&gt;'INVALID'; 对这个查询，可以改写为不使用NOT: 1select * from employee where salary&lt;3000 or salary&gt;3000; 虽然这两种查询的结果一样，但是第二种查询方案会比第一种查询方案更快些。第二种查询允许Oracle对salary列使用索引，而第一种查询则不能使用索引。]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>SQL优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【推荐】Hexo 的 Next 主题优化/个性化]]></title>
    <url>%2Fblog%2F2017-06-06.Hexo-theme-next-optimize%2F</url>
    <content type="text"><![CDATA[参考自： Hexo 官方 Doc NexT 官方 Doc 【主要来源】hexo的next主题个性化教程:打造炫酷网站 Hexo常见问题解决方案 hexo优化 0. 基本配置部署到多平台 参考 ： 将hexo-github博客同步托管至coding 由于百度蜘蛛把github屏蔽了，导致百度搜不到博客文章，let me feel a little unhappy，为了扩大网站收录率，我将hexo-github博客同步托管到国内coding上。 Hexo提供了hexo-deployer-git工具，可以帮助部署Hexo到很多平台。 1$ npm install hexo-deployer-git --save 修改_config.yml中的配置： 123456deploy: type: git repo: coding: git@git.coding.net:yafey/blog.git github: git@github.com:yafey/blog.git branch: master 然后执行命令： 12hexo g # 生成， hexo generate 的缩写hexo d # 部署， hexo deploy 的缩写 以下参考自 ： Hexo博客搭建之使用Hexo+GitHub搭建个人博客 在使用框架时，会常用到以下几个命令： 12345$ hexo generate // 简写：hexo g，生成静态文件，会在当前目录下生成一个public文件夹$ hexo server // 简写：hexo s，启动本地服务，用于博客的预览$ hexo deploy // 简写：hexo d，部署到远程（如GitHub，可以在_config.yml中配置）$ hexo new post-name // 简写：hexo n post-name， 新建文章$ hexo new page page-name //简写：hexo n page page-name，新建页面 还有常用的组合命令： 12$ hexo d -g // 生成和部署$ hexo s -g // 生成和预览 草稿命令： 123$ hexo new draft &lt;title&gt; // 新建草稿，存放在source/_drafts$ hexo publish post &lt;title&gt; // 发布草稿为文章，文章转移到source/_posts$ hexo s -g --drafts // 显示草稿 简单必要设置 注意：配置文件要符合英文标点符号使用规范: 冒号后必须空格，否则会编译错误 a. Hexo _config.yml 修改语言 123language: - zh-Hans # 中文 - defaults b. next _config.yml 修改 主题 1scheme: Mist #整洁有序的单栏外观 ， 右侧边栏 c. 网站标题，作者Hexo _config.yml ，修改这些值：12345title: Y.a.F.e.Y Blog #博客标题subtitle: #博客副标题description: #博客描述author: YaFey #作者timezone: Asia/Chongqing d. 域名，文章链接 Hexo _config.yml ，修改这些值：1234url: http://xxx #你的博客网址root: /blog/ #博客跟目录，如果你的博客在网址的二级目录下，在这里填上permalink: :year/:month/:day/:title/permalink_defaults: #可以不填 e. 创建页面 &amp; 修改菜单 添加「标签」页面 添加「分类」页面 标签 和 分类 禁用评论 123456---title: categories # 若 标签， title 为 tagsdate: 2017-05-28 09:53:57type: "categories" # 若 标签， 引号内 为 tagscomments: false #禁用评论--- 1. next 主题优化 看到有些next主题的网站很炫酷，那么是怎么配置的呢？接下来我会讲一讲如何实现一些炫酷的效果 主要有以下29种： 在右上角或者左上角实现fork me on github 添加RSS 添加动态背景 实现点击出现桃心效果 修改文章内链接文本样式 修改文章底部的那个带#号的标签 在每篇文章末尾统一添加“本文结束”标记 修改作者头像并旋转 博文压缩 修改``代码块自定义样式 侧边栏社交小图标设置 主页文章添加阴影效果 在网站底部加上访问量 添加热度 网站底部字数统计 添加 README.md 文件 设置网站的图标Favicon 实现统计功能 添加顶部加载条 在文章底部增加版权信息 添加网易云跟帖 隐藏网页底部powered By Hexo / 强力驱动 修改网页底部的桃心 文章加密访问 添加jiathis分享 博文置顶 修改字体大小 修改打赏字体不闪动 侧边栏推荐阅读 0. 无痛使用图片参考另一篇文章 在 hexo 中无痛使用本地图片 1. 在右上角或者左上角实现fork me on github实现效果图 具体实现方法 点击这里挑选自己喜欢的样式，并复制代码。 例如，我是复制如下代码：然后粘贴刚才复制的代码到themes/next/layout/_layout.swig文件中(放在&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;的下面)，并把href改为你的github地址 2.添加RSS实现效果图 具体实现方法 切换到你的blog（我是取名blog，具体的看你们的取名是什么）的路径，例如我是在/Users/chenzekun/Code/Hexo/blog这个路径上，也就是在你的根目录下 然后安装 Hexo 插件：(这个插件会放在node_modules这个文件夹里) 1$ npm install --save hexo-generator-feed 接下来打开画红线的文件，如下图： 在里面的末尾添加：(请注意在冒号后面要加一个空格，不然会发生错误！) 123# Extensions## Plugins: http://hexo.io/plugins/plugins: hexo-generate-feed 然后打开next主题文件夹里面的_config.yml,在里面配置为如下样子：(就是在rss:的后面加上/atom.xml,注意在冒号后面要加一个空格) 1234# Set rss to false to disable feed link.# Leave rss as empty to use site's feed link.# Set rss to specific value if you have burned your feed already.rss: /atom.xml 配置完之后运行： 1$ hexo g 重新生成一次，你会在./public 文件夹中看到 atom.xml 文件。然后启动服务器查看是否有效，之后再部署到 Github 中。 3. 添加动态背景实现效果图 具体实现方法 这个我之前有一篇文章有讲过了，详情点击我的博客 修改_layout.swig打开 next/layout/_layout.swig在 &lt; /body&gt;之前添加代码(注意不要放在&lt; /head&gt;的后面) 123&#123;% if theme.canvas_nest %&#125;&lt;script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"&gt;&lt;/script&gt;&#123;% endif %&#125; 修改配置文件打开 /next/_config.yml,在里面添加如下代码：(可以放在最后面) 123456# --------------------------------------------------------------# background settings# --------------------------------------------------------------# add canvas-nest effect# see detail from https://github.com/hustcc/canvas-nest.jscanvas_nest: true 到此就结束了，运行 hexo clean，然后运行 hexo g,然后运行 hexo s，最后打开浏览器在浏览器的地址栏输入 localhost:4000 就能看到效果了\（￣︶￣）/ 如果你感觉默认的线条太多的话可以这么设置====&gt;在上一步修改 _layout.swig中，把刚才的这些代码： 123&#123;% if theme.canvas_nest %&#125;&lt;script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"&gt;&lt;/script&gt;&#123;% endif %&#125; 改为 1234&#123;% if theme.canvas_nest %&#125;&lt;script type="text/javascript"color="0,0,255" opacity='0.7' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"&gt;&lt;/script&gt;&#123;% endif %&#125; 配置项说明 color ：线条颜色, 默认: &#39;0,0,0&#39;；三个数字分别为(R,G,B) opacity: 线条透明度（0~1）, 默认: 0.5 count: 线条的总数量, 默认: 150 zIndex: 背景的z-index属性，css属性用于控制所在层的位置, 默认: -1 4. 实现点击出现桃心效果实现效果图 具体实现方法 在网址输入如下 1http://7u2ss1.com1.z0.glb.clouddn.com/love.js 然后将里面的代码copy一下，新建love.js文件并且将代码复制进去，然后保存。将love.js文件放到路径/themes/next/source/js/src里面，然后打开\themes\next\layout\_layout.swig文件,在末尾（在前面引用会出现找不到的bug）添加以下代码： 12&lt;!-- 页面点击小红心 --&gt;&#123;% include '_third-party/love.swig' %&#125; 新建 love.swig 1&lt;script type="text/javascript" src="&#123;&#123; url_for(theme.js) &#125;&#125;/src/love.js"&gt;&lt;/script&gt; 5. 修改文章内链接文本样式实现效果图 具体实现方法 修改文件 themes\next\source\css\_common\components\post\post.styl，在末尾添加如下css样式，： 1234567891011// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 其中选择.post-body 是为了不影响标题，选择 p 是为了不影响首页“阅读全文”的显示样式,颜色可以自己定义。 6. 修改文章底部的那个带#号的标签实现效果图 具体实现方法 修改模板/themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将 # 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 7. 在每篇文章末尾统一添加“本文结束”标记实现效果图 具体实现方法 在路径 \themes\next\layout\_macro 中新建 passage-end-tag.swig 文件,并添加以下内容： 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;-------------本文结束&lt;i class="fa fa-paw"&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 接着打开\themes\next\layout\_macro\post.swig文件，在post-body 之后， post-footer 之前添加如下画红色部分代码（post-footer之前两个DIV）： 代码如下： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 然后打开主题配置文件（_config.yml),在末尾添加： 123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 完成以上设置之后，在每篇文章之后都会添加如上效果图的样子。 8. 修改作者头像并旋转实现效果图 具体实现方法 打开\themes\next\source\css\_common\components\sidebar\sidebar-author.styl，在里面添加如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125; 9. 博文压缩在站点的根目录下执行以下命令： 12$ npm install gulp -g$ npm install gulp-clean-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save 在如下图所示，新建 gulpfile.js ，并填入以下内容： 123456789101112131415161718192021222324252627282930313233var gulp = require('gulp');var minifycss = require('gulp-clean-css');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');// 压缩 public 目录 cssgulp.task('minify-css', function() &#123; return gulp.src('./public/**/*.css') .pipe(minifycss()) .pipe(gulp.dest('./public'));&#125;);// 压缩 public 目录 htmlgulp.task('minify-html', function() &#123; return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest('./public'))&#125;);// 压缩 public/js 目录 jsgulp.task('minify-js', function() &#123; return gulp.src('./public/**/*.js') .pipe(uglify()) .pipe(gulp.dest('./public'));&#125;);// 执行 gulp 命令时执行的任务gulp.task('default', [ 'minify-html','minify-css','minify-js']); 生成博文时执行 hexo g &amp;&amp; gulp 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。 10. 修改``代码块自定义样式实现效果图 具体实现方法 打开\themes\next\source\css\_custom\custom.styl,向里面加入：(颜色可以自己定义) 123456789101112131415// Custom styles.code &#123; color: #ff7600; background: #fbf7f8; margin: 2px;&#125;// 大代码块的自定义样式.highlight, pre &#123; margin: 5px 0; padding: 5px; border-radius: 3px;&#125;.highlight, code, pre &#123; border: 1px solid #d6d6d6;&#125; 11. 侧边栏社交小图标设置实现效果图 具体实现方法 打开主题配置文件（_config.yml），搜索social_icons:,在图标库找自己喜欢的小图标，并将名字复制在如下位置，保存即可 12. 主页文章添加阴影效果实现效果图 具体实现方法 打开\themes\next\source\css\_custom\custom.styl,向里面加入： 12345678// 主页文章添加阴影效果 .post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 13. 在网站底部加上访问量实现效果图 具体实现方法打开\themes\next\layout\_partials\footer.swig文件,在copyright前加上画红线这句话： 代码如下： 1&lt;script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt; 然后再合适的位置添加显示统计的代码，如图：代码如下： 12345&lt;div class="powered-by"&gt;&lt;i class="fa fa-user-md"&gt;&lt;/i&gt;&lt;span id="busuanzi_container_site_uv"&gt; 本站访客数:&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt; 在这里有两中不同计算方式的统计代码： pv的方式，单个用户连续点击n篇文章，记录n次访问量 123&lt;span id="busuanzi_container_site_pv"&gt; 本站总访问量&lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt;次&lt;/span&gt; uv的方式，单个用户连续点击n篇文章，只记录1次访客数 123&lt;span id="busuanzi_container_site_uv"&gt; 本站总访问量&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;次&lt;/span&gt; 添加之后再执行hexo d -g，然后再刷新页面就能看到效果 14. 添加热度实现效果图 具体实现方法 next主题集成leanCloud，打开/themes/next/layout/_macro/post.swig,在画红线的区域添加℃： 然后打开，/themes/next/languages/zh-Hans.yml,将画红框的改为热度就可以了 15. 网站底部字数统计实现效果图 具体方法实现切换到根目录下，然后运行如下代码 1$ npm install hexo-wordcount --save 然后在/themes/next/layout/_partials/footer.swig文件尾部加上： 1234&lt;div class="theme-info"&gt; &lt;div class="powered-by"&gt;&lt;/div&gt; &lt;span class="post-count"&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 16. 添加 README.md 文件每个项目下一般都有一个 README.md 文件，但是使用 hexo 部署到仓库后，项目下是没有 README.md 文件的。 在 Hexo 目录下的 source 根目录下添加一个 README.md 文件，修改站点配置文件 _config.yml，将 skip_render 参数的值设置为 1skip_render: README.md 保存退出即可。再次使用 hexo d 命令部署博客的时候就不会在渲染 README.md 这个文件了。 17. 设置网站的图标Favicon实现效果图 具体方法实现 在EasyIcon中找一张（32*32）的ico图标,或者去别的网站下载或者制作，并将图标名称改为favicon.ico，然后把图标放在/themes/next/source/images里，并且修改主题配置文件： 12# Put your favicon.ico into `hexo-site/source/` directory.favicon: /favicon.ico 18. 实现统计功能实现效果图 具体实现方法 在根目录下安装 hexo-wordcount,运行： 1$ npm install hexo-wordcount --save 然后在主题的配置文件中，配置如下： 123456# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true 19. 添加顶部加载条实现效果图 具体实现方法 打开/themes/next/layout/_partials/head.swig文件，添加红框上的代码代码如下： 12&lt;script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"&gt;&lt;/script&gt;&lt;link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"&gt; 但是，默认的是粉色的，要改变颜色可以在/themes/next/layout/_partials/head.swig文件中添加如下代码（接在刚才link的后面） 12345678910111213&lt;style&gt; .pace .pace-progress &#123; background: #1E92FB; /*进度条颜色*/ height: 3px; &#125; .pace .pace-progress-inner &#123; box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/ &#125; .pace .pace-activity &#123; border-top-color: #1E92FB; /*上边框颜色*/ border-left-color: #1E92FB; /*左边框颜色*/ &#125;&lt;/style&gt; 目前，博主的增加顶部加载条的pull request 已被Merge😀===&gt;详情现在升级最新版的next主题，升级后只需修改主题配置文件(_config.yml)将pace: false改为pace: true就行了，你还可以换不同样式的加载条，如下图： 20. 在文章底部增加版权信息实现效果图 在目录 next/layout/_macro/下添加 my-copyright.swig： 1234567891011121314151617181920212223242526272829303132&#123;% if page.copyright %&#125;&lt;div class="my_post_copyright"&gt; &lt;script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script type="text/javascript" src="http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js"&gt;&lt;/script&gt; &lt;script src="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" type="text/css" href="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css"&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;"&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href="/" title="访问 &#123;&#123; theme.author &#125;&#125; 的个人博客"&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format("YYYY年MM月DD日 - HH:MM") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format("YYYY年MM月DD日 - HH:MM") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;" title="&#123;&#123; page.title &#125;&#125;"&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class="copy-path" title="点击复制文章链接"&gt;&lt;i class="fa fa-clipboard" data-clipboard-text="&#123;&#123; page.permalink &#125;&#125;" aria-label="复制成功！"&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class="fa fa-creative-commons"&gt;&lt;/i&gt; &lt;a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)"&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard('.fa-clipboard'); clipboard.on('success', $(function()&#123; $(".fa-clipboard").click(function()&#123; swal(&#123; title: "", text: '复制成功', html: false, timer: 500, showConfirmButton: false &#125;); &#125;); &#125;)); &lt;/script&gt;&#123;% endif %&#125; 在目录next/source/css/_common/components/post/下添加my-post-copyright.styl： 123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 修改next/layout/_macro/post.swig，在代码 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'wechat-subscriber.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 之前添加增加如下代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'my-copyright.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 如下： 修改next/source/css/_common/components/post/post.styl文件，在最后一行增加代码： 1@import "my-post-copyright" 保存重新生成即可。如果要在该博文下面增加版权信息的显示，需要在 Markdown 中增加copyright: true的设置，类似： 1234567---title: 前端小项目：使用canvas绘画哆啦A梦date: 2017-05-22 22:53:53tags: canvascategories: 前端copyright: true--- 小技巧：如果你觉得每次都要输入copyright: true很麻烦的话,那么在/scaffolds/post.md文件中添加：这样每次hexo new &quot;你的内容&quot;之后，生成的md文件会自动把copyright:加到里面去(注意：如果解析出来之后，你的原始链接有问题：如：http://yoursite.com/前端小项目：使用canvas绘画哆啦A梦.html,那么在根目录下_config.yml中写成类似这样：）就行了。 21. 添加网易云跟帖实现效果图 具体方法实现有两种实现方法：①更新next主题，因为最新版本的主题已经支持这种评论。直接在主题配置文件_config.yml 文件中添加如下配置: 12 1gentie_productKey: #your-gentie-product-key ②如果你不想更新的话，那么按下面步骤进行：首先，还是在主题配置文件_config.yml 文件中添加如下配置: 12 1gentie_productKey: #your-gentie-product-key 你的productKey就是下面画红线部分 然后在在layout/_scripts/third-party/comments/ 目录中添加 gentie.swig，文件内容如下： 12 1234567891011121314&#123;% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname and not theme.disqus_shortname and not theme.hypercomments_id %&#125; &#123;% if theme.gentie_productKey %&#125; &#123;% set gentie_productKey = theme.gentie_productKey %&#125; &lt;script&gt; var cloudTieConfig = &#123; url: document.location.href, sourceId: "", productKey: "&#123;&#123;gentie_productKey&#125;&#125;", target: "cloud-tie-wrapper" &#125;; &lt;/script&gt; &lt;script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"&gt;&lt;/script&gt; &#123;% endif %&#125;&#123;% endif %&#125; 然后在layout/_scripts/third-party/comments.swig文件中追加： 12 1&#123;% include './comments/gentie.swig' %&#125; 最后，在 layout/_partials/comments.swig 文件中条件最后追加网易云跟帖插件引用的判断逻辑： 12 123&#123;% elseif theme.gentie_productKey %&#125; &lt;div id="cloud-tie-wrapper" class="cloud-tie-wrapper"&gt; &lt;/div&gt; 具体位置如下： 可能你hexo s时可能看不到，直接hexo d就可以看到了 22. 隐藏网页底部powered By Hexo / 强力驱动打开themes/next/layout/_partials/footer.swig,使用””隐藏之间的代码即可，或者直接删除。位置如图： 23. 修改网页底部的桃心还是打开themes/next/layout/_partials/footer.swig，找到：，然后还是在图标库中找到你自己喜欢的图标，然后修改画红线的部分就可以了。 24. 文章加密访问实现效果图 具体实现方法 打开themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件,在以下位置插入这样一段代码： 代码如下： 12345678910&lt;script&gt; (function()&#123; if('&#123;&#123; page.password &#125;&#125;')&#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;')&#123; alert('密码错误！'); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 然后在文章上写成类似这样： 25. 添加jiathis分享在主题配置文件中，jiathis为true，就行了，如下图 默认是这样子的：如果你想自定义话，打开themes/next/layout/_partials/share/jiathis.swig修改画红线部分就可以了 26. 博文置顶修改 hero-generator-index 插件，把文件：node_modules/hexo-generator-index/lib/generator.js 内的代码替换为： 12345678910111213141516171819202122232425262728'use strict';var pagination = require('hexo-pagination');module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 在文章中添加 top 值，数值越大文章越靠前，如 12345678---title: 解决Charles乱码问题date: 2017-05-22 22:45:48tags: 技巧categories: 技巧copyright: truetop: 100--- 27. 修改字体大小打开\themes\next\source\css\ _variables\base.styl文件，将$font-size-base改成16px，如下所示： 1$font-size-base =16px 28. 修改打赏字体不闪动修改文件next/source/css/_common/components/post/post-reward.styl，然后注释其中的函数wechat:hover和alipay:hover，如下： 123456789101112/* 注释文字闪动函数 #wechat:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125; #alipay:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125;*/ 29. 侧边栏推荐阅读今天有位网友问推荐阅读是怎么弄，其实挺简单的，打开主题配置文件修改成这样就行了(links里面写你想要的链接): 1234567891011# Blogrollslinks_title: 推荐阅读#links_layout: blocklinks_layout: inlinelinks: 优设: http://www.uisdc.com/ 张鑫旭: http://www.zhangxinxu.com/ Web前端导航: http://www.alloyteam.com/nav/ 前端书籍资料: http://www.36zhen.com/t?id=3448 百度前端技术学院: http://ife.baidu.com/ google前端开发基础: http://wf.uisdc.com/cn/ 致谢 感谢大神们的文章，真的学到了许多，有些忘了记录下来，在这里由衷的感谢。虽然比较折腾，但是确实满满的成就感，Road endless its long and far, I will seek up and down！ 欢迎访问我的博客 参考的文章： http://blog.csdn.net/MasterAnt_D/article/details/56839222 http://zidingyi4qh.com/2017/04/27/NexT%E5%BA%95%E9%83%A8logo%E6%B7%BB%E5%8A%A0%E8%AE%BF%E9%97%AE%E9%87%8F/ https://fuyis.me/2017/01/25/Hexo-theme-next-and-optimized-configuration/ http://www.vitah.net/posts/20f300cc/ http://thief.one/2017/03/03/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next 主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 主题同步]]></title>
    <url>%2Fblog%2F2017-06-06.Hexo-theme-sync%2F</url>
    <content type="text"><![CDATA[主题同步的时候肯定会产生冲突，不要害怕冲突，有冲突是好事，还能增强对 Git 的使用，只能这样安慰自己了。 关于 主题 同步，考虑了好几天， 还是采用这个方案吧。 参考 ： 同步hexo主题 主题作者一直在增加新功能，我偶尔会修改下主题的样式，如何应用到我自己的站点里？其实就是git的submodule的用法。 12345678910111213# 首先clone我自己的 repo 到 Hexo 的根目录 ， 注意最后的 ` themes/next`git clone &lt;hexo-theme-next@bitbucket.org&gt; themes/next# cd themes/next 并 添加一个github的remotecd themes/nextgit remote add github git@github.com:iissnan/hexo-theme-next.git # 注意这是不是 origin , origin 其实是默认的别名# 将作者的一些更新合并到我自己的分支git pull github master # 注意这是不是 origingit checkout foolbeargit merge master# 肯定会有些冲突，解决冲突后commitgit commit -m "xxx"# 修改后的foolbear分支push到我自己的repogit push origin foolbear 以下操作在我自己笔记本上 123cd themes/nextgit pullgit checkout foolbear 概念上是很简单的，只是记录下。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next 主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 常用操作]]></title>
    <url>%2Fblog%2F2017-06-06.git-brief%2F</url>
    <content type="text"><![CDATA[git 初始化（以下命令在 Git Bash中操作）添加 Coding 账户 SSH 公钥 TL;DR [^1] 参考 ： coding 帮助中心 生成公钥打开命令行终端输入ssh-keygen -t rsa -C “username@example.com”,( 注册的邮箱)，接下来点击enter键即可（也可以输入密码）。 12345ssh-keygen -t rsa -b 4096 -C "your_email@example.com"# Creates a new ssh key, using the provided email as a label# Generating public/private rsa key pair.Enter file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter] // 因为有多个git 仓库，所以 推荐跟仓库名及使用的电脑相关， 如：coding_pcEnter passphrase (empty for no passphrase): 成功之后 1234Your identification has been saved in /Users/you/.ssh/id_rsa.# Your public key has been saved in /Users/you/.ssh/id_rsa.pub.# The key fingerprint is:# 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com 添加公钥 本地打开 id_rsa.pub 文件，复制其中全部内容，填写到SSH_RSA公钥key下的一栏，公钥名称可以随意起名字。 完成后点击“添加”，然后输入密码或动态码即可添加完成。 完成后在命令行测试，首次建立链接会要求信任主机。 ssh -T git@git.coding.net 12~/git $ ssh -T git@git.coding.netHello yafey! You've connected to Coding.net via SSH successfully! 【知识点】多个账户配置 （如 github + coding）如果需要使用多个账户建议生成多个公钥，可以在 ~/.ssh/config文件中加上下边一段 12345# 该文件用于配置私钥对应的服务器Host git.coding.netUser xxxx@email.com # 这里 也可以配置成 `User git`PreferredAuthentications publickeyIdentityFile ~/.ssh/coding_rsa # 生成的非默认地址的公钥存放点 git clone --recursive好像是会把 submodule 也更新好， 待验证。 git 初始化项目在命令行中创建 Git 仓库 12345678mkdir HexoBlogSourcecd HexoBlogSourcegit initecho "# HexoBlogSource" &gt;&gt; README.mdgit add README.mdgit commit -m "first commit"git remote add origin https://git.coding.net/yafey/HexoBlogSource.gitgit push -u origin master 已有项目 12git remote add origin https://git.coding.net/yafey/HexoBlogSource.gitgit push -u origin master git 常用操作集锦tag remote branch HEAD directly 参考 ： Git: Is there a way to tag remote branch HEAD directly by commit id? No real need to mess with local tags, just do the rewrite while pushing. 12# 替换下面的 &lt;&gt; 中的内容， 如果只有一个 remote ，origin 不用替换。git push &lt;origin&gt; refs/remotes/&lt;origin&gt;/&lt;branch1&gt;:refs/tags/&lt;tagged-branch1&gt; [^1]: Too Long; Don’t Read的缩写，换成中国话，就是太长了，读不下去的意思。 网络上的文章都太长了？ @2012-11-27 09:30 根据字典解释，“TL;DR”发源自网络。一般用于回复别人写得太多，反而让人抓不住重点，现在有的人把它放在一段话的开头，代表“长话短说”的意思——如今不少服务都直接以“TL;DR”为命名，把网络上一篇很长的报道，缩短成简单的三两句话，让人快速抓住文章的精华。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【简要】记录搭建 Hexo 的一些步骤]]></title>
    <url>%2Fblog%2F2017-06-06.Hexo-brief%2F</url>
    <content type="text"><![CDATA[总想有个自己的地方记录一些东西， 兜兜转转，还是选择了GitHub Pages。试过Jekyll，可惜ruby跟我相性实在不合，折腾了半天也没搞明白。于是选择了Hexo。使用很简单，js也比ruby亲切些，但搭建过程中还是碰到一些问题，这里记录下。 安装 Node.js暂时略， 可参考 记录下搭建hexo的一些问题 by 自制node.js + npm绿色版 安装 Git略， 作为开发， 你电脑上都没有 Git ？ 教程网上一大把。 建议： 安装的时候， 不要选择 checkout Window ，commit Linux ， 这样自动转换 EOL 的 默认选项。 安装 Hexo 【重头戏开始了】写博客时 2017年6月6日23:46:34 的 版本信息 ，Hexo 不同的版本变化还挺大的。 12345678910111213PS ~\git\HexoBlogSource&gt; hexo versionhexo: 3.3.7hexo-cli: 1.0.3os: Windows_NT 10.0.14393 win32 x64http_parser: 2.7.0node: 6.9.2v8: 5.1.281.88uv: 1.9.1zlib: 1.2.8ares: 1.10.1-DEVicu: 57.1modules: 48openssl: 1.0.2j Hexo 官网 给出了 最简单的 安装步骤 (稍加整理) 1234567891011# npm安装时其实可以指定版本号npm install hexo-cli -ghexo init blogcd blog# 安装一些必要的依赖 ， 执行前看下 &lt;【知识点】在中国，npm 使用优化 &gt;npm installhexo s[erver] -p 80 # [] 方括号中的内容可省略# 可选，使用rss时才需要npm install hexo-generator-feed --save# 可选，生成sitemapnpm install hexo-generator-sitemap --save 【知识点】在中国，npm 使用优化 网络不好、被墙的话，npm会很慢，试试加参数--registry=http://r.cnpmjs.org，国内的镜像。 出现各种奇怪的错误的话，试试npm cache clear。 将 Npm 的源替换成淘宝的源 参考 ： 将 Npm 的源替换成淘宝的源 by sg.ff @2016年02月17日发布 在墙内久了，难免会碰到撞墙的时候，所幸国内也有众多 NPM 镜像可供选择，在大多数情况下我们可以使用国内的源（比如 淘宝 NPM 镜像 http://npm.taobao.org）去替换官方的源以加快下载包的速度。 不过呢，我们在发布自己的包的时候却需要将源修改回官方的 https://registry.npmjs.org 源。 1234567# 修改源地址为淘宝 NPM 镜像npm config set registry http://registry.npm.taobao.org/# 修改源地址为官方源npm config set registry https://registry.npmjs.org/ 安装 Next 主题 hexo的主题很多，但感觉好看的不多。。。最终选择了NexT，很喜欢这种简洁的风格，作者更新也很积极。 你会爱上 Next 的 。 Hexo 主题的同步目前是个问题， 详见 另一篇文章 《Hexo 主题同步》 Next 主题优化内容太多， 详见 另一篇文章 《Hexo 主题优化》 未解之谜 可能的原因： 参考自： Hexo部署常见问题解决方案 将自己的Blog文件夹使用Git来管理，需要注意一下几点。 如果主题是通过git管理的，需要将主题文件夹下的.git文件夹删除，才能同步Blog文件夹（.git文件夹是隐藏的，需要显示隐藏文件才能删除，Linux下需要rm -rf命令才能删除，Mac没用过，不清楚）。 按照Blog目录下自带的.gitignore文件，node_modules文件夹是不会同步的，所以同步之后需要自己再次进行npm install，但是注意，不要进行hexo init了，否则_config.yml全都白弄了。 可以看到 hexo init a 时， 会自动把 landscape 下载好， 日志中也打出了 Submodule &#39;themes/landscape&#39; (...) registered for path &#39;themes/landscape&#39; 这样的信息， 但是： 奇怪的就是 ， landscape 在 Hexo 根目录 用 git gui 命令 是可以看到 文件的， 但是 next 主题只显示 subproject 一个文件， 难道是因为 hexo init a 用了类似 git clone --recursive 的语法，然后就不作为一个 subproject 了？ 然后我把 landscape 目录删了， 按 Next 方式 clone 了一遍， landscape 目录也像 next 那样只显示 subproject 一个文件， 这样也好，减少了很多文件。 1234567891011121314151617181920212223242526272829303132333435363738PS ~\git&gt; hexo init aINFO Cloning hexo-starter to ~\git\aCloning into '~\git\a'...remote: Counting objects: 53, done.remote: Total 53 (delta 0), reused 0 (delta 0), pack-reused 53Unpacking objects: 100% (53/53), done.Submodule 'themes/landscape' (https://github.com/hexojs/hexo-theme-landscape.git) registered for path 'themes/landscape'Cloning into '~/git/a/themes/landscape'...remote: Counting objects: 775, done.remote: Total 775 (delta 0), reused 0 (delta 0), pack-reused 775Receiving objects: 100% (775/775), 2.53 MiB | 1.18 MiB/s, done.Resolving deltas: 100% (397/397), done.INFO Install dependencies��Ϣ: ���ṩ��ģʽ�޷��ҵ��ļ�npm WARN deprecated swig@1.4.2: This package is no longer maintainednpm WARN prefer global marked@0.3.6 should be installed with -g&gt; fsevents@1.1.1 install ~\git\a\node_modules\fsevents&gt; node install&gt; dtrace-provider@0.8.2 install ~\git\a\node_modules\dtrace-provider&gt; node scripts/install.js&gt; hexo-util@0.6.0 postinstall ~\git\a\node_modules\hexo-util&gt; npm run build:highlightnpm WARN invalid config loglevel="notice"&gt; hexo-util@0.6.0 build:highlight ~\git\a\node_modules\hexo-util&gt; node scripts/build_highlight_alias.js &gt; highlight_alias.jsonnpm notice created a lockfile as package-lock.json. You should commit this file.added 438 packages in 200.46sINFO Start blogging with Hexo! 参考 ： 【重点参考】记录下搭建hexo的一些问题 最简便的方法搭建Hexo+Github博客,基于Next主题 Hexo部署常见问题解决方案 – 传送门]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 ES Decorators 构建一致性 API「淘宝FED前端团队」]]></title>
    <url>%2Fblog%2F2017-06-02.building-consistent-api-with-es-decorators%2F</url>
    <content type="text"><![CDATA[使用 ES decorators 构建一致性 API作者: 法海 发表于: 2017-04-27 重用和一致性是程序设计中经久不衰的两个课题。在最新的 ES Proposal 中，「decorators 语法」为此带来了一定的便利，并且，很适合应用于大型的类库中。 装饰模式提到 decorator 大家都不会陌生，即「装饰模式」—— 我们可以在「不侵入原有代码」的情况下，为代码增加一些「额外的功能」。 所谓「额外的功能」一般都比较独立，不和原有逻辑耦合，只是做一层包装。你也可以把它看成「包装模式」。形如： 123456789101112131415// 旧方法function func() &#123;&#125;// 包装后的新方法function funcWrapped() &#123; // 有的没的 doSomethingBefore(); // 旧方法的过程本身并不变化 func(); // 这啊那的 doSomethingAfter();&#125; 这样看来，有一些场景特别适用这个模式，比如： 记录方法的开始执行和结束执行。 为运算过程提供额外的缓存能力。 标记方法为 deprecated。 等等。 编写一个装饰器如果有好多方法都想包上这种「额外的功能」，那么我们不会一个个地去改写，而是考虑抽出一个「装饰器」—— 它能够接受原方法，然后生成包装后的方法。比如，我们想记录所有方法的运行时间： 12345678910111213141516171819function performanceTimingDecorator(func) &#123; // 返回包装后的新方法 return function(...args) &#123; const start = Date.now(); func(...args); const end = Date.now(); const t = end - start; console.log(`$&#123;func.name&#125; performed $&#123;t&#125;ms.`); &#125;;&#125;function func() &#123;&#125;const funcWrapped = performanceTimingDecorator(func);// func performed 2ms.funcWrapped(); 使用 ES decorators如果一个系统内需要大量运用装饰器，那么上述的写法可读性还有待提高。ES decorators 解决了这个问题，这是一个新的语法（语法糖）： 123456789101112131415// 定义 decoratorfunction performanceTiming(...args) &#123; // 返回包装后的方法 return function(target, key, descriptor) &#123; // ... &#125;;&#125;class MyClass &#123; // 使用这种语法修饰方法 func @performanceTiming func() &#123;&#125;&#125; 新的 decorator 语法 @xxx 的形式非常类似 Java Annotation，不过后者作为静态语言，其 Annotation 的实现机制以及使用场景和 ES decorators 都有区别，这是一个题外话。事实上，ES decorators 完全借鉴自 Python 的 decorators。 同时，聪明的你应该发现，相比手写装饰器，新的语法中其实「该写的东西一个都没少」。那这个 decorators 语法有什么意义呢？ 在我看来，这种语法糖对 decorators 的「定义」和「调用」都做了收敛，带来了「形式美感」。说人话，可读性更好。 在 decorators 定义时，约束了装饰器的输入（固定的几个相关参数）和输出（返回一个 function），使所有装饰器风格得到收敛。 在 decorators 调用时，以无侵入的语法「修饰」类或方法，可维护性和可读性都提升很多。 这两个优势，让我想到 ES decorators 的一个重要使用场景，便是应用于构架一致性 API。 构架一致性 API对于多人开发的大型类库来说，「一致性」是很重要同时也很难执行的一个课题。这里的「一致性」包括： 各模块提供一致的标准公用功能。 公用功能的实现和调用方式也保持一致。 整体 API 的风格一致。 其中 1、2 两点可以通过引入 ES decorators 机制来更好地达到。 实践演示先封装好部分 decorators（可参见 @ali/universal-decorator 这个包），这里选取两个装饰器： @deprecated - 用于修饰类的方法，如果方法被调用，则在 console 中提示此方法已经过时，以便开发者转而调用其他方法。 @moduleLevel - 这是 Rax 体系下模块类的一个静态成员标准字段，可取值为几个有限的枚举，此装饰器对此做了约束。 接下来具体地应用到库中。 例如 @ali/universal-tracker 中，report() 方法已经迁移到了 @ali/universal-goldlog，原方法已经废弃，则可以写作： 1234567891011import &#123;deprecated&#125; from '@ali/universal-decorator';class Tracker &#123; @deprecated('This method is moved to universal-goldlog.', &#123; url: 'http://web.npm.alibaba-inc.com/package/@ali/universal-goldlog' &#125;) report() &#123; // ... &#125;&#125; 然后在调用 report() 后则会提示： 这样，在相关的所有库中都引入类似的装饰器，从而保证 API 表达上的一致，并且这些公共逻辑遵循一致的实现。 另外还有一个例子，可以用来对类的字段做约束。以大量基于 Rax 的页面模块为例，这些模块 class 需要声明一个静态属性 moduleLevel 是 app 级别还是 page 级别，以便于框架将其渲染到对应的容器中。但是静态成员的赋值不够清晰明朗，也不能对枚举值做约束。使用 decorators 来改写则： 1234567import &#123;moduleLevel&#125; from '@ali/universal-decorator';@moduleLevel('page')class MyModule1 &#123;&#125;@moduleLevel('other')class MyModule2 &#123;&#125; moduleLevel 这个 decorator 将为类赋上一个名为 moduleLevel 的静态成员，并且会对传入值作判断，如果入参不是 &#39;page&#39; 或 &#39;app&#39;，则发出警告： 最后，由于使用了 ES decorators 语法的代码，类似于一种声明式的标记，所以更利于我们对这些代码作静态分析，比如进一步的提前校验，或是条件编译等等。这部分更多的想法和思路，有待发掘。 引用 Exploring EcmaScript Decorators 题图：一棵被装饰得五光十色的圣诞树。很多涉及到 decorator 的文章动不动就拿圣诞树来举例子，俨然 Christmas tree 是 decorate 的固定宾语。🎄]]></content>
      <categories>
        <category>Web开发</category>
      </categories>
      <tags>
        <tag>decorator</tag>
        <tag>es7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES7 Decorator 装饰者模式「淘宝FED前端团队」]]></title>
    <url>%2Fblog%2F2017-06-02.es7-decorator%2F</url>
    <content type="text"><![CDATA[ES7 Decorator 装饰者模式作者: 玄农 发表于: 2015-11-16 1、装饰模式设计模式大家都有了解，网上有很多系列教程。 这里只分享 装饰者模式 以及如何使用 ES7 的 decorator 概念。 1.1、装饰模式 v.s. 适配器模式装饰模式和适配器模式都是 包装模式 (Wrapper Pattern)，它们都是通过封装其他对象达到设计的目的的，但是它们的形态有很大区别。 适配器模式我们使用的场景比较多，比如连接不同数据库的情况，你需要包装现有的模块接口，从而使之适配数据库 —— 好比你手机使用转接口来适配插座那样； 装饰模式不一样，仅仅包装现有的模块，使之 “更加华丽” ，并不会影响原有接口的功能 —— 好比你给手机添加一个外壳罢了，并不影响手机原有的通话、充电等功能； 更多区别参见：设计模式——装饰模式（Decorator） 1.2、装饰模式场景 —— 面向 AOP 编程装饰模式经典的应用是 AOP 编程，比如“日志系统”，日志系统的作用是记录系统的行为操作，它在不影响原有系统的功能的基础上增加记录环节 —— 好比你佩戴了一个智能手环，并不影响你日常的作息起居，但你现在却有了自己每天的行为记录。 更加抽象的理解，可以理解为给数据流做一层filter，因此 AOP 的典型应用包括 安全检查、缓存、调试、持久化等等。可参考Spring aop 原理及各种应用场景 。 2、使用 ES7 的 decoratorES7 中增加了一个 decorator 属性，它借鉴自 Python，请参考文章Decorators in ES7。 下面我们以 钢铁侠 为例讲解如何使用 ES7 的 decorator。 以钢铁侠为例，钢铁侠本质是一个人，只是“装饰”了很多武器方才变得那么 NB，不过再怎么装饰他还是一个人。 我们的示例场景是这样的 首先创建一个普通的Man类，它的抵御值 2，攻击力为 3，血量为 3； 然后我们让其带上钢铁侠的盔甲，这样他的抵御力增加 100，变成 102； 让其带上光束手套，攻击力增加 50，变成 53； 最后让他增加“飞行”能力 2.1、【Demo 1】对方法的装饰：装备盔甲创建 Man 类： 1234567891011121314151617181920class Man&#123; constructor(def = 2,atk = 3,hp = 3)&#123; this.init(def,atk,hp); &#125; init(def,atk,hp)&#123; this.def = def; // 防御值 this.atk = atk; // 攻击力 this.hp = hp; // 血量 &#125; toString()&#123; return `防御力:$&#123;this.def&#125;,攻击力:$&#123;this.atk&#125;,血量:$&#123;this.hp&#125;`; &#125;&#125;var tony = new Man();console.log(`当前状态 ===&gt; $&#123;tony&#125;`);// 输出：当前状态 ===&gt; 防御力:2,攻击力:3,血量:3 代码直接放在 http://babeljs.io/repl/ 中运行查看结果，记得勾选Experimental选项和Evaluate选项 创建 decorateArmour 方法，为钢铁侠装配盔甲——注意 decorateArmour 是装饰在方法init上的。 1234567891011121314151617181920212223242526272829303132function decorateArmour(target, key, descriptor) &#123; const method = descriptor.value; let moreDef = 100; let ret; descriptor.value = (...args)=&gt;&#123; args[0] += moreDef; ret = method.apply(target, args); return ret; &#125; return descriptor;&#125;class Man&#123; constructor(def = 2,atk = 3,hp = 3)&#123; this.init(def,atk,hp); &#125; @decorateArmour init(def,atk,hp)&#123; this.def = def; // 防御值 this.atk = atk; // 攻击力 this.hp = hp; // 血量 &#125; toString()&#123; return `防御力:$&#123;this.def&#125;,攻击力:$&#123;this.atk&#125;,血量:$&#123;this.hp&#125;`; &#125;&#125;var tony = new Man();console.log(`当前状态 ===&gt; $&#123;tony&#125;`);// 输出：当前状态 ===&gt; 防御力:102,攻击力:3,血量:3 我们先看输出结果，防御力的确增加了 100，看来盔甲起作用了。 初学者这里会有两个疑问： decorateArmour方法的参数为啥是这三个？可以更换么？ decorateArmour方法为什么返回的是descriptor 这里给出个人的解答作为参考： Decorators 的本质是利用了 ES5 的 Object.defineProperty 属性，这三个参数其实是和 Object.defineProperty 参数一致的，因此不能更改，详细分析请见 细说 ES7 JavaScript Decorators 可以看看 bable 转换后 的代码，其中有一句是 descriptor = decorator(target, key, descriptor) || descriptor; ，点到为止，这里不详细展开了，可自行看看这行代码的上下文（参考文献中也涉及到这句代码的解释）。 2.2、【Demo 2】装饰器叠加：增加光束手套在上面的示例中，我们成功为 普通人 增加 “盔甲” 这个装饰；现在我想再给他增加 “光束手套”，希望额外增加 50 点防御值。 Step 1：拷贝一份decorateArmour方法，改名为decorateLight，同时修改防御值的属性： 1234567891011function decorateLight(target, key, descriptor) &#123; const method = descriptor.value; let moreAtk = 50; let ret; descriptor.value = (...args)=&gt;&#123; args[1] += moreAtk; ret = method.apply(target, args); return ret; &#125; return descriptor;&#125; Step 2：直接在init方法上添加装饰语法： 123456789.... @decorateArmour @decorateLight init(def,atk,hp)&#123; this.def = def; // 防御值 this.atk = atk; // 攻击力 this.hp = hp; // 血量 &#125; ... 最后的代码如下： 123456789101112131415161718192021222324252627282930...function decorateLight(target, key, descriptor) &#123; const method = descriptor.value; let moreAtk = 50; let ret; descriptor.value = (...args)=&gt;&#123; args[1] += moreAtk; ret = method.apply(target, args); return ret; &#125; return descriptor;&#125;class Man&#123; constructor(def = 2,atk = 3,hp = 3)&#123; this.init(def,atk,hp); &#125; @decorateArmour @decorateLight init(def,atk,hp)&#123; this.def = def; // 防御值 this.atk = atk; // 攻击力 this.hp = hp; // 血量 &#125;...&#125;var tony = new Man();console.log(`当前状态 ===&gt; $&#123;tony&#125;`);//输出：当前状态 ===&gt; 防御力:102,攻击力:53,血量:3 在这里你就能看出装饰模式的优势了，它可以对某个方法进行叠加使用，对原类的侵入性非常小，只是增加一行@decorateLight而已，可以方便地增删；（同时还可以复用） 2.3、【Demo 3】对类的装饰：增加飞行能力按文章 装饰模式所言，装饰模式有两种：纯粹的装饰模式 和 半透明的装饰模式。 上述的两个 demo 中所使用的应该是 纯粹的装饰模式，它并不增加对原有类的接口；下面要讲 demo 是给普通人增加“飞行”能力，相当于给类新增一个方法，属于 半透明的装饰模式，有点儿像适配器模式的样子。 Step 1：增加一个方法： 1234567891011function addFly(canFly)&#123; return function(target)&#123; target.canFly = canFly; let extra = canFly ? '(技能加成:飞行能力)' : ''; let method = target.prototype.toString; target.prototype.toString = (...args)=&gt;&#123; return method.apply(target.prototype,args) + extra; &#125; return target; &#125;&#125; Step 2：这个方法将直接去装饰类： 12345678910111213141516171819202122232425262728293031323334...// 3function addFly(canFly)&#123; return function(target)&#123; target.canFly = canFly; let extra = canFly ? '(技能加成:飞行能力)' : ''; let method = target.prototype.toString; target.prototype.toString = (...args)=&gt;&#123; return method.apply(target.prototype,args) + extra; &#125; return target; &#125;&#125;@addFly(true)class Man&#123; constructor(def = 2,atk = 3,hp = 3)&#123; this.init(def,atk,hp); &#125; @decorateArmour @decorateLight init(def,atk,hp)&#123; this.def = def; // 防御值 this.atk = atk; // 攻击力 this.hp = hp; // 血量 &#125; ...&#125;...console.log(`当前状态 ===&gt; $&#123;tony&#125;`);// 输出：当前状态 ===&gt; 防御力:102,攻击力:53,血量:3(技能加成:飞行能力) 作用在方法上的 decorator 接收的第一个参数（target ）是类的 prototype；如果把一个decorator 作用到类上，则它的第一个参数 target 是 类本身。（参考 Decorators in ES7） 3、使用原生 JS 实现装饰器模式关于如何用现有标准的原生 JS 实现的装饰模式，可参考译文JavaScript设计模式：装饰者模式，这是一篇值得一读的文章，深入浅出。 这里用 ES5 重写一下上面的 Demo 1的场景，简略说一下关键点： Man 是具体的类，Decorator 是针对 Man 的装饰器基类 具体的装饰类 DecorateArmour 典型地使用 prototype 继承方式 继承自Decorator 基类； 基于 IOC（控制反转）思想 ，Decorator 是接受 Man 类，而不是自己创建 Man类； 最后代码是： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 首先我们要创建一个基类function Man()&#123; this.def = 2; this.atk = 3; this.hp = 3;&#125;// 装饰者也需要实现这些方法，遵守 Man 的接口Man.prototype=&#123; toString:function()&#123; return `防御力:$&#123;this.def&#125;,攻击力:$&#123;this.atk&#125;,血量:$&#123;this.hp&#125;`; &#125;&#125;// 创建装饰器，接收 Man 对象作为参数。var Decorator = function(man)&#123; this.man = man;&#125;// 装饰者要实现这些相同的方法Decorator.prototype.toString = function()&#123; return this.man.toString();&#125;// 继承自装饰器对象// 创建具体的装饰器，也是接收 Man 作对参数var DecorateArmour = function(man)&#123; var moreDef = 100; man.def += moreDef; Decorator.call(this,man);&#125;DecorateArmour.prototype = new Decorator();// 接下来我们要为每一个功能创建一个装饰者对象，重写父级方法，添加我们想要的功能。DecorateArmour.prototype.toString = function()&#123; return this.man.toString();&#125;// 注意这里的调用方式// 构造器相当于“过滤器”，面向切面的var tony = new Man();tony = new DecorateArmour(tony);console.log(`当前状态 ===&gt; $&#123;tony&#125;`);// 输出：当前状态 ===&gt; 防御力:102,攻击力:3,血量:3 4、经典实现：LoggerAOP 的经典应用就是 日志系统 了，那么我们也用 ES7 的语法给钢铁侠打造一个日志系统吧。 下面是最终的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Created by jscon on 15/10/16. */let log = (type) =&gt; &#123; return (target, name, descriptor) =&gt; &#123; const method = descriptor.value; descriptor.value = (...args) =&gt; &#123; console.info(`($&#123;type&#125;) 正在执行: $&#123;name&#125;($&#123;args&#125;) = ?`); let ret; try &#123; ret = method.apply(target, args); console.info(`($&#123;type&#125;) 成功 : $&#123;name&#125;($&#123;args&#125;) =&gt; $&#123;ret&#125;`); &#125; catch (error) &#123; console.error(`($&#123;type&#125;) 失败: $&#123;name&#125;($&#123;args&#125;) =&gt; $&#123;error&#125;`); &#125; return ret; &#125; &#125;&#125;class IronMan &#123; @log('IronMan 自检阶段') check()&#123; return '检查完毕'; &#125; @log('IronMan 攻击阶段') attack()&#123; return '击倒敌人'; &#125; @log('IronMan 机体报错') error()&#123; throw 'Something is wrong!'; &#125;&#125;var tony = new IronMan();tony.check();tony.attack();tony.error();// 输出：// (IronMan 自检阶段) 正在执行: check() = ?// (IronMan 自检阶段) 成功 : check() =&gt; 检查完毕// (IronMan 攻击阶段) 正在执行: attack() = ?// (IronMan 攻击阶段) 成功 : attack() =&gt; 击倒敌人// (IronMan 机体报错) 正在执行: error() = ?// (IronMan 机体报错) 失败: error() =&gt; Something is wrong! Logger 方法的关键在于： 首先使用 const method = descriptor.value; 将原有方法提取出来，保障原有方法的纯净； 在 try..catch 语句是 调用 ret = method.apply(target, args);在调用之前之后分别进行日志汇报； 最后返回 return ret; 原始的调用结果 相信这套思路会给后续我们实现 AOP 模式提供良好的借鉴。 5、扩展：基于工厂模式当你想要一个有 3 种功能的钢铁侠，就得用 new 操作符 创建 4 个对象。这么做单调乏味又烦人，所以我们打算只调用一个方法就能创建出一部拥有所有功能的钢铁侠。 这就需要 工厂模式 了，工厂模式的官方定义是：在子类中对一个类的成员对象进行实例化。比如定义 decorateIronMan（person,feature） 方法，里面接受一个 Person 对象（而不是自己初始化）,相当于流水线生产了。 如何 结合装饰模式和工厂模式 提高代码效能，这篇优秀的译文 JavaScript设计模式：工厂模式 给出了详细的方法，这里不再赘述 ，强烈推荐阅读此文。 6、现在就想用？decorator 目前还只是一个提议，但是感谢 Babel ，我们现在就可以体验它了。首先，安装babel： 1npm install babel -g 然后，开启 decorator： 1babel --optional es7.decorators foo.js &gt; foo.es5.js babel 也提供了一个在线的 REPL ，勾选 experimental 选项，就可以了。 在 webstorm 中设置 babelStep 1 ：首先全局安装babel组件模块 1npm install -g babel Step 2 ：设置 scope （这一步可以省略） 命名 scope： 将文件添加到当前 scope： Step 3 ：设置 ES 版本 Step 4 ：添加 watcher arguments 内可以填写：$FilePathRelativeToProjectRoot$ --stage --out-file $FileNameWithoutExtension$-es5.js $FilePath$ . 如果需要 source-map，需要添加--source-map选项，同时在Output paths to refresh中填写 $FileNameWithoutExtension$-es5.js:$FileNameWithoutExtension$-es5.js.map 更多设置参考babel cli 7、总结虽然它是 ES7 的特性，但在 Babel 大势流行的今天，我们可以利用 Babel 来使用它。我们可以利用 Babel 命令行工具，或者 grunt、gulp、webpack 的 babel 插件来使用 Decorators。 上述的代码都可以直接放在 http://babeljs.io/repl/ 中运行查看结果； 关于 ES7 Decorators 的更有意思的玩法，你可以参见牛人实现的常用的 Decorators：core-decorators。以及 raganwald 的 如何用 Decorators 来实现 Mixin。 参考文献 Decorators in ES7：装饰者模式让你包装已有的方法，从而扩展已有函数。 JavaScript设计模式：装饰者模式：严重推荐，这一系列让你比较透彻明白设计模式在 JS 中的应用。 ES7 之 Decorators 实现 AOP 示例：如何实现一个简单的 AOP。 细说 ES7 JavaScript Decorators：讲解 ES7 Decorator的背后原理，就是使用了 Object.defineProperty 方法； How To Set Up the Babel Plugin in WebStorm：图文并茂，教你如何设置 babel. Rest 参数和参数默认值：ES6 为我们提供一种新的方式来创建可变参数的函数，Rest 参数和参数默认值 Exploring ES2016 Decorators：很完整的一个教程，里面涉及比较全面。 Traits with ES7 Decorators：相当于是介绍 traits-decorator 模块；]]></content>
      <categories>
        <category>Web开发</category>
      </categories>
      <tags>
        <tag>decorator</tag>
        <tag>es7</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从达标到卓越 —— API 设计之道「淘宝FED前端团队」]]></title>
    <url>%2Fblog%2F2017-06-02.from-done-to-better%2F</url>
    <content type="text"><![CDATA[从达标到卓越 —— API 设计之道作者: 法海 发表于: 2017-02-16 新技术层出不穷，长江后浪推前浪，而浪潮褪去后能留下来的，是一些经典的设计思想。 在前端界，以前有远近闻名的 jQuery，近来有声名鹊起的 Vue.js。这两者叫好又叫座的原因固然有很多，但是其中有一个共同特质不可忽视，那便是它们的 API 设计 非常优雅。 因此这次我想来谈个大课题 —— API 设计之道。 讨论内容的定义域本文并不是《jQuery API 赏析》，当我们谈论 API 的设计时，不只局限于讨论「某个框架应该如何设计暴露出来的方法」。作为程序世界分治复杂逻辑的基本协作手段，广义的 API 设计涉及到我们日常开发中的方方面面。 最常见的 API 暴露途径是函数声明（Function Signiture），以及属性字段（Attributes）；而当我们涉及到前后端 IO 时，则需要关注通信接口的数据结构（JSON Schema）；如果还有异步的通信，那么事件（Events）或消息（Message）如何设计也是个问题；甚至，依赖一个包（Package）的时候，包名本身就是接口，你是否也曾碰到过一个奇葩的包名而吐槽半天？ 总之，「API 设计」不只关乎到框架或库的设计者，它和每个开发者息息相关。 提纲挈领有一个核心问题是，我们如何评判一个 API 的设计算「好」？在我看来，一言以蔽之，易用。 那「易用」又是什么呢？我的理解是，只要能够足够接近人类的日常语言和思维，并且不需要引发额外的大脑思考，那就是易用。 Don’t make me think. 具体地，我根据这些年来碰到的大量（反面和正面）案例，归纳出以下这些要点。按照要求从低到高的顺序如下： 达标：词法和语法 正确拼写 准确用词 注意单复数 不要搞错词性 处理缩写 用对时态和语态 进阶：语义和可用性 单一职责 避免副作用 合理设计函数参数 合理运用函数重载 使返回值可预期 固化术语表 遵循一致的 API 风格 卓越：系统性和大局观 版本控制 确保向下兼容 设计扩展机制 控制 API 的抽象级别 收敛 API 集 发散 API 集 制定 API 的支持策略 （本文主要以 JavaScript 作为语言示例。） 达标：词法和语法高级语言和自然语言（英语）其实相差无几，因此正确地使用（英语的）词法和语法是程序员最基本的素养。而涉及到 API 这种供用户调用的代码时，则尤其重要。 但事实上，由于亚洲地区对英语的掌握能力普遍一般……所以现实状况并不乐观 —— 如果以正确使用词法和语法作为达标的门槛，很多 API 都没能达标。 正确拼写正确地拼写一个单词是底线，这一点无需赘述。然而 API 中的各种错别字现象仍屡见不鲜，即使是在我们阿里这样的大公司内。 曾经有某个 JSON 接口（mtop）返回这样一组店铺数据，以在前端模板中渲染： 12345678910// json[ &#123; "shopBottom": &#123; "isTmall": "false", "shopLevel": "916", "shopLeveImg": "//xxx.jpg" &#125; &#125;] 乍一看平淡无奇，结果我调试了小半天都没能渲染出店铺的「店铺等级标识图片」，即shopLevelImg 字段。问题到底出在了哪里？ 眼细的朋友可能已经发现，接口给的字段名是 shopLeveImg，少了一个 l，而在其后字母 I的光辉照耀下，肉眼很难分辨出这个细节问题。 拼错单词的问题真的是太普遍了，再比如： 某个叫做 toast 的库，package.json 中的 name 写成了 taost。导致在 npm 中没能找到这个包。 某个跑马灯组件，工厂方法中的一个属性错将 panel 写成了 pannel。导致以正确的属性名初始化时代码跑不起来。 某个 URL（www.ruanyifeng.com/blog/2017/01/entainment.html）中错将entertainment 写成了 entainment……这倒没什么大影响，只是 URL 发布后就改不了了，留下了错别字不好看。 …… 注意到，这些拼写错误经常出现在 字符串 的场景中。不同于变量名，IDE 无法检查字符串中的单词是否科学、是否和一些变量名一致，因此，我们在对待一些需要公开出去的 API 时，需要尤其注意这方面的问题；另一方面，更认真地注意 IDE 的 typo 提示（单词拼写错误提示），也会对我们产生很大帮助。 准确用词我们知道，中英文单词的含义并非一一对应，有时一个中文意思可以用不同的英文单词来解释，这时我们需要选择使用恰当的准确的词来描述。 比如中文的「消息」可以翻译为 message、notification、news 等。虽然这几个不同的单词都可以有「消息」的意思，但它们在用法和语境场景上存在着细微差异： message：一般指双方通信的消息，是内容载体。而且经常有来有往、成对出现。比如 postMessage() 和 receiveMessage()。 notification：经常用于那种比较短小的通知，现在甚至专指 iOS / Android 那样的通知消息。比如 new NotificationManager()。 news：内容较长的新闻消息，比 notification 更重量级。比如 getTopNews()。 feed：自从 RSS 订阅时代出现的一个单词，现在 RSS 已经日薄西山，但是 feed 这个词被用在了更多的地方。其含义只可意会不可言传。比如 fetchWeitaoFeeds()。 所以，即使中文意思大体相近，也要准确地用词，从而让读者更易理解 API 的作用和 上下文场景。 有一个正面案例，是关于 React 的。（在未使用 ES2015 的）React 中，有两个方法叫做： 12345678React.createClass(&#123; getDefaultProps: function() &#123; // return a dictionary &#125;, getInitialState: function() &#123; // return a dictionary either &#125;&#125;); 它们的作用都是用来定义初始化的组件信息，返回值的类型也都一样，但是在方法名上却分别用了 default 和 initial 来修饰，为什么不统一为一个呢？ 原因和 React 的机制有关： props 是指 Element 的属性，要么是不存在某个属性值后来为它赋值，要么是存在属性的默认值后来将其覆盖。所以这种行为，default 是合理的修饰词。 state 是整个 Component 状态机中的某一个特定状态，既然描述为了状态机，那么状态和状态之间是互相切换的关系。所以对于初始状态，用 initial 来修饰。 就这么个小小的细节，就可一瞥 React 本身的机制，足以体现 API 设计者的智慧。 另外，最近我还碰到了这样一组事件 API： 12345// event name 1page.emit('pageShowModal');// event name 2page.emit('pageCloseModal'); 这两个事件显然是一对正反义的动作，在上述案例中，表示「显示窗口」时使用了 show，表示「关闭窗口」时使用了 close，这都是非常直觉化的直译。而事实上，成对出现的词应该是：show &amp; hide、open &amp; close。 因此这里必须强调：成对出现的正反义词不可混用。在程序世界经常成对出现的词还有： in &amp; out on &amp; off previous &amp; next forward &amp; backward success &amp; failure … 总之，我们可以试着扩充英语的词汇量，使用合适的词，这对我们准确描述 API 有很大的帮助。 注意单复数所有涉及到诸如数组（Array）、集合（Collection）、列表（List）这样的数据结构，在命名时都要使用复数形式： 123456789101112var shopItems = [ // ...];export function getShopItems() &#123; // return an array&#125;// failexport function getShopItem() &#123; // unless you really return a non-array&#125; 现实往往出人意表地糟糕，前不久刚改一个项目，我就碰到了这样的写法： 1234567class MarketFloor extends Component &#123; state = &#123; item: [ &#123;&#125; ] &#125;;&#125; 这里的 item 实为一个数组，即使它内部只有一个成员。因此应该命名为 items 或itemList，无论如何，不应该是表示单数的 item。 同时要注意，在复数的风格上保持一致，要么所有都是 -s，要么所有都是 -list。 反过来，我们在涉及到诸如字典（Dictionary）、表（Map）的时候，不要使用复数！ 123456// failvar EVENT_MAPS = &#123; MODAL_WILL_SHOW: 'modalWillShow', MODAL_WILL_HIDE: 'modalWillHide', // ...&#125;; 虽然这个数据结构看上去由很多 key-value 对组成，是个类似于集合的存在，但是「map」本身已经包含了这层意思，不需要再用复数去修饰它。 不要搞错词性另外一个容易犯的低级错误是搞错词性，即命名时拎不清名词、动词、形容词…… 1234asyncFunc(&#123; success: function() &#123;&#125;, fail: function() &#123;&#125;&#125;); success 算是一个在程序界出镜率很高的词了，但是有些同学会搞混，把它当做动词来用。在上述案例中，成对出现的单词其词性应该保持一致，这里应该写作 succeed 和 fail；当然，在这个语境中，最好遵从惯例，使用名词组合 success 和 failure。 这一对词全部的词性如下： n. 名词：success, failure v. 动词：succeed, fail adj. 形容词：successful, failed（无形容词，以过去分词充当） adv. 副词：successfully, fail to do sth.（无副词，以不定式充当） 注意到，如果有些词没有对应的词性，则考虑变通地采用其他形式来达到同样的意思。 所以，即使我们大部分人都知道：方法命名用动词、属性命名用名词、布尔值类型用形容词（或等价的表语），但由于对某些单词的词性不熟悉，也会导致最终的 API 命名有问题，这样的话就很尴尬了。 处理缩写关于词法最后一个要注意的点是缩写。有时我们经常会纠结，首字母缩写词（acronym）如 DOM、SQL 是用大写还是小写，还是仅首字母大写，在驼峰格式中又该怎么办…… 对于这个问题，简单不易混淆的做法是，首字母缩写词的所有字母均大写。（如果某个语言环境有明确的业界惯例，则遵循惯例。） 12345// beforeexport function getDomNode() &#123;&#125;// afterexport function getDOMNode() &#123;&#125; 在经典前端库 KISSY 的早期版本中，DOM 在 API 中都命名为 dom，驼峰下变为 Dom；而在后面的版本内统一写定为全大写的 DOM。 另外一种缩写的情况是对长单词简写（shortened word），如 btn (button)、chk (checkbox)、tpl (template)。这要视具体的语言规范 / 开发框架规范而定。如果什么都没定，也没业界惯例，那么把单词写全了总是不会错的。 用对时态和语态由于我们在调用 API 时一般类似于「调用一条指令」，所以在语法上，一个函数命名是祈使句式，时态使用一般现在时。 但在某些情况下，我们需要使用其他时态（进行时、过去时、将来时）。比如，当我们涉及到 生命周期、事件节点。 在一些组件系统中，必然涉及到生命周期，我们来看一下 React 的 API 是怎么设计的： 12345export function componentWillMount() &#123;&#125;export function componentDidMount() &#123;&#125;export function componentWillUpdate() &#123;&#125;export function componentDidUpdate() &#123;&#125;export function componentWillUnmount() &#123;&#125; React 划分了几个关键的生命周期节点（mount, update, unmount, …），以将来时和过去时描述这些节点片段，暴露 API。注意到一个小细节，React 采用了 componentDidMount这种过去时风格，而没有使用 componentMounted，从而跟 componentWillMount 形成对照组，方便记忆。 同样地，当我们设计事件 API 时，也要考虑使用合适的时态，特别是希望提供精细的事件切面时。或者，引入 before、after 这样的介词来简化： 12345678// will renderComponent.on('beforeRender', function() &#123;&#125;);// now renderingComponent.on('rendering', function() &#123;&#125;);// has renderedComponent.on('afterRender', function() &#123;&#125;); 另一方面是关于语态，即选用主动语态和被动语态的问题。其实最好的原则就是 尽量避免使用被动语态。因为被动语态看起来会比较绕，不够直观，因此我们要将被动语态的 API 转换为主动语态。 写成代码即形如： 12345// passive voice, make me confusedobject.beDoneSomethingBy(subject);// active voice, much more clear nowsubject.doSomething(object); 进阶：语义和可用性说了那么多词法和语法的注意点，不过才是达标级别而已。确保 API 的可用性和语义才使 API 真正「可用」。 无论是友好的参数设置，还是让人甜蜜蜜的语法糖，都体现了程序员的人文关怀。 单一职责单一职责是软件工程中一条著名的原则，然而知易行难，一是我们对于具体业务逻辑中「职责」的划分可能存在难度，二是部分同学仍没有养成贯彻此原则的习惯。 小到函数级别的 API，大到整个包，保持单一核心的职责都是很重要的一件事。 123456// failcomponent.fetchDataAndRender(url, template);// goodvar data = component.fetchData(url);component.render(data, template); 如上，将混杂在一个大坨函数中的两件独立事情拆分出去，保证函数（function）级别的职责单一。 更进一步地，（假设）fetchData 本身更适合用另一个类（class）来封装，则对原来的组件类 Component 再进行拆分，将不属于它的取数据职责也分离出去： 1234567891011121314class DataManager &#123; fetchData(url) &#123;&#125;&#125;class Component &#123; constructor() &#123; this.dataManager = new DataManager(); &#125; render(data, template) &#123;&#125;&#125;// more code, less responsibilityvar data = component.dataManager.fetchData(url);component.render(data, template); 在文件（file）层面同样如此，一个文件只编写一个类，保证文件的职责单一（当然这对很多语言来说是天然的规则）。 最后，视具体的业务关联度而决定，是否将一簇文件做成一个包（package），或是拆成多个。 避免副作用严格「无 副作用) 的编程」几乎只出现在纯函数式程序中，现实中的 OOP 编程场景难免触及副作用。因此在这里所说的「避免副作用」主要指的是： 函数本身的运行稳定可预期。 函数的运行不对外部环境造成意料外的污染。 对于无副作用的纯函数而言，输入同样的参数，执行后总能得到同样的结果，这种幂等性使得一个函数无论在什么上下文中运行、运行多少次，最后的结果总是可预期的 —— 这让用户非常放心，不用关心函数逻辑的细节、考虑是否应该在某个特定的时机调用、记录调用的次数等等。希望我们以后设计的 API 不会出现这个案例中的情况： 12345// return x.x.x.1 while call it oncethis.context.getSPM();// return x.x.x.2 while call it twicethis.context.getSPM(); 在这里，getSPM() 用来获取每个链接唯一的 SPM 码（SPM 是阿里通用的埋点统计方案）。但是用法却显得诡异：每调用一次，就会返回一个不同的 SPM 串，于是当我们需要获得几个 SPM 时，就会这样写： 123var spm1 = this.context.getSPM();var spm2 = this.context.getSPM();var spm3 = this.context.getSPM(); 虽然在实现上可以理解 —— 此函数内部维护了一个计数器，每次返回一个自增的 SPM D 位，但是 这样的实现方式与这个命名看似是幂等的 getter 型函数完全不匹配，换句话说，这使得这个 API 不可预期。 如何修改之？一种做法是，不改变此函数内部的实现，而是将 API 改为 Generator 式的风格，通过形如 SPMGenerator.next() 接口来获取自增的 SPM 码。 另一种做法是，如果要保留原名称，可以将函数签名改为 getSPM(spmD)，接受一个自定义的 SPM D 位，然后返回整个 SPM 码。这样在调用时也会更明确。 除了函数内部的运行需可预期外，它对外部一旦造成不可预期的污染，那么影响将更大，而且更隐蔽。 对外部造成污染一般是两种途径：一是在函数体内部直接修改外部作用域的变量，甚至全局变量；二是通过修改实参间接影响到外部环境，如果实参是引用类型的数据结构。 曾经也有发生因为对全局变量操作而导致整个容器垮掉的情况，这里就不再展开。 如何防止此类副作用发生？本质上说，需要控制读写权限。比如： 模块沙箱机制，严格限定模块对外部作用域的修改； 对关键成员作访问控制（access control），冻结写权限等等。 合理设计函数参数对一个函数来说，「函数签名」（Function Signature）比函数体本身更重要。函数名、参数设置、返回值类型，这三要素构成了完整的函数签名。而其中，参数设置对用户来说是接触最频繁，也最为关心的部分。 那如何优雅地设计函数的入口参数呢？我的理解是这样几个要点： 优化参数顺序。相关性越高的参数越要前置。 这很好理解，相关性越高的参数越重要，越要在前面出现。其实这还有两个隐含的意思，即可省略的参数后置，以及 为可省略的参数设定缺省值。对某些语言来说（如 C++），调用的时候如果想省略实参，那么一定要为它定义缺省值，而带缺省值的参数必须后置，这是在编译层面就规定死的。而对另一部分灵活的语言来说（如 JS），将可省参数后置同样是最佳实践。 1234567891011// badfunction renderPage(pageIndex, pageData) &#123;&#125;renderPage(0, &#123;&#125;);renderPage(1, &#123;&#125;);// goodfunction renderPage(pageData, pageIndex = 0) &#123;&#125;renderPage(&#123;&#125;);renderPage(&#123;&#125;, 1); 第二个要点是控制参数个数。用户记不住过多的入口参数，因此，参数能省略则省略，或更进一步，合并同类型的参数。 由于可以方便地创建 Object 这种复合数据结构，合并参数的这种做法在 JS 中尤为普遍。常见的情况是将很多配置项都包成一个配置对象： 12345678910// traditional$.ajax(url, params, success);// or$.ajax(&#123; url, params, success, failure&#125;); 这样做的好处是： 用户虽然仍需记住参数名，但不用再关心参数顺序。 不必担心参数列表过长。将参数合并为字典这种结构后，想增加多少参数都可以，也不用关心需要将哪些可省略的参数后置的问题。 当然，凡事有利有弊，由于缺乏顺序，就无法突出哪些是最核心的参数信息；另外，在设定参数的默认值上，会比参数列表的形式更繁琐。因此，需要兼顾地使用最优的办法来设计函数参数，为了同一个目的：易用。 合理运用函数重载谈到 API 的设计，尤其是函数的设计，总离不开一个机制：重载（overload）。 对于强类型语言来说，重载是个很 cool 的功能，能够大幅减少函数名的数量，避免命名空间的污染。然而对于弱类型语言而言，由于不需要在编译时做 type-binding，函数在调用阶段想怎么传实参都行……所以重载在这里变得非常微妙。以下着重谈一下，什么时候该选择重载，什么时候又不该。 12345Element getElementById(String: id)HTMLCollection getElementsByClassName(String: names)HTMLCollection getElementsByTagName(String: name) 以上三个函数是再经典不过的 DOM API，而在当初学习它们的时候（从 Java 思维转到 JS 思维）我就在想这两个问题： 为什么要设计成 getSomethingBySomething 这么复杂结构的名字，而不是使用getSomething 做重载？ 这三个函数只有 getElementById 是单数形式，为何不设计为返回 HTMLCollection（即使只返回一个成员也可以包一个 Collection 嘛），以做成复数形式的函数名从而保持一致性？ 两个问题中，如果第二个问题能解决，那么这三个函数的结构将完全一致，从而可以考虑解决第一个问题。 先来看问题二。稍微深入下 DOM 知识后就知道，id 对于整个 DOM 来说必须是唯一的，因此在理论上 getElementsById（注意有复数）将永远返回仅有 0 或 1 个成员的 Collection，这样一来用户的调用方式将始终是 var element = getElementsById(id)[0]，而这是非常荒谬的。所以 DOM API 设计得没问题。 既然问题二无解，那么自然这三个函数没法做成一个重载。退一步说，即使问题二能解决，还存在另外一个麻烦：它们的入口参数都是一样的，都是 String！对于强类型语言来说，参数类型和顺序、返回值统统一样的情况下，压根无法重载。因为编译器无法通过任何一个有效的特征，来执行不同的逻辑！ 所以，如果入口参数无法进行有效区分，不要选择重载。 当然，有一种奇怪的做法可以绕过去： 123456789101112// failfunction getElementsBy(byWhat, name) &#123; switch(byWhat) &#123; case 'className': // ... case 'tagName': // ... &#125;&#125;getElementsBy('tagName', name);getElementsBy('className', name); 一种在风格上类似重载的，但实际是在运行时走分支逻辑的做法……可以看到，API 的信息总量并没降低。不过话不能说死，这种风格在某些特定场景也有用武之地，只是多数情况下并不推荐。 与上述风格类似的，是这样一种做法： 12345// get elements by tag-name by defaultHTMLCollection getElements(String: name)// if you add a flag, it goes by class-nameHTMLCollection getElements(String: name, Boolean: byClassName) 「将 flag 标记位作为了重载手段」—— 在早期微软的一些 API 中经常能见到这样的写法，可以说一旦离开了文档就无法编码，根本不明白某个 Boolean 标记位是用来干嘛的，这大大降低了用户的开发体验，以及代码可读性。 这样看起来，可重载的场景真是太少了！也不尽然，在我看来有一种场景很适合用重载：批量处理。 123Module handleModules(Module: module)Collection&lt;Module&gt; handleModules(Collection&lt;Module&gt;: modules) 当用户经常面临处理一个或多个不确定数量的对象时，他可能需要思考和判断，什么时候用单数 handleModule、什么时候用复数 handleModules。将这种类型的操作重载为一个（大抵见于 setter 型操作），同时支持单个和批量的处理，可以降低用户的认知负担。 所以，在合适的时机重载，否则宁愿选择「函数名结构相同的多个函数」。原则是一样的，保证逻辑正确的前提下，尽可能降低用户负担。 对了，关于 getElements 那三个 API，它们最终的进化版本回到了同一个函数：querySelector(selectors)。 使返回值可预期函数的易用性体现在两方面：入口和出口。上面已经讲述了足够多关于入口的设计事项，这一节讲出口：函数返回值。 对于 getter 型的函数来说，调用的直接目的就是为了获得返回值。因此我们要让返回值的类型和函数名的期望保持一致。 12345678// expect 'a.b.c.d'function getSPMInString() &#123; // fail return &#123; a, b, c, d &#125;;&#125; 从这一点上来讲，要慎用 ES2015 中的新特性「解构赋值」。 而对于 setter 型的函数，调用的期望是它能执行一系列的指令，然后去达到一些副作用，比如存文件、改写变量值等等。因此绝大多数情况我们都选择了返回 undefined / void —— 这并不总是最好的选择。 回想一下，我们在调用操作系统的命令时，系统总会返回「exit code」，这让我们能够获知系统命令的执行结果如何，而不必通过其他手段去验证「这个操作到底生效了没」。因此，创建这样一种返回值风格，或可一定程度增加健壮性。 另外一个选项，是让 setter 型 API 始终返回 this。这是 jQuery 为我们带来的经典启示 —— 通过返回 this，来产生一种「链式调用（chaining）」的风格，简化代码并且增加可读性： 1234$('div') .attr('foo', 'bar') .data('hello', 'world') .on('click', function() &#123;&#125;); 最后还有一个异类，就是异步执行的函数。由于异步的特性，对于这种需要一定延时才能得到的返回值，只能使用 callback 来继续操作。使用 Promise 来包装它们尤为必要。对异步操作都返回一个 Promise，使整体的 API 风格更可预期。 固化术语表在前面的词法部分中曾经提到「准确用词」，但即使我们已经尽量去用恰当的词，在有些情况下仍然不免碰到一些难以抉择的尴尬场景。 比如，我们经常会看到 pic 和 image、path 和 url 混用的情况，这两组词的意思非常接近（当然严格来说 path 和 url 的意义是明确不同的，在此暂且忽略），稍不留神就会产生 4 种组合…… picUrl picPath imageUrl imagePath 更糟糕的情况是 imgUrl、picUri、picURL…… 所以，在一开始就要 产出术语表，包括对缩写词的大小写如何处理、是否有自定义的缩写词等等。一个术语表可以形如： 标准术语 含义 禁用的非标准词 pic 图片 image, picture path 路径 URL, url, uri on 绑定事件 bind, addEventListener off 解绑事件 unbind, removeEventListener emit 触发事件 fire, trigger module 模块 mod 不仅在公开的 API 中要遵守术语表规范，在局部变量甚至字符串中都最好按照术语表来。 1234page.emit('pageRenderRow', &#123; index: this.props.index, modList: moduleList&#125;); 比如这个我最近碰到的案例，同时写作了 modList 和 moduleList，这就有点怪怪的。 另外，对于一些创造出来的、业务特色的词汇，如果不能用英语简明地翻译，就直接用拼音： 淘宝 Taobao 微淘 Weitao 极有家 Jiyoujia …… 在这里，千万不要把「微淘」翻译为 MicroTaobao……当然，专有词已经有英文名的除外，如 Tmall。 遵循一致的 API 风格这一节算得上是一个复习章节。词法、语法、语义中的很多节都指向同一个要点：一致性。 一致性可以最大程度降低信息熵。 好吧，这句话不是什么名人名言，就是我现编的。总而言之，一致性能大大降低用户的学习成本，并对 API 产生准确的预期。 在词法上，提炼术语表，全局保持一致的用词，避免出现不同的但是含义相近的词。 在语法上，遵循统一的语法结构（主谓宾顺序、主被动语态），避免天马行空的造句。 在语义上，合理运用函数的重载，提供可预期的甚至一致类型的函数入口和出口。 甚至还可以一致得更细节些，只是举些例子： 打 log 要么都用中文，要么都用英文。 异步接口要么都用回调，要么都改成 Promise。 事件机制只能选择其一：object.onDoSomething = func 或 object.on(&#39;doSomething&#39;, func)。 所有的 setter 操作必须返回 this。 …… 一份代码写得再怎么烂，把某个单词都拼成一样的错误，也好过这个单词只出现一次错误。 是的，一致性，再怎么强调都不为过。 卓越：系统性和大局观不管是大到发布至业界，或小到在公司内跨部门使用，一组 API 一旦公开，整体上就是一个产品，而调用方就是用户。所谓牵一发而动全身，一个小细节可能影响整个产品的面貌，一个小改动也可能引发整个产品崩坏。因此，我们一定要站在全局的层面，甚至考虑整个技术环境，系统性地把握整个体系内 API 的设计，体现大局观。 版本控制80% 的项目开发在版本控制方面做得都很糟糕：随心所欲的版本命名、空洞诡异的提交信息、毫无规划的功能更新……人们显然需要一段时间来培养规范化开发的风度，但是至少得先保证一件事情： 在大版本号不变的情况下，API 保证向前兼容。 这里说的「大版本号」即「语义化版本命名」&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt; 中的第一位 &lt;major&gt;位。 这一位的改动表明 API 整体有大的改动，很可能不兼容，因此用户对大版本的依赖改动会慎之又慎；反之，如果 API 有不兼容的改动，意味着必须修改大版本号，否则用户很容易出现在例行更新依赖后整个系统跑不起来的情况，更糟糕的情况则是引发线上故障。 如果这种情况得不到改善，用户们就会选择 永远不升级依赖，导致更多的潜在问题。久而久之，最终他们便会弃用这些产品（库、中间件、whatever）。 所以，希望 API 的提供者们以后不会再将大版本锁定为 0。更多关于「语义化版本」的内容，请参考我的另一篇文章《论版本号的正确打开方式》。 确保向下兼容如果不希望对客户造成更新升级方面的困扰，我们首先要做好的就是确保 API 向下兼容。 API 发生改动，要么是需要提供新的功能，要么是为之前的糟糕设计买单……具体来说，改动无外乎：增加、删除、修改 三方面。 首先是删除。不要轻易删除公开发布的 API，无论之前写得多么糟糕。如果一定要删除，那么确保正确使用了「Deprecated」： 对于某个不想保留的可怜 API，先不要直接删除，将其标记为 @deprecated 后置入下一个小版本升级（比如从 1.0.2 到 1.1.0）。 123456789/*** @deprecated*/export function youWantToRemove(foo, bar) &#123;&#125;/*** This is the replacement.*/export function youWantToKeep(foo) &#123;&#125; 并且，在 changelog 中明确指出这些 API 即将移除（不推荐使用，但是目前仍然能用）。 之后，在下一个 大版本 中（比如 1.1.0 到 2.0.0）删除标记为 @deprecated 的部分，同时在 changelog 中指明它们已删除。 其次是 API 的修改。如果我们仅仅是修复 bug、重构实现、或者添加一些小特性，那自然没什么可说的；但是如果想彻底修改一个 API……比如重做入口参数、改写业务逻辑等等，建议的做法是： 确保原来的 API 符合「单一职责」原则，如果不是则修改之。 增加一个全新的 API 去实现新的需求！由于我们的 API 都遵循「单一职责」，因此一旦需要彻底修改 API，意味着新需求和原来的职责已经完全无法匹配，不如干脆新增一个 API。 视具体情况选择保留或移除旧 API，进入前面所述「删除 API」的流程。 最后是新增 API。事实上，即使是只加代码不删代码，整体也不一定是向下兼容的。有一个经典的正面案例是： 12345// modern browsersdocument.hidden == false;// out-of-date browsersdocument.hidden == undefined; 浏览器新增的一个 API，用以标记「当前文档是否可见」。直观的设计应该是新增document.visible 这样的属性名……问题是，在逻辑上，文档默认是可见的，即document.visible 默认为 true，而不支持此新属性的旧浏览器返回 document.visible == undefined，是个 falsy 值。因此，如果用户在代码中简单地以： 123if (document.visible) &#123; // do some stuff&#125; 做特征检测的话，在旧浏览器中就会进入错误的条件分支……而反之，以 document.hiddenAPI 来判断，则是向下兼容的。 设计扩展机制毫无疑问，在保证向下兼容的同时，API 需要有一个对应的扩展机制以可持续发展 —— 一方面便于开发者自身增加功能，另一方面用户也能参与进来共建生态。 技术上来说，接口的扩展方式有很多，比如：继承（extend）、组合（mixin）、装饰（decorate）……选择没有对错，因为不同的扩展方式适用于不同的场景：在逻辑上确实存在派生关系，并且需要沿用基类行为同时自定义行为的，采用重量级的继承；仅仅是扩充一些行为功能，但是逻辑上压根不存在父子关系的，使用组合；而装饰手法更多应用于给定一个接口，将其包装成多种适用于不同场景新接口的情况…… 另一方面，对于不同的编程语言来说，由于不同的语言特性……静态、动态等，各自更适合用某几种扩展方式。所以，到底采用什么扩展办法，还是得视情况而定。 在 JS 界，有一些经典的技术产品，它们的扩展甚至已经形成生态，如： jQuery。耳熟能详的 $.fn.customMethod = function() {};。这种简单的 mixin 做法已经为 jQuery 提供了成千上万的插件，而 jQuery 自己的大部分 API 本身也是基于这个写法构建起来的。 React。React 自身已经处理了所有有关组件实例化、生命周期、渲染和更新等繁琐的事项，只要开发者基于 React.Component 来继承出一个组件类。对于一个 component system 来说，这是一个经典的做法。 Gulp。相比于近两年的大热 Webpack，个人认为 Gulp 更能体现一个 building system 的逻辑 —— 定义各种各样的「任务」，然后用「管道」将它们串起来。一个 Gulp 插件也是那么的纯粹，接受文件流，返回文件流，如是而已。 Koa。对于主流的 HTTP Server 来说，中间件的设计大同小异：接受上一个 request，返回一个新的 response。而对天生 Promise 化的 Koa 来说，它的中间件风格更接近于 Gulp 了，区别仅在于一个是 file stream，一个是 HTTP stream。 不只是庞大的框架需要考虑扩展性，设计可扩展的 API 应该变成一种基本的思维方式。比如这个活生生的业务例子： 12345678910111213141516171819202122232425// json[ &#123; "type": "item", "otherAttrs": "foo" &#125;, &#123; "type": "shop", "otherAttrs": "bar" &#125;]// render logicswitch(feed.type) &#123; case 'item': console.log('render in item-style.'); break; case 'shop': console.log('render in shop-style.'); break; case 'other': default: console.log('render in other styles, maybe banner or sth.'); break;&#125; 根据不同的类型渲染一组 feeds 信息：商品模块、店铺模块，或是其他。某天新增了需求说要支持渲染天猫的店铺模块（多显示个天猫标等等），于是 JSON 接口直接新增一个type = &#39;tmallShop&#39; —— 这种接口改法很简单直观，但是并不好。在不改前端代码的情况下，tmallShop 类型默认进入 default 分支，导致奇奇怪怪的渲染结果。 考虑到 tmallShop 和 shop 之间是一个继承的关系，tmallShop 完全可以当一个普通的 shop来用，执行后者的所有逻辑。用 Java 的表达方式来说就是： 123// a tmallShop is a shopShop tmallShop = new TmallShop();tmallShop.doSomeShopStuff(); 将这个逻辑关系反映到 JSON 接口中，合理的做法是新增一个 subType 字段，用来标记tmallShop，而它的 type 仍然保持为 shop。这样一来，即使原来的前端代码完全不修改，仍然可以正常运行，除了无法渲染出一些天猫店铺的特征。 这里还有一个非常类似的正面案例，是 ABS 搭建系统（淘宝 FED 出品的站点搭建系统）设计的模块 JSON Schema： 12345678910// json[ &#123; "type": "string", "format": "enum" &#125;, &#123; "type": "string", "format": "URL" &#125;] 同样采用了 type 为主类型，而扩展字段在这里变成了 format，用来容纳一些扩展特性。在实际开发中，的确也很方便新增各种新的数据结构逻辑。 控制 API 的抽象级别API 能扩展的前提是什么？是接口足够抽象。这样才能够加上各种具体的定语、装饰更多功能。用日常语言举个例子： 123456789// abstractI want to go to a place.// when&#123;Today, Tomorrow, Jan. 1st&#125; I want to go to a place.// whereI want to go to &#123;mall, cafe, bed&#125;.// concrete, no extends any moreToday I want to go to a cafe for my business. 所以，在设计 API 时要高抽象，不要陷入具体的实现，不要陷入具体的需求，要高屋建瓴。 看个实际的案例：一个类 React Native 的页面框架想暴露出一个事件「滚动到第二屏」，以便页面开发者能监听这个事件，从而更好地控制页面资源的加载策略（比如首屏默认加载渲染、到第二屏之后再去加载剩下的资源）。 但是因为一些实现上的原因，页面框架还不能通过页面位移（offset）来精确地通知「滚动到了第二屏」，而只能判断「第二屏的第一个模块出现了」。于是这个事件没有被设计为secondScreenReached，而变成了 secondScreenFirstModuleAppear……虽然secondScreenFirstModuleAppear 不能精确定义 secondScreenReached，但是直接暴露这个具体的 API 实在太糟糕了，问题在于： 用户在依赖一个非常非常具体的 API，给用户造成了额外的信息负担。「第二屏的第一个模块出现了！」这很怪异，用户根本不关心模块的事情，用户关心的只是他是否到达了第二屏。 一旦页面框架能够真正通过页面位移来实现「滚动到第二屏」，如果我们暴露的是高抽象的 secondScreenReached，那么只需要更改一下这个接口的具体实现即可；反之，我们暴露的是很具体的 secondScreenFirstModuleAppear，就只能挨个通知用户：「你现在可以不用依赖这个事件了，改成我们新出的 secondScreenReached 吧！」 是的，抽象级别一般来说越高越好，将 API 设计成业务无关的，更通用，而且方便扩展。但是物极必反，对于像我这样的抽象控来说，最好能学会控制接口的抽象级别，将其保持在一个恰到好处的层次上，不要做无休止的抽象。 还是刚才的例子 secondScreenReached，我们还可以将其抽象成 targetScreenReached，可以支持到达首屏、到达第二屏、第三屏……的事件，这样是不是更灵活、更优雅呢？并没有 —— 抽象时一定要考虑到具体的业务需求场景，有些实现路径如果永远不可能走到，就没必要抽出来。比如这个例子中，没有人会去关心第三屏、第四屏的事件。 太高的抽象容易造成太多的层次，带来额外的耦合、通信等不同层次之间的沟通成本，这将会成为新的麻烦。对用户而言，也是额外的信息负担。 对于特定的业务来说，接口越抽象越通用，而越具体则越能解决特定问题。所以，思考清楚，API 面向的场景范围，避免懒惰设计，避免过度设计。 收敛 API 集对于一整个体系的 API 来说，用户面对的是这个整体集合，而不是其中某几个单一的 API。我们要保证集合内的 API 都在一致的抽象维度上，并且适当地合并 API，减小整个集合的信息量，酌情做减法。 产品开始做减法，便是对用户的温柔。 收敛近似意义的参数和局部变量。下面这样的一组 API 好像没什么不对，但是对强迫症来说一定产生了不祥的直觉： 12345export function selectTab(index) &#123;&#125;export function highlightTab(tabIndex) &#123;&#125;export function gotoPage(index) &#123;&#125; 又是 index 又是 tabIndex 的，或许还会有 pageIndex？诚然，函数形参和局部变量的命名对最终用户来说没有直接影响，但是这些不一致的写法仍然能反映到 API 文档中，并且，对开发者自身也会产生混淆。所以，选一个固定的命名风格，然后从一而终！如果忘了的话，回头看一下前文「固化术语表」这一节吧！ 收敛近似职责的函数。对用户暴露出太多的接口不是好事，但是一旦要合并不同的函数，是否就会破坏「单一职责」原则呢？ 不，因为「单一职责」本身也要看具体的抽象层次。以下这个例子和前文「合理运用函数重载」中的例子有相似之处，但具体又有所不同。 12345678910111213141516171819202122// a complex rendering processfunction renderPage() &#123; // too many APIs here renderHeader(); renderBody(); renderSidebar(); renderFooter();&#125;// now mergedfunction renderPage() &#123; renderSections([ 'header', 'body', 'sidebar', 'footer' ]);&#125;// call renderSectionfunction renderSections(sections) &#123;&#125;// and the real laborfunction renderSection(section) &#123;&#125; 类似于这样，避免暴露过多近似的 API，合理利用抽象将其合并，减小对用户的压力。 对于一个有清晰继承树的场景来说，收敛 API 显得更加自然且意义重大 —— 利用多态性（Polymorphism）构建 Consistent APIs。（以下例子来源于 Clean Code JS。） 12345678910111213// bad: type-checking herefunction travelToTexas(vehicle) &#123; if (vehicle instanceof Bicycle) &#123; vehicle.pedal(this.currentLocation, new Location('texas')); &#125; else if (vehicle instanceof Car) &#123; vehicle.drive(this.currentLocation, new Location('texas')); &#125;&#125;// coolfunction travelToTexas(vehicle) &#123; vehicle.move(this.currentLocation, new Location('texas'));&#125; 有一个将 API 收敛到极致的家伙恐怕大家都不会陌生：jQuery 的 $()。这个风格不正是 jQuery 当年的杀手级特性之一吗？ 如果 $() 能让我搞定这件事，就不要再给我 foo() 和 bar()。 收敛近似功能的包。再往上一级，我们甚至可以合并相近的 package。 淘宝 FED 的 Rax 体系（类 RN 框架）中，有基础的组件标签，如 &lt;Image&gt; (in @ali/rax-components)、&lt;Link&gt; (in @ali/rax-components)，也有一些增强功能的 package，如&lt;Picture&gt; (in @ali/rax-picture)、&lt;Link&gt; (in @ali/rax-spmlink)。 在这里，后者包之于前者相当于装饰了更多功能，是前者的增强版。而在实际应用中，也是推荐使用诸如 &lt;Picture&gt; 而禁止使用 &lt;Image&gt;。那么在这种大环境下，&lt;Image&gt; 等基础 API 的暴露就反而变得很扰民。可以考虑将增强包的功能完全合并入基础组件，即将 &lt;Picture&gt;并入 &lt;Image&gt;，用户只需面对单一的、标准的组件 API。 发散 API 集这听上去很荒谬，为什么一个 API 集合又要收敛又要发散？仅仅是为了大纲上的对称性吗？ 当然不是。存在这个小节是因为我有一个不得不提的案例，不适合放在其他段落，只能放在这里……不，言归正传，我们有时的确需要发散 API 集，提供几个看似接近的 API，以引导用户。因为 —— 虽然这听起来很荒谬 —— 某些情况下，API 其实不够用，但是用户 没有意识到 API 不够用，而是选择了混用、滥用。看下面这个例子： 123456789101112131415// the func is used hererequestAnimationFrame(() =&gt; &#123; // what? trigger an event? emitter.emit('moduleDidRenderRow');&#125;);// ...and thererequestAnimationFrame(() =&gt; &#123; // another one here, I guess rendering? this.setState(&#123; // ... &#125;);&#125;); 在重构一组代码时，我看到代码里充斥着 requestAnimationFrame()，这是一个比较新的全局 API，它会以接近 60 FPS 的速率延时执行一个传入的函数，类似于一个针对特定场景优化过的 setTimeout()，但它的初衷是用来绘制动画帧的，而不应该用在奇奇怪怪的场景中。 在深入地了解了代码逻辑之后，我认识到这里如此调用是为了「延时一丢丢执行一些操作」，避免阻塞主渲染线程。然而这种情况下，还不如直接调用 setTimeout() 来做延时操作。虽然没有太明确的语义，但是至少好过把自己伪装成一次动画的绘制。更可怕的是，据我所知 requestAnimationFrame() 的滥用不仅出现在这次重构的代码中，我至少在三个不同的库见过它的身影 —— 无一例外地，这些库和动画并没有什么关系。 （一个可能的推断是，调用 requestAnimationFrame(callback) 时不用指定 timeout 毫秒数，而 setTimeout(callback, timeout) 是需要的。似乎对很多用户来说，前者的调用方式更 cool？） 所以，在市面上有一些 API 好像是「偏方」一般的存在：虽然不知道为什么要这么用，但是……用它就对了！ 事实上，对于上面这个场景，最恰当的解法是使用一个更加新的 API，叫做requestIdleCallback(callback)。这个 API 从名字上看起来就很有语义：在线程空闲的时候再执行操作。这完全契合上述场景的需求，而且还自带底层的优化。 当然，由于 API 比较新，还不是所有的平台都能支持。即便如此，我们也可以先面向接口编程，自己做一个 polyfill： 1234// simple polyfillexport function requestIdleCallback(callback) =&gt; &#123; callback &amp;&amp; setTimeout(callback, 1e3 / 60);&#125;; 另一个经典的滥用例子是 ES2015 中的「Generator / yield」。 原本使用场景非常有限的生成器 Generator 机制被大神匠心独运地加以改造，包装成用来异步代码同步化的解决方案。这种做法自然很有创意，但是从语义用法上来说实在不足称道，让代码变得非常难读，并且带来维护隐患。与其如此，还不如仅仅使用 Promise。 令人欣慰的是，随后新版的 ES 即提出了新的异步代码关键字「async / await」，真正在语法层面解决了异步代码同步化的问题，并且，新版的 Node.js 也已经支持这种语法。 因此，我们作为 API 的开发者，一定要提供足够场景适用的 API，来引导我们的用户，不要让他们做出一些出人意料的「妙用」之举。 制定 API 的支持策略我们说，一组公开的 API 是产品。而产品，一定有特定的用户群，或是全球的开发者，或仅仅是跨部门的同事；产品同时有保质期，或者说，生命周期。 面向目标用户群体，我们要制定 API 的支持策略： 每一个大版本的支持周期是多久。 是否有长期稳定的 API 支持版本。（Long-term Support） 如何从旧版本升级。 老旧版本很可能还在运行，但维护者已经没时间精力再去管这些历史遗物，这时明确地指出某些版本不再维护，对开发者和用户都好。当然，同时别忘了给出升级文档，指导老用户如何迁移到新版本。还有一个更好的做法是，在我们开启一个新版本之际，就确定好上一个版本的寿命终点，提前知会到用户。 还有一个技术上的注意事项，那就是：大版本间最好有明确的隔离。对于一个复杂的技术产品来说，API 只是最终直接面向用户的接口，背后还有特定的环境、工具组、依赖包等各种支撑，互相之间并不能混用。 比如，曾经的经典前端库 KISSY。在业界技术方案日新月异的大潮下，KISSY 6 版本已经强依赖了 TNPM（阿里内网的 NPM）、DEF 套件组（淘宝 FED 的前端工具套件），虽然和之前的 1.4 版本相比 API 的变化并不大，但是仍然不能在老环境下直接使用 6 版本的代码库……这一定程度上降低了自由组合的灵活度，但事实上随着业务问题场景的复杂度提升，解决方案本身会需要更定制化，因此，将环境、工具等上下游关联物随代码一起打包，做成一整个技术方案，这正是业界的现状。 所以，隔离大版本，制定好 API 支持策略，让我们的产品更专业，让用户免去后顾之忧。 总结以上，便是我从业以来感悟到的一些「道」，三个进阶层次、几十个细分要点，不知有没有给读者您带来一丁点启发。 但实际上，大道至简。我一直认为，程序开发和平时的说话写字其实没有太大区别，无非三者 —— 逻辑和抽象。 领域知识。 语感。 写代码，就像写作，而设计 API 好比列提纲。勤写、勤思，了解前人的模式、套路，学习一些流行库的设计方法，掌握英语、提高语感……相信大家都能设计出卓越的 API。 最后，附上 API 设计的经典原则： Think about future, design with flexibility, but only implement for production. 引用 Framework Design Guidelines.aspx) Page Visibility 的 API 设计 我心目中的优秀 API Clean Code JavaScript 题图：只是一张符合上下文的图片，并没有更深的含义。 花絮：由于文章很长，在编写过程中我也不由得发生了「同一个意思却使用多种表达方式」的情况。某些时候这是必要的 —— 可以丰富文字的多样性；而有些时候，则显得全文缺乏一致性。在发表本文之前，我搜索了这些词语：「调用者」、「调用方」、「引用者」、「使用者」，然后将它们统一修改为我们熟悉的名字：「用户」。]]></content>
      <categories>
        <category>Web开发</category>
      </categories>
      <tags>
        <tag>API设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS in JS 简介 「阮一峰」]]></title>
    <url>%2Fblog%2F2017-06-02.CSS-in-JS-brief%2F</url>
    <content type="text"><![CDATA[CSS in JS 简介作者： 阮一峰 日期： 2017年4月 5日 1、 以前，网页开发有一个原则，叫做“关注点分离”（separation of concerns）。 它的意思是，各种技术只负责自己的领域，不要混合在一起，形成耦合。对于网页开发来说，主要是三种技术分离。 HTML 语言：负责网页的结构，又称语义层 CSS 语言：负责网页的样式，又称视觉层 JavaScript 语言：负责网页的逻辑和交互，又称逻辑层或交互层 简单说，就是一句话，不要写”行内样式”（inline style）和”行内脚本”（inline script）。比如，下面代码就很糟糕（查看完整代码）。 12345&gt; &lt;h1 style="color:red;font-size:46px;" onclick="alert('Hi')"&gt;&gt; Hello World&gt; &lt;/h1&gt;&gt;&gt; 2、 React 出现以后，这个原则不再适用了。因为，React 是组件结构，强制要求把 HTML、CSS、JavaScript 写在一起。 上面的例子使用 React 改写如下（查看完整代码）。 123456789101112131415&gt; const style = &#123;&gt; 'color': 'red',&gt; 'fontSize': '46px'&gt; &#125;;&gt;&gt; const clickHandler = () =&gt; alert('hi');&gt;&gt; ReactDOM.render(&gt; &lt;h1 style=&#123;style&#125; onclick=&#123;clickHandler&#125;&gt;&gt; Hello, world!&gt; &lt;/h1&gt;,&gt; document.getElementById('example')&gt; );&gt;&gt; 上面代码在一个文件里面，封装了结构、样式和逻辑，完全违背了”关注点分离”的原则，很多人不适应。 但是，这有利于组件的隔离。每个组件包含了所有需要用到的代码，不依赖外部，组件之间没有耦合，很方便复用。所以，随着 React 的走红和组件模式深入人心，这种”关注点混合”的新写法逐渐成为主流。 3、 表面上，React 的写法是 HTML、CSS、JavaScript 混合在一起。但是，实际上不是。现在其实是用 JavaScript 在写 HTML 和 CSS。 React 在 JavaScript 里面实现了对 HTML 和 CSS 的封装，我们通过封装去操作 HTML 和 CSS。也就是说，网页的结构和样式都通过 JavaScript 操作。 4、 React 对 HTML 的封装是 JSX 语言 ，这个在各种 React 教程都有详细介绍，本文不再涉及了，下面来看 React 对 CSS 的封装。 React 对 CSS 封装非常简单，就是沿用了 DOM 的 style 属性对象，这个在前面已经看到过了。 123456&gt; const style = &#123;&gt; 'color': 'red',&gt; 'fontSize': '46px'&gt; &#125;;&gt;&gt; 上面代码中，CSS 的font-size属性要写成fontSize，这是 JavaScript 操作 CSS 属性的约定。 由于 CSS 的封装非常弱，导致了一系列的第三方库，用来加强 React 的 CSS 操作。它们统称为 CSS in JS，意思就是使用 JS 语言写 CSS。根据不完全统计，各种 CSS in JS 的库至少有47种。老实说，现在也看不出来，哪一个库会变成主流。 你可能会问，它们与”CSS 预处理器”（比如 Less 和 Sass，包括 PostCSS）有什么区别？回答是 CSS in JS 使用 JavaScript 的语法，是 JavaScript 脚本的一部分，不用从头学习一套专用的 API，也不会多一道编译步骤。 5、 上周，我看到一个新的 CSS in JS 库，叫做 polished.js。它将一些常用的 CSS 属性封装成函数，用起来非常方便，充分体现使用 JavaScript 语言写 CSS 的优势。 我觉得这个库很值得推荐，这篇文章的主要目的，就是想从这个库来看怎么使用 CSS in JS。 首先，加载 polished.js。 123&gt; const polished = require('polished');&gt;&gt; 如果是浏览器，插入下面的脚本。 1234&gt; &lt;script src="https://unpkg.com/polished@1.0.0/dist/polished.min.js"&gt;&gt; &lt;/script&gt;&gt;&gt; polished.js目前有50多个方法，比如clearfix方法用来清理浮动。 12345&gt; const styles = &#123;&gt; ...polished.clearFix(),&gt; &#125;;&gt;&gt; 上面代码中，clearFix就是一个普通的 JavaScript 函数，返回一个对象。 12345678910&gt; polished.clearFix()&gt; // &#123;&gt; // &amp;::after: &#123;&gt; // clear: "both",&gt; // content: "",&gt; // display: "table"&gt; // &#125;&gt; // &#125;&gt;&gt; “展开运算符”（...）将clearFix返回的对象展开，便于与其他 CSS 属性混合。然后，将样式对象赋给 React 组件的style属性，这个组件就能清理浮动了。 123456&gt; ReactDOM.render(&gt; &lt;h1 style=&#123;style&#125;&gt;Hello, React!&lt;/h1&gt;,&gt; document.getElementById('example')&gt; );&gt;&gt; 从这个例子，大家应该能够体会polished.js的用法。 6、 下面再看几个很有用的函数。 ellipsis将超过指定长度的文本，使用省略号替代（查看完整代码）。 123456789101112131415&gt; const styles = &#123;&gt; ...polished.ellipsis('200px')&gt; &#125;&gt;&gt; // 返回值&gt; // &#123;&gt; // 'display': 'inline-block',&gt; // 'max-width': '250px',&gt; // 'overflow': 'hidden',&gt; // 'text-overflow': 'ellipsis',&gt; // 'white-space': 'nowrap',&gt; // 'word-wrap': 'normal'&gt; // &#125;&gt;&gt; hideText用于隐藏文本，显示图片。 1234567891011121314&gt; const styles = &#123;&gt; 'background-image': 'url(logo.png)',&gt; ...polished.hideText(),&gt; &#125;;&gt;&gt; // 返回值&gt; // &#123;&gt; 'background-image': 'url(logo.png)',&gt; 'text-indent': '101%',&gt; 'overflow': 'hidden',&gt; 'white-space': 'nowrap',&gt; &#125;&gt;&gt; hiDPI指定高分屏样式。 12345678910111213141516&gt; const styles = &#123;&gt; [polished.hiDPI(1.5)]: &#123;&gt; width: '200px',&gt; &#125;&gt; &#125;;&gt;&gt; // 返回值&gt; //'@media only screen and (-webkit-min-device-pixel-ratio: 1.5),&gt; // only screen and (min--moz-device-pixel-ratio: 1.5),&gt; // only screen and (-o-min-device-pixel-ratio: 1.5/1),&gt; // only screen and (min-resolution: 144dpi),&gt; // only screen and (min-resolution: 1.5dppx)': &#123;&gt; // 'width': '200px',&gt; //&#125;&gt;&gt; retinaImage为高分屏和低分屏设置不同的背景图。 123456789101112131415&gt; const styles = &#123;&gt; ...polished.retinaImage('my-img')&gt; &#125;;&gt;&gt; // 返回值&gt; // backgroundImage: 'url(my-img.png)',&gt; // '@media only screen and (-webkit-min-device-pixel-ratio: 1.3),&gt; // only screen and (min--moz-device-pixel-ratio: 1.3),&gt; // only screen and (-o-min-device-pixel-ratio: 1.3/1),&gt; // only screen and (min-resolution: 144dpi),&gt; // only screen and (min-resolution: 1.5dppx)': &#123;&gt; // backgroundImage: 'url(my-img_2x.png)',&gt; // &#125;&gt;&gt; 7、 polished.js提供的其他方法如下，详细用法请参考文档。 normalize()：样式表初始化 placeholder()：对 placeholder 伪元素设置样式 selection()：对 selection 伪元素设置样式 darken()：调节颜色深浅 lighten()：调节颜色深浅 desaturate()：降低颜色的饱和度 saturate()：增加颜色的饱和度 opacify()：调节透明度 complement()：返回互补色 grayscale()：将一个颜色转为灰度 rgb()：指定红、绿、蓝三个值，返回一个颜色 rgba()：指定红、绿、蓝和透明度四个值，返回一个颜色 hsl()：指定色调、饱和度和亮度三个值，返回一个颜色 hsla()：指定色调、饱和度、亮度和透明度三个值，返回一个颜色 mix()：混合两种颜色 em()：将像素转为 em rem()：将像素转为 rem 目前，polished.js只是1.0版，以后应该会有越来越多的方法。 8、 polished.js还有一个特色：所有函数默认都是柯里化的，因此可以进行函数组合运算，定制出自己想要的函数。 123456&gt; import &#123; compose &#125; from 'ramda';&gt; import &#123; lighten, desaturate &#125; from 'polished';&gt;&gt; const tone = compose(lighten(10), desaturate(10))&gt;&gt; 上面代码使用 Ramda 函数库完成组合运算。Ramda 的用法可以参考我写的教程。 （正文完）]]></content>
      <categories>
        <category>Web开发.React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typora – 终于有一款优美的 Markdown 编辑器[Win/macOS]]]></title>
    <url>%2Fblog%2F2017-06-02.md-best-offline-client%2F</url>
    <content type="text"><![CDATA[0x00 偶然间的邂逅今天偶然间看到了 Typora ， 看了下他的文档， 很好的符合我的要求， 配合 Hexo 使用， 简直完美。下面是 appinn 的评价： 青小蛙 on 2016.07.16. Typora 是一款 Markdown 编辑器，拥有 Windows、macOS 客户端，可以算作一款 Windows 下难得的好看、优美的客户端。@Appinn 0x01 需求对于 md ， 图片一直是个痛点， 看到 Typora 可以支持 Paste images from clipboard , 立刻两眼放光，稍加验证， 完全可以满足需求 。 而且 ， 提供了一些人性化的 快捷键，可以更优雅的编写 md 文件了 :) 。 而且 可以直接在 渲染后的效果进行书写，这个效果很棒。这是一种其他编辑器都没有的体验。 0x02 粘贴图片的配置 官方文档 in English Images in Typora 如果要达到 从 clipboard 粘贴图片的效果， Typora 要求提供图片的存放路径， 这里稍有不足的地方是 – 需要针对每个文件都进行调整。 操作步骤 Paste images from clipboard Since Markdown file is only plain text file, users could not insert image data into Markdown file directly, but can insert image reference to file/url. Typora support paste image data from clipboard, after telling typora where to put those images. Typora would put image data into given folder or server, then insert images referring to that stored file or url One common scenario is to edit *.md posts in static sites (like Jekyll) using Typora. For example, if the .*md file is put under _posts folder while the image files goes into _media folder, you may want to copy images files into folder _media when you drag/drop or paste images into Markdown file automatically. Here’s how: Save your file into some path. (md 文件必须被保存后) Enable Editor → Image Insert → Allow copy images to given folder in preferences panel. Select Edit → Image Tools → When Insert Local Images → Copy Image File to Folder from menubar, pick the target folder. In step 3, a new item typora-copy-images-to: {relative path} will be inserted into the YAML Front Matter block of current document. So you could also manually add typora-copy-images-to property in YAML Front Matter to enable this behaviour. 在 step 3 中，会在文件中添加 YAML 信息， 类似如下效果： 1234---typora-copy-images-to: &lt;path&gt;typora-root-url: &lt;path&gt;--- After that, if you drag &amp; drop local images or paste images into Typora, the image file will be copied into the target file and update related src. 这样操作完成后， 不管是 拖拽 还是 粘贴， 图片都会 被拷贝到 target 目录， 并更新相关的 image 的相对地址。 结合 Hexo 使用参考 之前的文章 在 hexo 中无痛使用本地图片 确保 按 2.1 中的配置好后， 做如下修改，以后就可以基本不用考虑 图片的痛点了： 修改 scaffolds 下面的 post.md 和 draft.md ， 添加如下 YAML ： 12typora-copy-images-to: &#123;&#123; title &#125;&#125;typora-root-url: &#123;&#123; title &#125;&#125; 以后用 hexo new &lt;post&gt; 方式生成的文件，就可以直接贴图片了，这里稍微要注意的地方是： 因为 hexo-asset-image会忽略 以/开头的图片，所以要手动的把 ![123](/123.jpg) 路径中的 /去掉。]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 Hexo 中无痛使用本地图片]]></title>
    <url>%2Fblog%2F2017-06-01.no-pains-with-hexo-local-image%2F</url>
    <content type="text"><![CDATA[原文：http://www.tuicool.com/articles/umEBVfIhttp://codefalling.com/2015/12/19/no-pains-with-hexo-local-image/ 已失效 1 起因在 hexo 中使用本地图片是件非常让人纠结的事情，在 markdown 里的图片地址似乎永远无法和最后生成的网页保持一致。 这些问题使得我一度不愿意使用本地图片而选择用图床，但被移动运营商无耻的横条广告逼得打算上 https，图床只支持 http 就成了问题。 hexo 下插入图片现在大概有几个方案 1.1 放在根目录早期大部分的方案是把图片放在 source/img下，然后在 markdown 里写 ![img](/source/img/img.png)。显然这样在本地的编辑器里完全不能正确识别图片的位置。 1.2 asset-image在 hexo 2.x 时出现的插件，后来被吸纳进 hexo 3 core，用法的介绍见 资源文件夹 | Hexo。比较尴尬的是，这种方法直接放弃了 markdown 原来的语法，使用类似 ``的语法，。markdown 本来有插入图片的语法不好好支持，专门用一个新的语法来插入本地图片，让我这种强迫症不太能接受。 2 解决方案CodeFalling/hexo-asset-image 2.1使用首先确认 _config.yml中有 post_asset_folder:true。 在 hexo 目录，执行 1234npm install https://github.com/CodeFalling/hexo-asset-image --save# 在 pull request merged 之前使用下面的npm install https://github.com/yafey/hexo-asset-image --save 假设在 12345MacGesture2-Publish├── apppicker.jpg├── logo.jpg└── rules.jpgMacGesture2-Publish.md 这样的目录结构（目录名和文章名一致），只要使用 ![logo](MacGesture2-Publish/logo.jpg)就可以插入图片。 生成的结构为 12345public/2015/10/18/MacGesture2-Publish├── apppicker.jpg├── index.html├── logo.jpg└── rules.jpg 同时，生成的 html 是 1&lt;img src="/HexoBlog/2015/10/18/MacGesture2-Publish/logo.jpg" alt="logo"&gt; 而不是愚蠢的 1&lt;img src="MacGesture2-Publish/logo.jpg" alt="logo"&gt; 值得一提的是，这个插件对于( yafey 注：我现在还不知道这货是干嘛用的 –&gt; ) CodeFalling/hexo-renderer-org 同样有效。 2.1.1 兼容性问题？在本地使用过程中发现，在 使用了 hexo-asset-image 之后， 如果更新了文件， 预览的时候 文件就无法正常显示， 一定要 重新 hexo g ， 然后 hexo s -p 80 才能预览， 这个估计值得 enhance ， 可以去 提个 issue 。 2.2 第一次 raise a pull request to an open source project因为我的 Hexo 现在是放在 xxx.github.io/HexoBlog 上的， hexo-asset-image 生成的 link 原先是 不带 HexoBlog 的，竟然被我稀里糊涂的改掉了， 那就 raise pull request 给 作者吧， 这算是我第一次给 open source 提 pull request ， 以后也可以说是 给 open source 做过贡献了 :) 。 pull request 链接 ： https://github.com/CodeFalling/hexo-asset-image/pull/25/files]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nvm or N]]></title>
    <url>%2Fblog%2F2017-06-01.node-version-control-nvm-or-n%2F</url>
    <content type="text"><![CDATA[如何选择 nvm 还是 n ? 管理 node 版本，选择 nvm 还是 n？@「淘宝前端团队(FED)」 nvm 和 n 的差异还是比较大的，具体体现在： 安装简易度。nvm 安装起来显然是要麻烦不少；n 这种安装方式更符合 node 的惯性思维。见仁见智吧。 系统支持。注意， nvm 不支持 Windows n 不支持 windows。 对全局模块的管理。n 对全局模块毫无作为，因此有可能在切换了 node 版本后发生全局模块执行出错的问题；nvm 的全局模块存在于各自版本的沙箱中，切换版本后需要重新安装，不同版本间也不存在任何冲突。 关于 node 路径。n 是万年不变的 /usr/local/bin；nvm 需要手动指定路径。 所以，如何选择？真心见仁见智了，不过这里可以给出大体的建议： 如果你使用 Windows，那没得选了，使用 n，或者换一台 Mac。 如果你会频繁切换 node 版本（比如本地经常测试最新版的特性，同时又要兼顾代码在生产环境的兼容性），那么从全局模块兼容性的角度考虑，只能使用 nvm。 如果你是一个轻量级的用户，不需要担心兼容性的问题，更关心 node 安装和使用上的体验，那么选择 n。 你如果要问，楼主最终选用了谁？我会说，我选择了更流行的那一个。 升级node.js和npm [注] 参考：https://segmentfault.com/a/1190000009025883 n 模块不支持windows系统，官方文档(Unfortunately n is not supported on Windows yet. If you’re able to make it work, send in a pull request!) 一行命令搞定npm和node.js的升级，省去了重新编译和安装的过程。具体如下： 升级node.jsnpm中有一个模块叫做 “n”，专门用来管理node.js版本的。 更新到最新的稳定版只需要在命令行中打下如下代码： 12345# 第一步，安装 n (n 模块不支持 windows 系统)npm install -g n# 第二步，升级 node 到最新稳定版本n stable 如需最新版本则用n latest 当然，n后面也可以跟具体的版本号：n v6.2.0 或 n 6.2.0 node.js升级就是这么简单。 升级npmnpm升级就更简单了，只需要在终端中输入： 1npm -g install npm@next 补充常用 npm 命令 参考 ： https://segmentfault.com/a/1190000006869650 1234567891011121314151617$ npm -v #显示版本，检查npm 是否正确安装。 $ npm install express #安装express模块 $ npm install -g express #全局安装express模块 $ npm list #列出已安装模块 $ npm show express #显示模块详情 $ npm update #升级当前目录下的项目的所有模块 $ npm update express #升级当前目录下的项目的指定模块 $ npm update -g express #升级全局安装的express模块 $ npm uninstall express #删除指定的模块 Windows 强行安装 n 模块（然并软） 参考 ： http://blog.csdn.net/u013474104/article/details/52197772 123456789101112131415PS C:\Users\yafey&gt; npm install -g nnpm ERR! Windows_NT 10.0.14393npm ERR! argv "C:\\_installed_soft\\nodejs\\node.exe" "C:\\_installed_soft\\nodejs\\node_modules\\npm\\bin\\npm-cli.js" "install" "-g" "n"npm ERR! node v6.9.2npm ERR! npm v3.10.9npm ERR! code EBADPLATFORMnpm ERR! notsup Unsupported platform for n@2.1.7: wanted &#123;"os":"!win32","arch":"any"&#125; (current: &#123;"os":"win32","arch":"x64"&#125;)npm ERR! notsup Valid OS: !win32npm ERR! notsup Valid Arch: anynpm ERR! notsup Actual OS: win32npm ERR! notsup Actual Arch: x64npm ERR! Please include the following file with any support request:npm ERR! C:\Users\yafey\npm-debug.log 解决方案在后面加上 --force 即可。 1npm install -g n --force 然并软该报错 还是 继续报错。 1234PS C:\Users\yafey&gt; n stable/bin/bash: C:\Users\yafey\AppData\Roaming\npm\node_modules\n\bin\n: No such file or directoryPS C:\Users\yafey&gt; n v4.4.7/bin/bash: C:\Users\yafey\AppData\Roaming\npm\node_modules\n\bin\n: No such file or directory]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git_clone_include_submodule]]></title>
    <url>%2Fblog%2F2017-06-01.git-clone-include-submodule%2F</url>
    <content type="text"><![CDATA[git clone 指定分支，并 register and update submodulesIf your submodule was added in a branch be sure to include it in your clone command…1git clone -b &lt;branch_name&gt; --recursive &lt;remote&gt; &lt;directory&gt; If --recursive is specified, this command will recurse into the registered submodules, and update any nested submodules within. 参考： How to `git clone` including submodules?]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>submodule</tag>
        <tag>clone</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tools]]></title>
    <url>%2Fblog%2F2017-05-31.tools%2F</url>
    <content type="text"><![CDATA[Web tool.oschina Bootcss 前端开发资源导航 Linux explainshell Miscellaneous (杂项) Youtube downloader 伪射手字幕 谷粉搜搜-谷歌替代品 【c#版】我为开源做贡献，网页正文提取——Html2Article 【php版】如何将CSDN的文章转成.md的markdown文件 GitPage 上的镜像React 【推荐】胡子大哈的 《React 小书》 | 自己github镜像 ES6 《ES6 标准入门》（第二版）出版了 by 阮一峰 | 自己github镜像 参考自 ： http://www.zipperary.com/tools/ 临时链接 ： bk.html]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fblog%2F2017-05-28.hello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>new to Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Doc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HelloHexo Test]]></title>
    <url>%2Fblog%2F2017-05-28.HelloHexo-Test%2F</url>
    <content type="text"><![CDATA[测试 1Git submodules: Specify a branch/taghttps://stackoverflow.com/questions/1777854/git-submodules-specify-a-branch-tagumläute refines dtmland’s command with a simplified version in the comments:1git submodule foreach -q --recursive 'git checkout $(git config -f $toplevel/.gitmodules submodule.$name.branch || echo master)' multiple lines:123git submodule foreach -q --recursive \ 'git checkout \ $(git config -f $toplevel/.gitmodules submodule.$name.branch || echo master)' GETTING GIT SUBMODULE TO TRACK A BRANCH (add submodule 的步骤)https://www.activestate.com/blog/2014/05/getting-git-submodule-track-branch 删除 submodule : git rm --cached &lt;mysubmodule&gt; add submodule : git submodule add --force -b BUAT &lt;git url&gt; &lt;submodule path&gt; Add a submodule which can’t be removed from the indexhttps://stackoverflow.com/questions/12218420/add-a-submodule-which-cant-be-removed-from-the-index If the output adding a new submodule is: 12345678 #'FolderName' already exists in the index # Tip the next commandsgit ls-files --stage # The output will be something similar to:160000 d023657a21c1bf05d0eeaac6218eb5cca8520d16 0 FolderName # Then, to remove the folder index tip:git rm -r --cached FolderName #Try again add the submodule]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>